<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="使用设计模块注意度，结合业务，不能过度设计。
组合模式
单例模式
只能产生一个实例对象。实例为静态成员，构造方法为private，静态方法返回惟一实例。
单例类一般不要实现Cloneable接口，若一个类实现了Cloneable接口且实现了clone()方法，那么这个类可以被复制，类复制时不需要调用">
    

    <!--Author-->
    
        <meta name="author" content="mamian">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="设计模式读书笔记"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="马面"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

        <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>设计模式读书笔记 - 马面</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    


</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">马面</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives/index.html">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags/index.html">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories/index.html">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/about/index.html">
                            
                                About
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/mamian">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('http://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>设计模式读书笔记</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        2016-08-15
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/设计模式/">#设计模式</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                        

<a href="/categories/读书笔记/">读书笔记</a>

                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <p>使用设计模块注意度，结合业务，不能过度设计。</p>
<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a><center>组合模式</center></h1><hr>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><center>单例模式</center></h1><ul>
<li>只能产生一个实例对象。实例为静态成员，构造方法为private，静态方法返回惟一实例。</li>
<li>单例类一般不要实现Cloneable接口，若一个类实现了Cloneable接口且实现了clone()方法，那么这个类可以被复制，类复制时不需要调用构造方法。单例将被破坏。</li>
<li>一个单例对象在内存中长久不使用，JVM会认为这个对象是一个垃圾，将会对其进行回收。但若采用J2EE容器或框架级容器（如Spring容器），可以让对象长久驻留内存。</li>
<li>spring中每个bean默认均为单例，这样做spring容器可以管理bean的生命周期。若采用非单例模式（如prototype）,则bean初始化后的管理交由j2ee容器管理，spring容器不再管理。</li>
<li><p>代码示例</p>
<ul>
<li><p>饱汉式：线程不安全，可通过synchronized来解决</p>
<pre><code>public class Singleton {

    private static Singleton item;

    private Singleton(){}

    public static Singleton getInstance() {
        if(item==null)
            item = new Singleton();
        return item;
    }
}
</code></pre></li>
<li><p>线程安全：</p>
<pre><code>public class Singleton {

    private static Singleton item;

    private Singleton(){}

    public static Singleton getInstance() {
        if(item==null){
            synchronized (Singleton.class) {
                if (item == null) {// Double checked
                    item = new Singleton();
                }
            }
        }
        return item;
    }
}
</code></pre></li>
<li><p>饿汉式</p>
<pre><code>public class Singleton {
    private static Singleton item = new Singleton();

    private Singleton(){}

    public static Singleton getInstance() {
        return item;
    }
}
</code></pre></li>
</ul>
</li>
</ul>
<hr>
<h1 id="多例模式"><a href="#多例模式" class="headerlink" title="多例模式"></a><center>多例模式</center></h1><hr>
<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a><center>状态模式</center></h1><hr>
<h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a><center>责任链模式</center></h1><hr>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a><center>观察者模式</center></h1><hr>
<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a><center>命令模式</center></h1><hr>
<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a><center>中介者模式</center></h1><ul>
<li>定义：将多对多关系转化为多对一的关系。Buy、Sell、Store对象均继承自AbstractColleague（AbstractColleague中包含一个中介者对象，其所有的实现类均可执行此中介者的某方法）。</li>
<li>抽象中介者AbstractMediator包含所有原多对多的具体类。Mediator实现了所有具体的业务逻辑，具体业务类如Buy通过调用自己的成员media的方法来实现业务逻辑。</li>
<li>优点：减少类间依赖</li>
<li>缺点：中介者本身会膨胀的很大且逻辑复杂。</li>
<li>代码：</li>
</ul>
<pre><code>public class AbstractColleague {//包含一个protected修饰的抽象中介者对象mediator，其所有的对象可共享此中介者并调用此中介者的方法

    protected AbstractMediator mediator;



    public AbstractColleague(AbstractMediator mediator) {

        this.mediator = mediator;

    }

}



public class Buy extends AbstractColleague{

    public Buy(AbstractMediator mediator){

        super(mediator);

    }

    public void startBuy(int num){

        super.mediator.execute(&quot;购买&quot;, num);

        System.out.println(&quot;Buy对象执行startBuy方法&quot;);

    }

    public void NotBuy(){

        System.out.println(&quot;Buy对象执行NotBuy方法&quot;);

    }

}



public class Sell extends AbstractColleague{

    public Sell(AbstractMediator mediator){

        super(mediator);

    }

    public void startSell(int num){

        super.mediator.execute(&quot;销售&quot;, num);

        System.out.println(&quot;Sell对象执行startSell方法&quot;);

    }

}



public class Store extends AbstractColleague{

    public Store(AbstractMediator mediator){

        super(mediator);

    }

    public void startStore(int num){

        super.mediator.execute(&quot;存储&quot;, num);

        System.out.println(&quot;Store对象执行startStore方法&quot;);

    }

}



public abstract class AbstractMediator {//抽象中介者：包含所有需将其作为中介者来互相交互信息的子系统或对象

    protected Buy buy;

    protected Sell sell;

    protected Store store;



    public AbstractMediator(){

        buy = new Buy(this);

        sell = new Sell(this);

        store = new Store(this);

    }

    public abstract void execute(String message,Object obj1);

}



public class Mediator extends AbstractMediator{

    public void execute(String message, Object obj1) {//参数为判断执行哪个对象方法的条件和参数

        if(message.equals(&quot;购买&quot;)){

            buyComputer((Integer) obj1);

            System.out.println(&quot;具体中介者mediator的execute方法&quot;+message);

        }else if(message.equals(&quot;销售&quot;)){

            sellComputer((Integer) obj1);

            System.out.println(&quot;具体中介者mediator的execute方法&quot;+message);

        }else if(message.equals(&quot;存储&quot;)){

            storeComputer((Integer) obj1);

            System.out.println(&quot;具体中介者mediator的execute方法&quot;+message);

        }

    }

    private void buyComputer(int num){

        System.out.println(&quot;具体中介者执行buyComputer方法，购&quot;+num+&quot;台电脑&quot;);

    }

    private void sellComputer(int num){

        System.out.println(&quot;具体中介者执行sellComputer方法，售&quot;+num+&quot;台电脑&quot;);

    }

    private void storeComputer(int num){

        System.out.println(&quot;具体中介者执行storeComputer方法，存&quot;+num+&quot;台电脑&quot;);

    }

}



public class Client {

    public static void main(String[] args){

        AbstractMediator mediator = new Mediator();



        Buy buy = new Buy(mediator);

        buy.startBuy(100);



        Sell sell = new Sell(mediator);

        sell.startSell(200);



        Store store = new Store(mediator);

        store.startStore(300);

    }

}
</code></pre><hr>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a><center>代理模式</center></h1><ul>
<li>为其他对象提供一种代理以控制对这个对象的访问。</li>
<li>代理模式也叫做委托模式，许多其他的模式如状态模式、策略模式、访问者模式本质上是在更特殊的场合采用了委托模式。</li>
<li>struts2的form元素映射就采用了动态代理模式。spring aop是非常典型的动态代理。</li>
<li>GG请Proxy代替他去追MM,GG包含一个MM,Proxy包含一个GG</li>
<li>Proxy的方法中执行的是GG的同名方法Proxy</li>
<li>Proxy与GG具有相同的方法，抽取其共性为Same_ProxyAndGG</li>
<li>代码</li>
</ul>
<pre><code>public class Same_ProxyAndGG {

    public void giveGiftA(){
    }

    public void giveGiftB(){
    }

    public void giveGiftC(){
    }

}


public class MM {

    private String name;//set  get

    public MM(String name) {
        this.name = name;
    }

}


public class GG extends Same_ProxyAndGG{

    private MM mm;

    public GG(MM mm){
        this.mm = mm;
    }

    public void giveGiftA(){
        System.out.println(&quot;GG送给&quot;+mm.getName()+&quot; GiftA&quot;);
    }

    public void giveGiftB(){
        System.out.println(&quot;GG送给&quot;+mm.getName()+&quot; GiftB&quot;);
    }

    public void giveGiftC(){
        System.out.println(&quot;GG送给&quot;+mm.getName()+&quot; GiftC&quot;);
    }

}


public class Proxy extends Same_ProxyAndGG{

    private GG gg;

    public Proxy(GG gg) {
        this.gg = gg;
    }

    public void giveGiftA(){
        gg.giveGiftA();
    }

    public void giveGiftB(){
        gg.giveGiftB();
    }

    public void giveGiftC(){
        gg.giveGiftC();
    }

}


public class Client {
    public static void main(String[] args){

        MM mm = new MM(&quot;漂亮妹纸&quot;);
        GG gg = new GG(mm);

        Proxy proxy = new Proxy(gg);



        proxy.giveGiftA();
        proxy.giveGiftB();
        proxy.giveGiftC();
    }
}
</code></pre><h3 id="动态代理（spring-aop）"><a href="#动态代理（spring-aop）" class="headerlink" title="动态代理（spring aop）"></a>动态代理（spring aop）</h3><ul>
<li>静态代理：由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。 </li>
<li>动态代理<ul>
<li>在程序运行时，运用反射机制动态创建而成。</li>
<li>动态代理是在实现阶段不用关心代理谁，在运行阶段才指定代理哪一个对象。</li>
</ul>
</li>
<li>aop：切面(Aspect)、切入点(JoinPoint)、通知(Advice)、织入(Weave)</li>
<li><p>java.lang.reflect包中的Proxy类和InvocationHandler接口提供了生成动态代理类的能力。</p>
<ul>
<li><p>InvocationHandler接口</p>
<pre><code>public interface InvocationHandler { 
    public Object invoke(Object proxy,Method method,Object[] args) throws Throwable; 
}

参数说明： 
Object proxy：指被代理的对象。 
Method method：要调用的方法 
Object[] args：方法调用时所需要的参数 
</code></pre></li>
<li><p>Proxy类：专门完成代理的操作类，可通过此类为一个或多个接口动态地生成实现类，此类提供了如下的操作方法： </p>
</li>
</ul>
</li>
</ul>
<pre><code>public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException 
参数说明： 
ClassLoader loader：类加载器 
Class&lt;?&gt;[] interfaces：得到全部的接口 
InvocationHandler h：得到InvocationHandler接口的子类实例
</code></pre><ul>
<li>代码</li>
</ul>
<hr>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a><center>策略模式</center></h1><hr>
<h1 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a><center>备忘录模式</center></h1><hr>
<h1 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a><center>模板模式</center></h1><ul>
<li>当我们写一个文档时（如需求文档）通常首先要找一个模板，模板里会清楚的写着要写几大模块且说明这些模块的先后顺序。我们再照着模板填充每一模块的具体内容。</li>
<li>定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</li>
<li>基本方法：由子类实现的方法，并且在模板方法中被调用。</li>
<li>模板方法：一个框架，实现对基本方法的调度，完成固定的逻辑。为防止恶意操作，一般模板方法会加final关键字，不允许覆盖。</li>
<li>父类模板中用一个方法规定了其所有子类要执行的一系列方法的顺序，即定义中所说的算法的框架。在高层的执行步骤是确定的（即每一步要实现什么功能），但具体执行的操作，每个子类均有自己的实现（即每一步具体如何实现，各子类均不同）。</li>
<li>代码</li>
</ul>
<pre><code>public abstract class Model {

    protected abstract void start();//protected

    protected abstract void alarm();

    protected abstract void stop();

    public final void run(){//final

        this.start();
        this.alarm();
        this.stop();

    }

}

public class ModelA extends Model{

    protected void start() {
        System.out.println(&quot;车辆A启动&quot;);
    }

    protected void alarm() {
        System.out.println(&quot;车辆A鸣笛&quot;);
    }

    protected void stop() {
        System.out.println(&quot;车辆A刹车&quot;);
    }

}

public class ModelB extends Model{

    protected void start() {
        System.out.println(&quot;车辆B启动&quot;);
    }

    protected void alarm() {
        System.out.println(&quot;车辆B鸣笛&quot;);
    }

    protected void stop() {
        System.out.println(&quot;车辆B刹车&quot;);
    }

}

public class Client {

    public static void main(String[] args){
        Model modelA = new ModelA();
        modelA.run();

        Model modelB = new ModelB();
        modelB.run();
    }

}
</code></pre><hr>
<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a><center>建造者模式</center></h1><ul>
<li>定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</li>
<li>与模板模式类似，建造者模式增加建造者且模板父类中增加了方法执行顺序变量sequence</li>
<li>建造者实现两个方法：一个返回要建造的对象，另一个设置要建造的对象中的通用方法中调用自身方法的顺序</li>
<li>Client中实例sequence和具体Builder，并执行Builder中的model的某方法。</li>
<li>具体建建类封装了构建细节，并返回构建好的对象。</li>
<li>与工厂模式的区别：建造者模块关注方法执行的顺序（方法本身已实现），即零件的组装顺序不同产生的对象也不同；工厂模式关注零件本身的创建，不关注组装顺序。</li>
<li>代码</li>
</ul>
<pre><code>public abstract class Model {

    private ArrayList&lt;String&gt; sequence = new ArrayList&lt;String&gt;();

    public final void setSequence(ArrayList&lt;String&gt; sequence){

        this.sequence = sequence;

    }

    final public void run(){

        for(int i=0;i&lt;sequence.size();i++){

            String nowOrperate = sequence.get(i);

            if(nowOrperate.equals(&quot;start&quot;)){
                this.start();
            }else if(nowOrperate.equals(&quot;alarm&quot;)){
                this.alarm();
            }else if(nowOrperate.equals(&quot;stop&quot;)){
                this.stop();
            }

        }

    }

    protected abstract void start();

    protected abstract void alarm();

    protected abstract void stop();

}

public class ModelA extends Model{

    protected void start() {
        System.out.println(&quot;车辆A启动&quot;);
    }

    protected void alarm() {
        System.out.println(&quot;车辆A鸣笛&quot;);
    }

    protected void stop() {
        System.out.println(&quot;车辆A刹车&quot;);
    }

}

public class ModelB extends Model{

    protected void start() {
        System.out.println(&quot;车辆B启动&quot;);
    }

    protected void alarm() {
        System.out.println(&quot;车辆B鸣笛&quot;);
    }

    protected void stop() {
        System.out.println(&quot;车辆B刹车&quot;);
    }

}

public abstract class Builder {

    public abstract void setSequence(ArrayList&lt;String&gt; sequence);

    public abstract Model getModel();

}

public class BuilderA extends Builder{

    private ModelA modelA = new ModelA();

    public void setSequence(ArrayList&lt;String&gt; sequence) {
        modelA.setSequence(sequence);
    }

    public Model getModel() {
        return modelA;
    }

}

public class BuilderB extends Builder{

    private ModelB modelB = new ModelB();

    public void setSequence(ArrayList&lt;String&gt; sequence) {
        modelB.setSequence(sequence);
    }

    public Model getModel() {
        return modelB;
    }

}

public class Client {

    public static void main(String[] args){

        ArrayList&lt;String&gt; sequence1 = new ArrayList&lt;String&gt;();

        sequence1.add(&quot;alarm&quot;);
        sequence1.add(&quot;start&quot;);
        sequence1.add(&quot;stop&quot;);

        Builder builderA = new BuilderA();
        builderA.setSequence(sequence1);
        builderA.getModel().run();

        ArrayList&lt;String&gt; sequence2 = new ArrayList&lt;String&gt;();
        sequence2.add(&quot;start&quot;);
        sequence2.add(&quot;alarm&quot;);
        sequence2.add(&quot;stop&quot;);

        Builder builderB = new BuilderB();
        builderB.setSequence(sequence2);
        builderB.getModel().run();
    }

}
</code></pre><hr>
<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a><center>原型模式</center></h1><ul>
<li>定义：不通过new产生新对象而是通过clone来实现的模式即为原型模式。</li>
<li>优点：clone方法直接拷贝内存二进制流，比new对象性能好很多。</li>
<li>缺点：直接在内存中拷贝，则构造函数不会执行。</li>
<li>浅拷贝：clone后的新对象与原对象使用的成员变化（数组类型、引用类型，但不包括String）为同一个对象，并未copy一个新变量给新对象。</li>
<li>clone()浅拷贝：Object类提供clone方法只是拷贝本对象(本对象的int、long、String等成员)，其对象内部的数组、引用对象等都不拷贝，还是指向原生对象的内部元素地址.</li>
<li>clone()深拷贝：thing.arrayList = (ArrayList<string>)this.arrayList.clone();</string></li>
<li>不可对final成员执行clone方法</li>
<li>代码：</li>
</ul>
<pre><code>public class AdvTemplate {

    private String advSubject =&quot;XX银行国庆信用卡抽奖活动&quot;;//广告信名称

    private String advContext = &quot;国庆抽奖通知：只要刷卡就送1百万！&quot;;//广告信内容


    public String getAdvSubject() {

        return advSubject;

    }

    public String getAdvContext() {

        return advContext;

    }

}


public class Mail implements Cloneable{

    private String receiver;//收件人   get  set

    private String subject;//邮件主题   get  set

    private String appellation;//称谓   get  set

    private String contxt;//邮件内容   get  set

    private String tail;//邮件的尾部，一般都是加上“XXX版权所有”等信息   get  set


    public Mail(AdvTemplate advTemplate) {

        this.subject = advTemplate.getAdvSubject();

        this.contxt = advTemplate.getAdvContext();

    }

    public Mail clone(){

        Mail mail = null;

        try{

            mail = (Mail)super.clone();

        }catch(CloneNotSupportedException e){

            e.printStackTrace();

        }

        return mail;

    }

}


public class Client {

    private static int MAX_COUNT = 6;//发送账单的数量，这个值是从数据库中获得

    public static void main(String[] args){//模拟发送邮件

        int i=0;

        //把模板定义出来，这个是从数据库中获得

        Mail mail = new Mail(new AdvTemplate());

        mail.setTail(&quot;XX银行版权所有&quot;);

        while(i&lt;MAX_COUNT){

            //以下是每封邮件不同的地方

            Mail cloneMail = mail.clone();

            cloneMail.setAppellation(getRandString(5)+&quot; 先生（女士）&quot;);

            cloneMail.setReceiver(getRandString(5) + &quot;@&quot; + getRandString(8)+&quot;.com&quot;);

            //然后发送邮件

            sendMail(cloneMail);

            i++;

        }

    }

    //发送邮件
    public static void sendMail(Mail mail){

        System.out.println(&quot;标题：&quot;+mail.getSubject() + &quot;\t收件人：&quot;+mail.getReceiver()+&quot;\t....发送成功！&quot;);

    }

    //获得指定长度的随机字符串

    public static String getRandString(int maxLength){

        String source =&quot;abcdefghijklmnopqrskuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;

        StringBuffer sb = new StringBuffer();

        Random rand = new Random();

        for(int i=0;i&lt;maxLength;i++){

            sb.append(source.charAt(rand.nextInt(source.length())));

        }

        return sb.toString();

    }

}
</code></pre><hr>
<h1 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a><center>门面模式</center></h1><hr>
<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a><center>享元模式</center></h1><hr>
<h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a><center>桥接模式</center></h1><hr>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a><center>适配器模式</center></h1><hr>
<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a><center>访问者模式</center></h1><hr>
<h1 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a><center>装饰模式</center></h1><hr>
<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a><center>简单工厂模式</center></h1><ul>
<li>Client中将参数传递给Factory，Factory根据参数决定生产哪个具体的实例类。</li>
<li>代码</li>
</ul>
<pre><code>public class Operater {

    public int getResult(int a,int b){
        return 0;
    }

}


public class OperaterAdd extends Operater{

    public int getResult(int addA,int addB){
        System.out.println(&quot;加法&quot;);
        return addA+addB;
    }

}


public class OperaterDiv extends Operater{

    public int getResult(int divA,int divB){
        System.out.println(&quot;除法&quot;);
        return divA/divB;
    }

}


public class Factory {

    private static Operater operater;

    public static Operater createOperater(char choose){
        switch(choose){
            case &apos;+&apos;:
                operater = new OperaterAdd();break;
            case &apos;/&apos;:
                operater = new OperaterDiv();break;
        }
        return operater;

    }

}


public class Client {
    public static void main(String[] args){
        Operater operater = Factory.createOperater(&apos;+&apos;);
        int result = operater.getResult(15,25);
    }
}
</code></pre><hr>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a><center>工厂模式</center></h1><ul>
<li>代码</li>
</ul>
<pre><code>public interface HumanInterface {

    public void laugh();

    public void cry();

    public void talk();

}

public class BlackHuman implements HumanInterface{

    public void laugh() {
        System.out.println(&quot;黑人会笑&quot;);
    }

    public void cry() {
        System.out.println(&quot;黑人会哭&quot;);
    }

    public void talk() {
        System.out.println(&quot;黑人可以说话，一般人听不懂&quot;);
    }

}


public class WhiteHuman implements HumanInterface{

    public void laugh() {
        System.out.println(&quot;白色人类会大笑，侵略的笑声&quot;);
    }

    public void cry() {
        System.out.println(&quot;白色人类会哭&quot;);
    }

    public void talk() {
        System.out.println(&quot;白色人类会说话，一般都是但是单字节！&quot;);
    }

}


public class YellowHuman implements HumanInterface{

    public void laugh() {
        System.out.println(&quot;黄色人类会大笑，幸福呀！&quot;);
    }

    public void cry() {
        System.out.println(&quot;黄色人类会哭&quot;);
    }

    public void talk() {
        System.out.println(&quot;黄色人类会说话，一般说的都是双字节&quot;);
    }

}


public class ClassUtils {

    //给一个接口，返回这个接口的所有实现类

    public static List&lt;Class&gt; getAllClassByInterface(Class c){

        List&lt;Class&gt; returnClassList = new ArrayList&lt;Class&gt;(); //返回结果

        //如果不是一个接口，则不做处理

        if(c.isInterface()){

            String packageName = c.getPackage().getName(); //获得当前的包名
            try {
                List&lt;Class&gt; allClass = getClasses(packageName);//获得当前包下以及子包下的所有类
                //判断是否是同一个接口
                for(int i=0;i&lt;allClass.size();i++){
                    if(c.isAssignableFrom(allClass.get(i))){//判断是不是一个接口
                        if(!c.equals(allClass.get(i))){//本身不加进去
                            returnClassList.add(allClass.get(i));
                        }
                    }
                }
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return returnClassList;
    }

    //从一个包中查找出所有的类，在jar包中不能查找

    private static List&lt;Class&gt; getClasses(String packageName)throws ClassNotFoundException, IOException {

        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        String path = packageName.replace(&apos;.&apos;, &apos;/&apos;);
        Enumeration&lt;URL&gt; resources = classLoader.getResources(path);
        List&lt;File&gt; dirs = new ArrayList&lt;File&gt;();
        while (resources.hasMoreElements()) {
            URL resource = resources.nextElement();
            dirs.add(new File(resource.getFile()));
        }

        ArrayList&lt;Class&gt; classes = new ArrayList&lt;Class&gt;();
        for (File directory : dirs) {
            classes.addAll(findClasses(directory, packageName));
        }
        return classes;
    }


    private static List&lt;Class&gt; findClasses(File directory, String packageName) throws ClassNotFoundException {

        List&lt;Class&gt; classes = new ArrayList&lt;Class&gt;();

        if (!directory.exists()) {
            return classes;
        }

        File[] files = directory.listFiles();
        for (File file : files) {
            if (file.isDirectory()) {
                assert !file.getName().contains(&quot;.&quot;);
                classes.addAll(findClasses(file, packageName + &quot;.&quot; + file.getName()));
            } else if (file.getName().endsWith(&quot;.class&quot;)) {
                classes.add(Class.forName(packageName + &apos;.&apos; + file.getName().substring(0, file.getName().length() - 6)));
            }
        }
        return classes;
    }
}


public class Client {

    public static void main(String[] args) {

        //女娲第一次造人，试验性质，少造点，火候不足，缺陷产品

        System.out.println(&quot;-----造出的第一批人是这样的：白人----&quot;);

        HumanInterface whiteHuman = HumanFactory.createHuman(WhiteHuman.class);

        whiteHuman.cry();
        whiteHuman.laugh();
        whiteHuman.talk();

        //女娲第二次造人，火候加足点，然后又出了个次品，黑人

        System.out.println(&quot;\n\n---造出的第二批人是这样的：黑人-------&quot;);

        HumanInterface blackHuman = HumanFactory.createHuman(BlackHuman.class);

        blackHuman.cry();
        blackHuman.laugh();
        blackHuman.talk();

        //第三批人了，这次火候掌握的正好，黄色人类（不写黄人，免得引起歧义），备注：RB人不属于此列

        System.out.println(&quot;\n\n----造出的第三批人是这样的：黄色人类--------&quot;);

        HumanInterface yellowHuman = HumanFactory.createHuman(YellowHuman.class);

        yellowHuman.cry();
        yellowHuman.laugh();
        yellowHuman.talk();

        //女娲烦躁了，爱是啥人类就是啥人类，烧吧

        for(int i=0;i&lt;1000000;i++){

            System.out.println(&quot;\n\n-----随机产生人类了-----&quot; + i);

            HumanInterface human = HumanFactory.createHuman();

            human.cry();
            human.laugh();
            human.talk();

        }

    }

}
</code></pre><hr>
<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a><center>抽象工厂模式</center></h1><ul>
<li>代码</li>
</ul>
<pre><code>public interface HumanInterface {
    public void laugh();
    public void cry();
    public void talk();
    public void sex();
}


public abstract class AbstractBlackHuman implements HumanInterface{

    public void laugh() {
        System.out.println(&quot;黑人会笑&quot;);
    }

    public void cry() {
        System.out.println(&quot;黑人会哭&quot;);
    }

    public void talk() {
        System.out.println(&quot;黑人可以说话，一般人听不懂&quot;);
    }

}


public abstract class AbstractWhiteHuman implements HumanInterface{

    public void laugh() {
        System.out.println(&quot;白色人类会大笑，侵略的笑声&quot;);
    }

    public void cry() {
        System.out.println(&quot;白色人类会哭&quot;);
    }

    public void talk() {
        System.out.println(&quot;白色人类会说话，一般都是但是单字节！&quot;);
    }

}


public abstract class AbstractYellowHuman implements HumanInterface{

    public void laugh() {
        System.out.println(&quot;黄色人类会大笑，幸福呀！&quot;);
    }

    public void cry() {
        System.out.println(&quot;黄色人类会哭&quot;);
    }

    public void talk() {
        System.out.println(&quot;黄色人类会说话，一般说的都是双字节&quot;);
    }

}


public class BlackHuman_Female extends AbstractBlackHuman{

    public void sex(){
        System.out.println(&quot;该黑种人的性别为女...&quot;);
    }

}


public class BlackHuman_Male extends AbstractBlackHuman{

    public void sex(){
        System.out.println(&quot;该黑种人的性别为男...&quot;);
    }

}


public class WhiteHuman_Female extends AbstractWhiteHuman{

    public void sex(){
        System.out.println(&quot;该白种人的性别为女...&quot;);
    }

}


public class WhiteHuman_Male extends AbstractWhiteHuman{

    public void sex(){
        System.out.println(&quot;该白种人的性别为男...&quot;);
    }

}



public class YellowHuman_Female extends AbstractYellowHuman{

    public void sex(){
        System.out.println(&quot;该黄种人的性别为女...&quot;);
    }

}



public class YellowHuman_Male extends AbstractYellowHuman{

    public void sex(){
        System.out.println(&quot;该黄种人的性别为男...&quot;);
    }

}



public enum HumanEnum {

    //把世界上所有人类型都定义出来

    YelloMaleHuman(&quot;抽象工厂模式.humanImpl.YellowHuman_Male&quot;),

    YelloFemaleHuman(&quot;抽象工厂模式.humanImpl.YellowHuman_Female&quot;),

    WhiteFemaleHuman(&quot;抽象工厂模式.humanImpl.WhiteHuman_Female&quot;),

    WhiteMaleHuman(&quot;抽象工厂模式.humanImpl.WhiteHuman_Male&quot;),

    BlackFemaleHuman(&quot;抽象工厂模式.humanImpl.BlackHuman_Female&quot;),

    BlackMaleHuman(&quot;抽象工厂模式.humanImpl.BlackHuman_Male&quot;);



    //定义构造函数，目的是Data(value)类型的相匹配

    private HumanEnum(String value){
        this.value = value;
    }

    private String value = &quot;&quot;;

    public String getValue(){
        return this.value;
    }

}



public interface HumanFactoryInterface {

    public HumanInterface createYellowHuman();//制造黄色人类

    public HumanInterface createWhiteHuman();//制造一个白色人类

    public HumanInterface createBlackHuman();//制造一个黑色人类

}



public abstract class AbstractHumanFactory implements HumanFactoryInterface{

    protected HumanInterface createHuman(HumanEnum humanEnum){

        HumanInterface human = null;

        //如果传递进来不是一个Enum中具体的一个Element的话，则不处理
        if (!humanEnum.getValue().equals(&quot;&quot;)) {
            try {
                //直接产生一个实例
                human = (HumanInterface) Class.forName(humanEnum.getValue()).newInstance();

            } catch (Exception e) {
                //因为使用了enum，这个种异常情况不会产生了，除非你的enum有问题；
                e.printStackTrace();
            }
        }
        return human;
    }
}



public class HumanFactory_Female extends AbstractHumanFactory{

    public HumanInterface createBlackHuman() {//创建一个女性黑种人
        return super.createHuman(HumanEnum.BlackFemaleHuman);
    }

    public HumanInterface createWhiteHuman() {//创建一个女性白种人
        return super.createHuman(HumanEnum.WhiteFemaleHuman);
    }

    public HumanInterface createYellowHuman() {//创建一个女性黄种人
        return super.createHuman(HumanEnum.YelloFemaleHuman);
    }

}



public class HumanFactory_Male extends AbstractHumanFactory{

    public HumanInterface createBlackHuman() {//创建一个男性黑种人
        return super.createHuman(HumanEnum.BlackMaleHuman);
    }

    public HumanInterface createWhiteHuman() {//创建一个男性白种人
        return super.createHuman(HumanEnum.WhiteMaleHuman);
    }

    public HumanInterface createYellowHuman() {//创建一个男性黄种人
        return super.createHuman(HumanEnum.YelloMaleHuman);
    }

}



public class Client {

    public static void main(String[] args){

        //第一条生产线，男性生产线

        HumanFactoryInterface maleHumanFactory = new HumanFactory_Male();

        //第二条生产线，女性生产线

        HumanFactoryInterface femaleHumanFactory = new HumanFactory_Female();



        //生产线建立完毕，开始生产人了:

        HumanInterface maleYellowHuman = maleHumanFactory.createYellowHuman();

        HumanInterface femaleYellowHuman = femaleHumanFactory.createYellowHuman();
        maleYellowHuman.cry();
        maleYellowHuman.laugh();
        femaleYellowHuman.sex();



        /*

        * 后面可以续了.....

        */

    }

}
</code></pre><hr>
<h1 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a><center>解释器模式</center></h1><hr>
<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a><center>迭代器模式</center></h1><hr>
<h1 id="六大设计原则"><a href="#六大设计原则" class="headerlink" title="六大设计原则"></a><center>六大设计原则</center></h1><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><ul>
<li>定义：有且仅有一个原因引起类的变更。</li>
<li>单一职责是指接口（类）的职责，一个类可以实现多个单职责的接口，但此实现类并不是说就不是单一职责了，实现类应该是更上一层粒度的单一职责。</li>
<li>职责的粒度需根据具体业务来定，追求学术上的单职责会导致接口数量巨增，设计太复杂。</li>
</ul>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><ul>
<li>定义：父类出现的地方，可以使用子类替换。</li>
<li>在类中调用其他类时必使用其他类的父类或接口。</li>
</ul>
<h3 id="依赖倒置原则（即面向接口编程）"><a href="#依赖倒置原则（即面向接口编程）" class="headerlink" title="依赖倒置原则（即面向接口编程）"></a>依赖倒置原则（即<strong><em>面向接口编程</em></strong>）</h3><ul>
<li>定义：高层模块不应依赖低层模块，两者均只依赖各自的抽象；细节依赖抽象，抽象不依赖细节。</li>
<li>模块间的依赖通过各自的抽象发生，实现类间不直接依赖。</li>
</ul>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><ul>
<li>定义：接口尽量细化，接口中的方法尽量少。</li>
<li>与单一职责的不同：单一职责是从业务层考虑。</li>
</ul>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><ul>
<li>定义：一个类需要对自己需要耦合或调用的类知道的最少。</li>
</ul>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><ul>
<li>定义：模块、类、方法均应对扩展开放，对修改关闭。</li>
<li>尽量通过扩展现有模块、类、方法来实现变化，而不是修改现有代码来完成变化。</li>
</ul>
<hr>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/mamian" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">© 2016  <a href="http://www.mamian.net/" target="_blank">mamian</a>  All Rights Reserved</p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>