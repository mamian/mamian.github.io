<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="使用设计模块注意度，结合业务，不能过度设计。
组合模式
单例模式
只能产生一个实例对象。实例为静态成员，构造方法为private，静态方法返回惟一实例。
单例类一般不要实现Cloneable接口，若一个类实现了Cloneable接口且实现了clone()方法，那么这个类可以被复制，类复制时不需要调用">
    

    <!--Author-->
    
        <meta name="author" content="mamian">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="设计模式读书笔记"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="马面"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

        <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>设计模式读书笔记 - 马面</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    


</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">马面</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives/index.html">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags/index.html">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories/index.html">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/about/index.html">
                            
                                About
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/mamian">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('http://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>设计模式读书笔记</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        2016-08-15
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/设计模式/">#设计模式</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                        

<a href="/categories/读书笔记/">读书笔记</a>

                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <p>使用设计模块注意度，结合业务，不能过度设计。</p>
<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a><center>组合模式</center></h1><hr>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><center>单例模式</center></h1><ul>
<li>只能产生一个实例对象。实例为静态成员，构造方法为private，静态方法返回惟一实例。</li>
<li>单例类一般不要实现Cloneable接口，若一个类实现了Cloneable接口且实现了clone()方法，那么这个类可以被复制，类复制时不需要调用构造方法。单例将被破坏。</li>
<li>一个单例对象在内存中长久不使用，JVM会认为这个对象是一个垃圾，将会对其进行回收。但若采用J2EE容器或框架级容器（如Spring容器），可以让对象长久驻留内存。</li>
<li>spring中每个bean默认均为单例，这样做spring容器可以管理bean的生命周期。若采用非单例模式（如prototype）,则bean初始化后的管理交由j2ee容器管理，spring容器不再管理。</li>
<li><p>代码示例</p>
<ul>
<li><p>饱汉式：线程不安全，可通过synchronized来解决</p>
<pre><code>public class Singleton {

    private static Singleton item;

    private Singleton(){}

    public static Singleton getInstance() {
        if(item==null)
            item = new Singleton();
        return item;
    }
}
</code></pre></li>
<li><p>线程安全：</p>
<pre><code>public class Singleton {

    private static Singleton item;

    private Singleton(){}

    public static Singleton getInstance() {
        if(item==null){
            synchronized (Singleton.class) {
                if (item == null) {// Double checked
                    item = new Singleton();
                }
            }
        }
        return item;
    }
}
</code></pre></li>
<li><p>饿汉式</p>
<pre><code>public class Singleton {
    private static Singleton item = new Singleton();

    private Singleton(){}

    public static Singleton getInstance() {
        return item;
    }
}
</code></pre></li>
</ul>
</li>
</ul>
<hr>
<h1 id="多例模式"><a href="#多例模式" class="headerlink" title="多例模式"></a><center>多例模式</center></h1><hr>
<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a><center>状态模式</center></h1><hr>
<h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a><center>责任链模式</center></h1><hr>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a><center>观察者模式</center></h1><hr>
<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a><center>命令模式</center></h1><hr>
<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a><center>中介者模式</center></h1><hr>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a><center>代理模式</center></h1><hr>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a><center>策略模式</center></h1><hr>
<h1 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a><center>备忘录模式</center></h1><hr>
<h1 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a><center>模板模式</center></h1><ul>
<li>当我们写一个文档时（如需求文档）通常首先要找一个模板，模板里会清楚的写着要写几大模块且说明这些模块的先后顺序。我们再照着模板填充每一模块的具体内容。</li>
<li>定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</li>
<li>基本方法：由子类实现的方法，并且在模板方法中被调用。</li>
<li>模板方法：一个框架，实现对基本方法的调度，完成固定的逻辑。为防止恶意操作，一般模板方法会加final关键字，不允许覆盖。</li>
<li>父类模板中用一个方法规定了其所有子类要执行的一系列方法的顺序，即定义中所说的算法的框架。在高层的执行步骤是确定的（即每一步要实现什么功能），但具体执行的操作，每个子类均有自己的实现（即每一步具体如何实现，各子类均不同）。</li>
<li><p>代码</p>
<pre><code>public abstract class Model {

    protected abstract void start();//protected

    protected abstract void alarm();

    protected abstract void stop();

    public final void run(){//final

        this.start();

        this.alarm();

        this.stop();

    }

}

public class ModelA extends Model{

    protected void start() {

        System.out.println(&quot;车辆A启动&quot;);

    }

    protected void alarm() {

        System.out.println(&quot;车辆A鸣笛&quot;);

    }

    protected void stop() {

        System.out.println(&quot;车辆A刹车&quot;);

    }

}
</code></pre></li>
</ul>
<pre><code>public class ModelB extends Model{

    protected void start() {

        System.out.println(&quot;车辆B启动&quot;);

    }

    protected void alarm() {

        System.out.println(&quot;车辆B鸣笛&quot;);

    }

    protected void stop() {

        System.out.println(&quot;车辆B刹车&quot;);

    }

}



public class Client {

    public static void main(String[] args){

        Model modelA = new ModelA();

        modelA.run();



        Model modelB = new ModelB();

        modelB.run();

    }

}
</code></pre><hr>
<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a><center>建造者模式</center></h1><ul>
<li>与模板模式类似，建造者模式增加建造者且模板父类中增加了方法执行顺序变量sequence</li>
<li>建造者实现两个方法：一个返回要建造的对象，另一个设置要建造的对象中的通用方法中调用自身方法的顺序</li>
<li>Client中实例sequence和具体Builder，并执行Builder中的model的某方法。</li>
<li><p>代码</p>
<pre><code>public abstract class Model {

    private ArrayList&lt;String&gt; sequence = new ArrayList&lt;String&gt;();
</code></pre></li>
</ul>
<pre><code>    public final void setSequence(ArrayList&lt;String&gt; sequence){

        this.sequence = sequence;

    }

    final public void run(){

        for(int i=0;i&lt;sequence.size();i++){

            String nowOrperate = sequence.get(i);

            if(nowOrperate.equals(&quot;start&quot;)){

                this.start();

            }else if(nowOrperate.equals(&quot;alarm&quot;)){

                this.alarm();

            }else if(nowOrperate.equals(&quot;stop&quot;)){

                this.stop();

            }

        }

    }



    protected abstract void start();

    protected abstract void alarm();

    protected abstract void stop();

}

public class ModelA extends Model{

    protected void start() {

        System.out.println(&quot;车辆A启动&quot;);

    }

    protected void alarm() {

        System.out.println(&quot;车辆A鸣笛&quot;);

    }

    protected void stop() {

        System.out.println(&quot;车辆A刹车&quot;);

    }

}



public class ModelB extends Model{

    protected void start() {

        System.out.println(&quot;车辆B启动&quot;);

    }

    protected void alarm() {

        System.out.println(&quot;车辆B鸣笛&quot;);

    }

    protected void stop() {

        System.out.println(&quot;车辆B刹车&quot;);

    }

}



public abstract class Builder {

    public abstract void setSequence(ArrayList&lt;String&gt; sequence);

    public abstract Model getModel();

}



public class BuilderA extends Builder{

    private ModelA modelA = new ModelA();



    public void setSequence(ArrayList&lt;String&gt; sequence) {

        modelA.setSequence(sequence);

    }

    public Model getModel() {

        return modelA;

    }

}



public class BuilderB extends Builder{

    private ModelB modelB = new ModelB();



    public void setSequence(ArrayList&lt;String&gt; sequence) {

        modelB.setSequence(sequence);

    }

    public Model getModel() {

        return modelB;

    }

}



public class Client {

    public static void main(String[] args){

        ArrayList&lt;String&gt; sequence1 = new ArrayList&lt;String&gt;();

        sequence1.add(&quot;alarm&quot;);

        sequence1.add(&quot;start&quot;);

        sequence1.add(&quot;stop&quot;);



        Builder builderA = new BuilderA();

        builderA.setSequence(sequence1);

        builderA.getModel().run();





        ArrayList&lt;String&gt; sequence2 = new ArrayList&lt;String&gt;();

        sequence2.add(&quot;start&quot;);

        sequence2.add(&quot;alarm&quot;);

        sequence2.add(&quot;stop&quot;);



        Builder builderB = new BuilderB();

        builderB.setSequence(sequence2);

        builderB.getModel().run();

    }

}
</code></pre><hr>
<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a><center>原型模式</center></h1><hr>
<h1 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a><center>门面模式</center></h1><hr>
<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a><center>享元模式</center></h1><hr>
<h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a><center>桥接模式</center></h1><hr>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a><center>适配器模式</center></h1><hr>
<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a><center>访问者模式</center></h1><hr>
<h1 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a><center>装饰模式</center></h1><hr>
<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a><center>简单工厂模式</center></h1><ul>
<li>Client中将参数传递给Factory，Factory根据参数决定生产哪个具体的实例类。</li>
<li><p>代码</p>
<pre><code>public class Operater {

    public int getResult(int a,int b){

        return 0;

    }

}

public class OperaterAdd extends Operater{

    public int getResult(int addA,int addB){

        System.out.println(&quot;加法&quot;);

        return addA+addB;

    }

}
</code></pre></li>
</ul>
<pre><code>public class OperaterDiv extends Operater{

    public int getResult(int divA,int divB){

        System.out.println(&quot;除法&quot;);

        return divA/divB;

    }

}



public class Factory {

    private static Operater operater;

    public static Operater createOperater(char choose){

        switch(choose){

            case &apos;+&apos;:

                operater = new OperaterAdd();break;

            case &apos;/&apos;:

                operater = new OperaterDiv();break;

        }

        return operater;

    }

}



public class Client {

    public static void main(String[] args){

        Operater operater = Factory.createOperater(&apos;+&apos;);

        int result = operater.getResult(15,25);

    }

}
</code></pre><hr>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a><center>工厂模式</center></h1><ul>
<li><p>代码</p>
<pre><code>public interface HumanInterface {

    public void laugh();

    public void cry();

    public void talk();

}

public class BlackHuman implements HumanInterface{

    public void laugh() {

        System.out.println(&quot;黑人会笑&quot;);

    }

    public void cry() {

        System.out.println(&quot;黑人会哭&quot;);

    }

    public void talk() {

        System.out.println(&quot;黑人可以说话，一般人听不懂&quot;);

    }

}
</code></pre></li>
</ul>
<pre><code>public class WhiteHuman implements HumanInterface{

    public void laugh() {

        System.out.println(&quot;白色人类会大笑，侵略的笑声&quot;);

    }

    public void cry() {

        System.out.println(&quot;白色人类会哭&quot;);

    }

    public void talk() {

        System.out.println(&quot;白色人类会说话，一般都是但是单字节！&quot;);

    }

}



public class YellowHuman implements HumanInterface{

    public void laugh() {

        System.out.println(&quot;黄色人类会大笑，幸福呀！&quot;);

    }

    public void cry() {

        System.out.println(&quot;黄色人类会哭&quot;);

    }

    public void talk() {

        System.out.println(&quot;黄色人类会说话，一般说的都是双字节&quot;);

    }

}



public class ClassUtils {

    //给一个接口，返回这个接口的所有实现类

    public static List&lt;Class&gt; getAllClassByInterface(Class c){

        List&lt;Class&gt; returnClassList = new ArrayList&lt;Class&gt;(); //返回结果

        //如果不是一个接口，则不做处理

        if(c.isInterface()){

            String packageName = c.getPackage().getName(); //获得当前的包名

            try {

                List&lt;Class&gt; allClass = getClasses(packageName);//获得当前包下以及子包下的所有类

                //判断是否是同一个接口

                for(int i=0;i&lt;allClass.size();i++){

                    if(c.isAssignableFrom(allClass.get(i))){//判断是不是一个接口

                        if(!c.equals(allClass.get(i))){//本身不加进去

                            returnClassList.add(allClass.get(i));

                        }

                    }

                }

            } catch (ClassNotFoundException e) {

                e.printStackTrace();

            } catch (IOException e) {

                e.printStackTrace();

            }

        }

        return returnClassList;

    }



    //从一个包中查找出所有的类，在jar包中不能查找

    private static List&lt;Class&gt; getClasses(String packageName)throws ClassNotFoundException, IOException {

        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();

        String path = packageName.replace(&apos;.&apos;, &apos;/&apos;);

        Enumeration&lt;URL&gt; resources = classLoader.getResources(path);

        List&lt;File&gt; dirs = new ArrayList&lt;File&gt;();

        while (resources.hasMoreElements()) {

            URL resource = resources.nextElement();

            dirs.add(new File(resource.getFile()));

        }

        ArrayList&lt;Class&gt; classes = new ArrayList&lt;Class&gt;();

        for (File directory : dirs) {

            classes.addAll(findClasses(directory, packageName));

        }

        return classes;

    }



    private static List&lt;Class&gt; findClasses(File directory, String packageName) throws ClassNotFoundException {

        List&lt;Class&gt; classes = new ArrayList&lt;Class&gt;();

        if (!directory.exists()) {

            return classes;

        }

        File[] files = directory.listFiles();

        for (File file : files) {

            if (file.isDirectory()) {

                assert !file.getName().contains(&quot;.&quot;);

                classes.addAll(findClasses(file, packageName + &quot;.&quot; + file.getName()));

            } else if (file.getName().endsWith(&quot;.class&quot;)) {

                classes.add(Class.forName(packageName + &apos;.&apos; + file.getName().substring(0, file.getName().length() - 6)));

            }

        }

        return classes;

    }

}



public class Client {

    public static void main(String[] args) {

        //女娲第一次造人，试验性质，少造点，火候不足，缺陷产品

        System.out.println(&quot;-----造出的第一批人是这样的：白人----&quot;);

        HumanInterface whiteHuman = HumanFactory.createHuman(WhiteHuman.class);

        whiteHuman.cry();

        whiteHuman.laugh();

        whiteHuman.talk();

        //女娲第二次造人，火候加足点，然后又出了个次品，黑人

        System.out.println(&quot;\n\n---造出的第二批人是这样的：黑人-------&quot;);

        HumanInterface blackHuman = HumanFactory.createHuman(BlackHuman.class);

        blackHuman.cry();

        blackHuman.laugh();

        blackHuman.talk();

        //第三批人了，这次火候掌握的正好，黄色人类（不写黄人，免得引起歧义），备注：RB人不属于此列

        System.out.println(&quot;\n\n----造出的第三批人是这样的：黄色人类--------&quot;);

        HumanInterface yellowHuman = HumanFactory.createHuman(YellowHuman.class);

        yellowHuman.cry();

        yellowHuman.laugh();

        yellowHuman.talk();

        //女娲烦躁了，爱是啥人类就是啥人类，烧吧

        for(int i=0;i&lt;1000000;i++){

            System.out.println(&quot;\n\n-----随机产生人类了-----&quot; + i);

            HumanInterface human = HumanFactory.createHuman();

            human.cry();

            human.laugh();

            human.talk();

        }

    }

}
</code></pre><hr>
<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a><center>抽象工厂模式</center></h1><ul>
<li><p>代码</p>
<pre><code>public interface HumanInterface {

        public void laugh();

        public void cry();

        public void talk();

        public void sex();

    }

    public abstract class AbstractBlackHuman implements HumanInterface{

        public void laugh() {

            System.out.println(&quot;黑人会笑&quot;);

        }

        public void cry() {

            System.out.println(&quot;黑人会哭&quot;);

        }

        public void talk() {

            System.out.println(&quot;黑人可以说话，一般人听不懂&quot;);

        }

    }
</code></pre></li>
</ul>
<pre><code>public abstract class AbstractWhiteHuman implements HumanInterface{

    public void laugh() {

        System.out.println(&quot;白色人类会大笑，侵略的笑声&quot;);

    }

    public void cry() {

        System.out.println(&quot;白色人类会哭&quot;);

    }

    public void talk() {

        System.out.println(&quot;白色人类会说话，一般都是但是单字节！&quot;);

    }

}



public abstract class AbstractYellowHuman implements HumanInterface{

    public void laugh() {

        System.out.println(&quot;黄色人类会大笑，幸福呀！&quot;);

    }

    public void cry() {

        System.out.println(&quot;黄色人类会哭&quot;);

    }

    public void talk() {

        System.out.println(&quot;黄色人类会说话，一般说的都是双字节&quot;);

    }

}



public class BlackHuman_Female extends AbstractBlackHuman{

    public void sex(){

        System.out.println(&quot;该黑种人的性别为女...&quot;);

    }

}



public class BlackHuman_Male extends AbstractBlackHuman{

    public void sex(){

        System.out.println(&quot;该黑种人的性别为男...&quot;);

    }

}



public class WhiteHuman_Female extends AbstractWhiteHuman{

    public void sex(){

        System.out.println(&quot;该白种人的性别为女...&quot;);

    }

}



public class WhiteHuman_Male extends AbstractWhiteHuman{

    public void sex(){

        System.out.println(&quot;该白种人的性别为男...&quot;);

    }

}



public class YellowHuman_Female extends AbstractYellowHuman{

    public void sex(){

        System.out.println(&quot;该黄种人的性别为女...&quot;);

    }

}



public class YellowHuman_Male extends AbstractYellowHuman{

    public void sex(){

        System.out.println(&quot;该黄种人的性别为男...&quot;);

    }

}



public enum HumanEnum {

    //把世界上所有人类型都定义出来

    YelloMaleHuman(&quot;抽象工厂模式.humanImpl.YellowHuman_Male&quot;),

    YelloFemaleHuman(&quot;抽象工厂模式.humanImpl.YellowHuman_Female&quot;),

    WhiteFemaleHuman(&quot;抽象工厂模式.humanImpl.WhiteHuman_Female&quot;),

    WhiteMaleHuman(&quot;抽象工厂模式.humanImpl.WhiteHuman_Male&quot;),

    BlackFemaleHuman(&quot;抽象工厂模式.humanImpl.BlackHuman_Female&quot;),

    BlackMaleHuman(&quot;抽象工厂模式.humanImpl.BlackHuman_Male&quot;);



    //定义构造函数，目的是Data(value)类型的相匹配

    private HumanEnum(String value){

        this.value = value;

    }

    private String value = &quot;&quot;;

    public String getValue(){

        return this.value;

    }

}



public interface HumanFactoryInterface {

    public HumanInterface createYellowHuman();//制造黄色人类

    public HumanInterface createWhiteHuman();//制造一个白色人类

    public HumanInterface createBlackHuman();//制造一个黑色人类

}



public abstract class AbstractHumanFactory implements HumanFactoryInterface{

    protected HumanInterface createHuman(HumanEnum humanEnum){

        HumanInterface human = null;

        //如果传递进来不是一个Enum中具体的一个Element的话，则不处理

        if (!humanEnum.getValue().equals(&quot;&quot;)) {

            try {

                //直接产生一个实例

                human = (HumanInterface) Class.forName(humanEnum.getValue()).newInstance();

            } catch (Exception e) {

                //因为使用了enum，这个种异常情况不会产生了，除非你的enum有问题；

                e.printStackTrace();

            }

        }

        return human;

    }

}



public class HumanFactory_Female extends AbstractHumanFactory{

    public HumanInterface createBlackHuman() {//创建一个女性黑种人

        return super.createHuman(HumanEnum.BlackFemaleHuman);

    }

    public HumanInterface createWhiteHuman() {//创建一个女性白种人

        return super.createHuman(HumanEnum.WhiteFemaleHuman);

    }

    public HumanInterface createYellowHuman() {//创建一个女性黄种人

        return super.createHuman(HumanEnum.YelloFemaleHuman);

    }

}



public class HumanFactory_Male extends AbstractHumanFactory{

    public HumanInterface createBlackHuman() {//创建一个男性黑种人

        return super.createHuman(HumanEnum.BlackMaleHuman);

    }

    public HumanInterface createWhiteHuman() {//创建一个男性白种人

        return super.createHuman(HumanEnum.WhiteMaleHuman);

    }

    public HumanInterface createYellowHuman() {//创建一个男性黄种人

        return super.createHuman(HumanEnum.YelloMaleHuman);

    }

}



public class Client {

    public static void main(String[] args){

        //第一条生产线，男性生产线

        HumanFactoryInterface maleHumanFactory = new HumanFactory_Male();

        //第二条生产线，女性生产线

        HumanFactoryInterface femaleHumanFactory = new HumanFactory_Female();



        //生产线建立完毕，开始生产人了:

        HumanInterface maleYellowHuman = maleHumanFactory.createYellowHuman();

        HumanInterface femaleYellowHuman = femaleHumanFactory.createYellowHuman();

        maleYellowHuman.cry();

        maleYellowHuman.laugh();

        femaleYellowHuman.sex();



        /*

        * 后面可以续了.....

        */

    }

}
</code></pre><hr>
<h1 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a><center>解释器模式</center></h1><hr>
<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a><center>迭代器模式</center></h1><hr>
<h1 id="六大设计原则"><a href="#六大设计原则" class="headerlink" title="六大设计原则"></a><center>六大设计原则</center></h1><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><ul>
<li>定义：有且仅有一个原因引起类的变更。</li>
<li>单一职责是指接口（类）的职责，一个类可以实现多个单职责的接口，但此实现类并不是说就不是单一职责了，实现类应该是更上一层粒度的单一职责。</li>
<li>职责的粒度需根据具体业务来定，追求学术上的单职责会导致接口数量巨增，设计太复杂。</li>
</ul>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><ul>
<li>定义：父类出现的地方，可以使用子类替换。</li>
<li>在类中调用其他类时必使用其他类的父类或接口。</li>
</ul>
<h3 id="依赖倒置原则（即面向接口编程）"><a href="#依赖倒置原则（即面向接口编程）" class="headerlink" title="依赖倒置原则（即面向接口编程）"></a>依赖倒置原则（即<strong><em>面向接口编程</em></strong>）</h3><ul>
<li>定义：高层模块不应依赖低层模块，两者均只依赖各自的抽象；细节依赖抽象，抽象不依赖细节。</li>
<li>模块间的依赖通过各自的抽象发生，实现类间不直接依赖。</li>
</ul>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><ul>
<li>定义：接口尽量细化，接口中的方法尽量少。</li>
<li>与单一职责的不同：单一职责是从业务层考虑。</li>
</ul>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><ul>
<li>定义：一个类需要对自己需要耦合或调用的类知道的最少。</li>
</ul>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><ul>
<li>定义：模块、类、方法均应对扩展开放，对修改关闭。</li>
<li>尽量通过扩展现有模块、类、方法来实现变化，而不是修改现有代码来完成变化。</li>
</ul>
<hr>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/mamian" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">© 2016  <a href="http://www.mamian.net/" target="_blank">mamian</a>  All Rights Reserved</p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>