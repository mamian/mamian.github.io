<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="安装
下载
配置工作空间
export GOPATH=~/Documents/code/workspace_go
export PATH=$PATH:$GOPATH/bin


工作空间workspace_go
mkdir -p $GOPATH/src/github.com/mamian




初">
    

    <!--Author-->
    
        <meta name="author" content="mamian">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="《Go语言编程》读书笔记"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="马面"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

        <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>《Go语言编程》读书笔记 - 马面</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    


</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">马面</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives/index.html">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags/index.html">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories/index.html">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/about/index.html">
                            
                                About
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/mamian">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('http://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>《Go语言编程》读书笔记</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        2016-09-14
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/Go/">#Go</a> <a href="/tags/Golang/">#Golang</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                        

<a href="/categories/读书笔记/">读书笔记</a>

                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a><center>安装</center></h1><ul>
<li><a href="https://golang.org/dl/" target="_blank" rel="external">下载</a></li>
<li>配置工作空间<ul>
<li>export GOPATH=~/Documents/code/workspace_go</li>
<li>export PATH=$PATH:$GOPATH/bin</li>
</ul>
</li>
<li>工作空间workspace_go<ul>
<li>mkdir -p $GOPATH/src/github.com/mamian</li>
</ul>
</li>
</ul>
<hr>
<h1 id="初识Go语言"><a href="#初识Go语言" class="headerlink" title="初识Go语言"></a><center>初识Go语言</center></h1><h3 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h3><h5 id="自动垃圾回收"><a href="#自动垃圾回收" class="headerlink" title="自动垃圾回收"></a>自动垃圾回收</h5><h5 id="更丰富的内置类型"><a href="#更丰富的内置类型" class="headerlink" title="更丰富的内置类型"></a>更丰富的内置类型</h5><ul>
<li>map</li>
<li>slice：可动态增长的数组</li>
</ul>
<h5 id="函数多返回值"><a href="#函数多返回值" class="headerlink" title="函数多返回值"></a>函数多返回值</h5><h5 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h5><ul>
<li>defer：不管程序是否出现异常,均 在函数退出时自动执行相关代码</li>
<li>panic</li>
<li>recover</li>
</ul>
<h5 id="匿名函数和闭包"><a href="#匿名函数和闭包" class="headerlink" title="匿名函数和闭包"></a>匿名函数和闭包</h5><pre><code>f := func(x, y int) int {
    return x + y
}
</code></pre><h5 id="类型struct和接口interface"><a href="#类型struct和接口interface" class="headerlink" title="类型struct和接口interface"></a>类型struct和接口interface</h5><ul>
<li>不支持继承和重载,而只是支持了最基本的类型组合功能。</li>
</ul>
<h5 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h5><ul>
<li>使用goroutine而不是用操作系统的并发机制。</li>
<li>使用消息传递来共享内存而不是使用共享内存来通信。</li>
<li>Go语言通过系统的线程来多派这些函数的执行,使得每个用go关键字执行的函数可以行成为一个单位协程。当一个协程阻塞的时候,调度器就会自动把其他协程排到另外的线程中去执行,从而实现了程序无等并行化行。</li>
<li>跨goroutine通信：channel</li>
<li>由于一个进程内创建的所有goroutine行在同一个内存地间中,因此如果不同的goroutine不得不去访问共享的内存变量,访问前应该先获取相应的读写。Go语言标准库中的sync包提供了完的读写功能。</li>
</ul>
<h5 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h5><h5 id="语言交互性"><a href="#语言交互性" class="headerlink" title="语言交互性"></a>语言交互性</h5><h3 id="第一个Go程序"><a href="#第一个Go程序" class="headerlink" title="第一个Go程序"></a>第一个Go程序</h3><ul>
<li>必须package main，但文件名不一定为main.go，必包含func main(){}方法。命令行传入的参数在os.Args变量中保存。如果需要支持命令行开关,可使用flag包。</li>
<li><p>go函数</p>
<pre><code>func 函数名(参数列表)(返回值列表) {
    //函数体
}
</code></pre><ul>
<li>函数返回时没有被明确赋值的返回值都会被设置为认值。</li>
</ul>
</li>
<li>编译程序<ul>
<li>直接运行：go run hello.go</li>
<li>编译后运行<ul>
<li>go build hello.go</li>
<li>./hello</li>
</ul>
</li>
</ul>
</li>
<li>日志<ul>
<li>fmt.Printf()  fmt.Println()</li>
<li>log</li>
</ul>
</li>
<li>GDB调试<ul>
<li>build出可执行文件后，直接gdb helloworld</li>
</ul>
</li>
</ul>
<hr>
<h1 id="顺序编程"><a href="#顺序编程" class="headerlink" title="顺序编程"></a><center>顺序编程</center></h1><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h5 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h5><ul>
<li><p>var</p>
<pre><code>var v1 int
var v2 string
var v3 [10]int          //数组
var v4 []int            //数组切片
var v5 struct {
    f int
}
var v6 *int             //指针
var v7 map[string]int   //map key为string   value为int 
var v8 func(a int) int
</code></pre></li>
<li><p>公用var</p>
<pre><code>var (
    v1 int
    v2 string
)
</code></pre></li>
</ul>
<h5 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h5><pre><code>var v1 int = 10 //正确方式1
var v2 = 10     //正确方式2，编译器可自动推导v2类型
v3 := 10        //正确方式3，编译器可自动推导v3类型
</code></pre><ul>
<li>出现在:=左侧的变量不应该是已经被声明过的,否则会导致编译错误</li>
</ul>
<h5 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h5><ul>
<li>声明后赋值<ul>
<li>var v10 int</li>
<li>v10 = 123</li>
</ul>
</li>
<li>多重赋值<ul>
<li>交换变量值：i,j = j,i</li>
</ul>
</li>
</ul>
<h5 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h5><ul>
<li>不用的返回值可用_代替。</li>
</ul>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul>
<li>常量可以是数值类型（整型、浮点型、复数），布尔类型、字符串类型。</li>
</ul>
<h5 id="字面常量"><a href="#字面常量" class="headerlink" title="字面常量"></a>字面常量</h5><ul>
<li>无类型<ul>
<li>只要这个常量在相应类型的值域范围内,就可以作为该类型的常量。</li>
<li>如-12可以赋值给int、uint、int32、int64、float32、float64、complex64、complex128等类型的变量。</li>
</ul>
</li>
</ul>
<h5 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h5><ul>
<li>通过<code>const</code>关键字定义常量。<ul>
<li>const Pi float64 = 3.14159265358979323846</li>
<li>const (<br>  size int64 = 1024<br>  eof = -1<br>）</li>
</ul>
</li>
</ul>
<h5 id="预定义常量"><a href="#预定义常量" class="headerlink" title="预定义常量"></a>预定义常量</h5><ul>
<li><p>iota</p>
<pre><code>const (//iota被重设为0 
    c0 = iota //c0 == 0 
    c1 = iota //c0 == 1 
    c2 = iota //c0 == 2
)
</code></pre></li>
<li><p>true、false    </p>
</li>
</ul>
<h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><ul>
<li><p>go中<code>没有enum</code>，可使用const实现枚举。</p>
<pre><code>const(
    Sunday = iota
    Monday
    Tuesday
)
</code></pre></li>
</ul>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul>
<li>对于常规的开发来说,用int和uint就可以了,没必要用int8之类明确指定长度的类型,以免导致移植困难。</li>
<li>基础类型<ul>
<li>bool</li>
<li>int8、byte、int16、int、uint、uintptr</li>
<li>float32、float64</li>
<li>complex64、complex128</li>
<li>string</li>
<li>rune：字符</li>
<li>error</li>
</ul>
</li>
<li>复合类型<ul>
<li>pointer</li>
<li>array</li>
<li>slice：切片</li>
<li>map：字典</li>
<li>chan：通道</li>
<li>struct：结构体</li>
<li>interface</li>
</ul>
</li>
<li>bool变量只能用true、false，不支持0、1，不支持类型转换。</li>
<li>int与int32在Go中为2种不同类型，不做自动类型转换，但可强制转换。</li>
<li>左移*、右移/、2变量异或^、1变量取反^、与&amp;、或|</li>
<li><p><code>浮点数比较</code>：浮点数不是一种精确的表达方式,不可像整型那样直接用==来判断是否相等。</p>
<pre><code>import &quot;math&quot;
//p为用户自定义的比较精度，如0.00001
func IsEqual(f1, f2, p float64) bool {
    return math.Fdim(f1, f2) &lt; p
}
</code></pre></li>
<li>字符串的内容可以用类似于数组下标的方式获取,但与数组不同,字符串的内容不能在初始化后被修改。</li>
<li><code>len(s)</code>获取字符串长度，<code>x+y</code>拼接字符串，<code>s[i]</code>取字符。</li>
<li><p>字符串遍历</p>
<ul>
<li><p>按字节遍历(有中文时不方遍)</p>
<pre><code>n := len(str)
for i := 0; i&lt;n; i++ {
}
</code></pre></li>
<li><p>按Unicode字符遍历</p>
<pre><code>for i, ch := range str{
    fmt.Println(i, ch)   //ch类型为rune
}
</code></pre></li>
</ul>
</li>
<li>字符类型<ul>
<li>byte：代表UTF8字符串的单个字节的值</li>
<li>rune：代表单个Unicode字符</li>
</ul>
</li>
<li>数组<ul>
<li>数组长度在定义后不可更改</li>
<li>数组长度：len(arr)</li>
<li>定义方法<ul>
<li>[32]byte                    //长度为32的数组，每个元素为一个字节</li>
<li>[2*N] struct { x, y int32 } //复杂类型数组</li>
<li>[1000]*float64              //指针数组</li>
<li>[3][5]int                   //二维数组</li>
<li>[2][2][2]float64            //等同于<a href="[2]([2]float64">2</a>)</li>
</ul>
</li>
<li>数组为值类型：<code>所有值类型在赋值和作为参数传递时都产生一次复制动作</code>。函数内操作的只是所传入数组的一个副本。</li>
</ul>
</li>
<li>数组切片<ul>
<li>创建切片<ul>
<li>基于数组创建切片<ul>
<li>var myArray [10]int = [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}</li>
<li>var mySlice []int = myArray[:5]</li>
</ul>
</li>
<li>直接创建<code>make</code><ul>
<li>mySlice1 := make([]int, 5)       //容量5，初始值0</li>
<li>mySlice3 := []int{1, 2, 3, 4, 5} //创建并初始化</li>
</ul>
</li>
</ul>
</li>
<li>cap()为数组切片分配的空间大小，len()为数组切片中当前所存储的元素个数</li>
<li>向切片尾端添加元素<ul>
<li>mySlice = append(mySlice, 1, 2, 3)</li>
</ul>
</li>
<li>将一个切片添加到另一切片尾端，注意不能少了<code>...</code><ul>
<li>mySlice2 := []int{8, 9, 10}</li>
<li>mySlice = append(mySlice, mySlice2…)</li>
</ul>
</li>
<li>基于切片创建新的切片<ul>
<li>oldSlice := []int{1, 2, 3, 4, 5}</li>
<li>newSlice := oldSlice[:3]</li>
</ul>
</li>
<li>切片间复制<ul>
<li>slice1 := []int{1, 2, 3, 4, 5}</li>
<li>slice2 := []int{5, 4, 3}</li>
<li>copy(slice2, slice1) //只会复制slice1的前3个元素到slice2中</li>
<li>copy(slice1, slice2) //只会复制slice2的前3个元素到slice1的前3个位置</li>
</ul>
</li>
</ul>
</li>
<li>map<ul>
<li>一堆键值对的未排序集合。</li>
<li>变量声明<ul>
<li>var myMap map[string] PersonInfo   //PersonInfo为value的类型</li>
</ul>
</li>
<li>创建<ul>
<li>myMap = make(map[string] PersonInfo)</li>
<li>myMap = map[string] PersonInfo{<pre><code>&quot;1234&quot;: PersonInfo{&quot;1&quot;, &quot;Jack&quot;, &quot;Room 101,...&quot;},
}
</code></pre></li>
</ul>
</li>
<li>元素赋值<ul>
<li>myMap[“1234”] = PersonInfo{“1”, “Jack”, “Room 101,…”}</li>
</ul>
</li>
<li>元素删除<ul>
<li>delete(myMap, “1234”)，key在map中可以不存在，但key本身不可为nil。</li>
</ul>
</li>
<li>元素查找<ul>
<li>value, ok := myMap[“1234”]</li>
<li>if ok { //找到了</li>
<li>//处理找到的value</li>
<li>}</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h5 id="条件语句-if-else"><a href="#条件语句-if-else" class="headerlink" title="条件语句 if-else"></a>条件语句 if-else</h5><h5 id="选择语句-switch-case"><a href="#选择语句-switch-case" class="headerlink" title="选择语句 switch-case"></a>选择语句 switch-case</h5><ul>
<li>条件表达式不限制为常量或者整数</li>
<li>Go语言不需要用break来明确退出一个case</li>
<li>只有在case中明确 加fallthrough关键字,才会继续执行紧跟的下一个case;</li>
</ul>
<h5 id="循环语句-for"><a href="#循环语句-for" class="headerlink" title="循环语句 for"></a>循环语句 for</h5><ul>
<li>Go中<code>没有while</code></li>
<li>break可选择中止哪个标签处的循环</li>
<li>continue</li>
</ul>
<h5 id="跳转语句-goto"><a href="#跳转语句-goto" class="headerlink" title="跳转语句 goto"></a>跳转语句 goto</h5><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h5 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h5><pre><code>package mymath
import &quot;errors&quot;

func Add(a int, b int) (ret int, err error) {
    if a &lt; 0 || b &lt; 0 {
        err= errors.New(&quot;Should be non-negative numbers!&quot;)
        return
    }
    return a + b, nil //支持多重返回值
}
</code></pre><h5 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h5><ul>
<li>小写字母开头的函数只在本包内可见,大写字母开头的函数才能被其他包使用。</li>
<li><p>使用函数</p>
<pre><code>import &quot;mymath&quot;
c := mymath.Add(1, 2)
</code></pre></li>
</ul>
<h5 id="不定参数"><a href="#不定参数" class="headerlink" title="不定参数"></a>不定参数</h5><ul>
<li><p>固定类型的不定参数</p>
<pre><code>func myfunc(args ...int) {
    for _, arg := range args {
        fmt.Println(arg)
    }
}
</code></pre></li>
<li><p>任意类型的不定参数</p>
<pre><code>func Printf(format string, args ...interface{}) {
}
</code></pre></li>
</ul>
<h5 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h5><h5 id="匿名函数与闭包"><a href="#匿名函数与闭包" class="headerlink" title="匿名函数与闭包"></a>匿名函数与闭包</h5><ul>
<li><p>匿名函数后跟参数列表表示函数调用</p>
<pre><code>func(ch chan int) {
    ch &lt;- ACK
} (reply_chan)
</code></pre></li>
<li><p>Go的匿名函数是一个闭包。</p>
</li>
</ul>
<h3 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h3><h5 id="error"><a href="#error" class="headerlink" title="error"></a>error</h5><h5 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h5><ul>
<li><p>defer例子</p>
<pre><code>srcFile, err := os.Open(src)
if err != nil {
    return
}
defer srcFile.Close()
</code></pre></li>
<li><p>可使用匿名函数来defer</p>
<pre><code>defer func() {
    //复杂的清理工作
} ()
</code></pre></li>
<li><p>一个函数中可以存在多个defer语句,因此需要注意的是,defer语句的调用是按先进后出的原则, 最后一个defer语句将最先被执行。只不过,当你需要为defer语句到底哪个先执行这种细节而烦恼的时候,说明你的代码结构可能需要调整一下了。</p>
</li>
</ul>
<h5 id="panic-与recover"><a href="#panic-与recover" class="headerlink" title="panic()与recover()"></a>panic()与recover()</h5><ul>
<li><p>func panic(interface{})</p>
<ul>
<li>函数执行过程中调用panic，函数立即停止执行，但defer语句还会正常执行，之后函数将返回到调用函数，并导致逐层向上执行panic流程，直至所属的goroutine中所有正在执行的函数被终止。</li>
<li>例子<ul>
<li>panic(404)</li>
<li>panic(“network broken”)</li>
<li>panic(Error(“file not exists”))</li>
</ul>
</li>
</ul>
</li>
<li><p>func recover() interface{}</p>
<ul>
<li>recover用于终止错误处理流程。一般recover在defer函数中执行以有效<code>截取</code>错误处理流程。goroutine发生异常后没有调用recover的话会导致goroutine所属进程打印异常信息后直接退出。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a><center>面向对象编程</center></h1><h3 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h3><ul>
<li>在Go语言中,你可以给任意类型(包括内置类型,但不包括指针类型)添加相应的方法。</li>
<li>Go语言和C语言一样,类型都是基于值传递的。要想修改变量的值,只能传递指针。</li>
</ul>
<h5 id="值语义和引用语义"><a href="#值语义和引用语义" class="headerlink" title="值语义和引用语义"></a>值语义和引用语义</h5><ul>
<li>Go语言中的大多数类型都基于值语义：byte、int、bool、float32、string、array、struct、pointer</li>
<li>数组也是值引用<ul>
<li>var a = [3]int{1,2,3}</li>
<li>var b = a</li>
<li>修改b数组对a没有任何影响</li>
<li>数组赋值时，<code>将内容完整复制</code>。</li>
</ul>
</li>
<li>数组也可使用引用赋值<ul>
<li>var b = &amp;a</li>
<li>修改b后a也同步修改</li>
<li>赋值后，b的类型是 *[3]int，而不是[3]int</li>
</ul>
</li>
<li>数组切片内部是指向数组的指针，可改变所指向的数组元素。</li>
<li>map本质上是一个字典指针；channel与map类似，本质上是一个指针。</li>
</ul>
<h5 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h5><pre><code>type Rect struct {
    x, y float64
    width, height float64
}

func (r *Rect) Area() float64 {
    return r.width * r.height
}
</code></pre><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li>在Go语言中,未进行显式初始化的变量都会被初始化为该类型的零值,例如bool类型的零值为false,int类型的零值为0,string类型的零值为空字符串。<ul>
<li>rect1 := new(Rect)</li>
<li>rect2 := &amp;Rect{}</li>
<li>rect3 := &amp;Rect{0, 0, 100, 200}</li>
<li>rect4 := &amp;Rect{width: 100, height: 200}</li>
</ul>
</li>
<li><p>Go语言中没有构造函数的概念,对象的创建通常交由一个全局的创建函数来完成,以NewXXX来命名,表示“构造函数”。</p>
<pre><code>func NewRect(x, y, width, height float64) *Rect {
    return &amp;Rect{x, y, width, height}
}
</code></pre></li>
</ul>
<h3 id="匿名组合"><a href="#匿名组合" class="headerlink" title="匿名组合"></a>匿名组合</h3><ul>
<li><p>Base类实现Foo()、Bar()方法</p>
<pre><code>type Base struct {
    Name string
}
func (base *Base) Foo() { ... }
func (base *Base) Bar() { ... }
</code></pre></li>
<li><p>Foo类从Base类“继承”并改写Bar()方法</p>
<pre><code>type Foo struct {
    Base
    ...
}
</code></pre></li>
</ul>
<pre><code>func (foo *Foo) Bar() {
    foo.Base.Bar()
    ...
}
</code></pre><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><ul>
<li>类型的成员变量、方法<code>依靠大小写来实现可见性</code>。</li>
<li>可访问性是包一级而不是类型一级。即类型Rect的area()方法，同一个package的其他类型也可访问到。</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>goroutine和channel是支撑起Go语言的并发模型的基石,接口是Go语言整个类型系统的基石。</li>
<li>Go语言中,一个类只需要实现了接口要求的所有函数,我们就说这个类实现了该接口。类中的方法可以多于接口中的方法。</li>
</ul>
<h5 id="接口赋值"><a href="#接口赋值" class="headerlink" title="接口赋值"></a>接口赋值</h5><ul>
<li>将对象实例赋值给接口<ul>
<li>对象实例需实现接口中的所有方法</li>
<li>var b interfaceName = &amp;a</li>
</ul>
</li>
<li>将一个接口赋值给另一个接口<ul>
<li>只要2接口拥有相同的方法列表（次序可不同），即为等同的，可相互赋值。</li>
</ul>
</li>
</ul>
<h5 id="接口查询"><a href="#接口查询" class="headerlink" title="接口查询"></a>接口查询</h5><ul>
<li><p>查询对象实例是否实现了某个接口</p>
<pre><code>var file1 Writer = ...
if file5, ok := file1.(two.IStream); ok {
    ...
}
</code></pre></li>
</ul>
<h5 id="类型查询"><a href="#类型查询" class="headerlink" title="类型查询"></a>类型查询</h5><ul>
<li><p>查询接口指向的对象实例的类型。</p>
<pre><code>var v1 interface{} = ...
switch v := v1.(type) {
    case int:     //现在v的类型是 int 
    case string:  //现在v的类型是 string
    ...
}
</code></pre></li>
<li>类型查询不常使用，常配合接口查询使用。</li>
<li>利用反射也可进行类型查询：reflect.TypeOf()</li>
</ul>
<h5 id="接口组合"><a href="#接口组合" class="headerlink" title="接口组合"></a>接口组合</h5><ul>
<li>Go支持类型组合，也支持接口组合。</li>
</ul>
<h5 id="Any类型"><a href="#Any类型" class="headerlink" title="Any类型"></a>Any类型</h5><ul>
<li>当函数可以接受任意的对象实例时,我们会将其声明为interface{}，任何对象实例都满足空接口interface{}。</li>
</ul>
<hr>
<h1 id="并发编程-1"><a href="#并发编程-1" class="headerlink" title="并发编程"></a><center>并发编程</center></h1><h3 id="并发基础"><a href="#并发基础" class="headerlink" title="并发基础"></a>并发基础</h3><ul>
<li>多进程</li>
<li>多线程</li>
<li>基于回调的非阻塞/异步IO<ul>
<li>通过事件驱动的方式使用异步IO,使服务器持续运转,且尽可能地少用线程,降低开销,它目前在Node.js中得到了很好的实践。但是使用这种模式,编程比多线程要复杂,因为它把流程做了分割,对于问题本身的反应不够自然。</li>
</ul>
</li>
<li>协程<ul>
<li>本质上是一种用户态线程,不需要操作系统来进行抢占式调度, 且在真正的实现中寄存于线程中。</li>
</ul>
</li>
<li>线程间通信方式：<code>共享内存</code>。为保证共享内存有效性，采取了加锁来避免死锁或资源竞争。</li>
<li><code>消息传递</code><ul>
<li>对线程间共享状态的各种操作都被封装在线程之间传递的消息中，这通常要求:发送消息时对状态进行复制,并且在消息传递的边界上交出这个状态的所有所有权。</li>
<li>由于需执行复制操作，大多消息传递的实现在性能上并不优越。但线程中的状态管理会更简单。</li>
</ul>
</li>
</ul>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><ul>
<li>线程和进程通常最多也不能超过1万个，而协程可轻松创建上百万个而不会导致系统资源衰间竭。</li>
</ul>
<h3 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h3><ul>
<li>goroutine为Go中的协程，Go语言标准库提供的所有系统调用操作（当然也包括所有同步IO操作），都会让出CPU给其他goroutine。</li>
<li>goroutine由Go运行时管理。</li>
<li>函数前加<code>go</code>关键字，则会在一个新的goroutine中并发执行。<code>若有返回值，返回值会被丢弃</code>。</li>
<li>main函数并不会等待其内的goroutine执行完毕，可能goroutine未来得及执行，main就退出了。</li>
</ul>
<h3 id="并发通信"><a href="#并发通信" class="headerlink" title="并发通信"></a>并发通信</h3><ul>
<li>不要通过共享内存来通信，而应该通过通信来共享内存。</li>
<li>消息机制：每个并发单元是自包含的、独立的个体，拥有自己的变量，不同并发单元间的变量不共享。</li>
<li>并发单元间的输入、输出只有一种，就是消息。</li>
<li>Go消息通信机制为channel。</li>
</ul>
<h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><ul>
<li>使用channel在2个或多个goroutine间传递消息。channel为进程内部的通信方式，通过channel传对象与函数执行时的参数传递一样，也可传指针。跨进程通信则可用Socket或HTTP。</li>
<li>channel为类型相关，即<code>一个channel只能传一种类型的值</code>。类型需在声明channel时指定。</li>
</ul>
<h5 id="声明、定义、读写"><a href="#声明、定义、读写" class="headerlink" title="声明、定义、读写"></a>声明、定义、读写</h5><ul>
<li>var ch chan int</li>
<li>value为channel类型的map<ul>
<li>var m map[string] chan bool</li>
</ul>
</li>
<li>初始化channel<ul>
<li>ch := make(chan int)</li>
</ul>
</li>
<li>数据写入channel<ul>
<li>ch &lt;- value</li>
<li>向channel写入数据通常会导致程序阻塞,直到有其他goroutine从这个channel中读取数据。</li>
</ul>
</li>
<li>从channel中读取数据<ul>
<li>value := &lt;-ch</li>
<li>如果channel之前没有写入数据,那么从channel中读取数据也会导致程序阻塞,直到channel中被写入数据为止。</li>
</ul>
</li>
</ul>
<h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><pre><code>    select {
        case &lt;-chan1:
            //如果chan1成功读取到数据，则进行case处理语句
        case chan2 &lt;- 1:
            //如果成功向chan2写入数据，则进行该case处理语句
        default:
            //如以上都没成功，则进入default处理流程
    }
- select用于处理`异步IO`问题。
- 每个case必为一个IO操作：面向channel的操作。
</code></pre><h5 id="缓冲机制"><a href="#缓冲机制" class="headerlink" title="缓冲机制"></a>缓冲机制</h5><ul>
<li>给channel带上缓冲，可达到消息队列的效果。</li>
<li>c := make(chan int, 1024)</li>
<li>即使没有读取方,写入方也可以一直往channel里写入,在缓冲区被填完完之前都不会阻塞。</li>
<li><p>可使用range读取数据</p>
<pre><code>for i := range c {
    fmt.Println(&quot;Received:&quot;, i)
}
</code></pre></li>
</ul>
<h5 id="超时机制"><a href="#超时机制" class="headerlink" title="超时机制"></a>超时机制</h5><ul>
<li>select只要其中一个case已经完成,程序就会继续往下执行,而不会考虑其他case的情况。</li>
<li><p>Go语言没有提供直接的超时处理机制,但可利用select机制实现超时处理。</p>
<pre><code>//首先，我们实现并执行一个匿名的超时等待函数
timeout := make(chan bool, 1)
go func() {
    time.Sleep(1e9) //待待1秒钟
    timeout &lt;- true
}()

//然后我们把timeout这个channel利用起来
select {
    case &lt;-ch:
        //从ch中读取到数据
    case &lt;-timeout:
        //一直没有从ch中读取到数据，但从timeout中读取到了数据 
}
</code></pre></li>
</ul>
<h5 id="channel的传递"><a href="#channel的传递" class="headerlink" title="channel的传递"></a>channel的传递</h5><h5 id="单向channel"><a href="#单向channel" class="headerlink" title="单向channel"></a>单向channel</h5><h5 id="关闭channel"><a href="#关闭channel" class="headerlink" title="关闭channel"></a>关闭channel</h5><ul>
<li>close(ch)</li>
<li>判断channel是否关闭<ul>
<li>x, ok := &lt;-ch</li>
<li>ok为false表示ch已经被关闭</li>
</ul>
</li>
</ul>
<h3 id="多核并行化"><a href="#多核并行化" class="headerlink" title="多核并行化"></a>多核并行化</h3><h3 id="出让时间片"><a href="#出让时间片" class="headerlink" title="出让时间片"></a>出让时间片</h3><ul>
<li>在goroutine中主动出让时间片给其他goroutine。<ul>
<li>runtine的Gosched()</li>
</ul>
</li>
</ul>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><ul>
<li>使成功地用channel来作为通信手段,还是避免不了多个goroutine之间共享数据的问题。所以提供了资源锁方案。</li>
</ul>
<h5 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h5><ul>
<li>Go的sync包提供2种锁：sync.Mutex和sync.RWMutex。<ul>
<li>Mutex<ul>
<li>一个goroutine获得Mutex后，其他goroutine只能等待这个goroutine释放该Mutex。</li>
</ul>
</li>
<li>RWMutex<ul>
<li>读锁(RLock())：不可写，但多个goroutine可同时读。</li>
<li>写锁(Lock())：独占，阻止任何其他goroutine(无论读和写)</li>
</ul>
</li>
</ul>
</li>
<li>任何一个Lock()或RLock()均需要保证对应有Unlock()或RUnlock()调用与之对应,否则可能导致等待该锁的所有goroutine处于饥饿状态,甚至可能导致死锁。</li>
</ul>
<h5 id="全局唯一性操作"><a href="#全局唯一性操作" class="headerlink" title="全局唯一性操作"></a>全局唯一性操作</h5><ul>
<li>全局角度只运行一次的代码，可使用Once类型保证全局的唯一性操作。</li>
</ul>
<hr>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a><center>网络编程</center></h1><ul>
<li>IP层：Raw Socket</li>
<li>TCP/UDP层</li>
<li>HTTP、FTP、SMTP层</li>
</ul>
<h3 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h3><ul>
<li>传统Socket编程步骤<ul>
<li>建立Socket：socket()</li>
<li>绑定Socket：bind()</li>
<li>监听：listen()或连接connect()</li>
<li>接受连接：accept()</li>
<li>接收：receive()或发送send()</li>
</ul>
</li>
<li>Go只需要调用net.Dial()即可。</li>
</ul>
<h5 id="Dial-函数"><a href="#Dial-函数" class="headerlink" title="Dial()函数"></a>Dial()函数</h5><ul>
<li>func Dial(net, addr string) (Conn, error)<ul>
<li>TCP链接<ul>
<li>conn, err := net.Dial(“tcp”, “192.168.0.10:2100”)</li>
</ul>
</li>
<li>UDP链接<ul>
<li>conn, err := net.Dial(“udp”, “192.168.0.12:975”)</li>
</ul>
</li>
<li>ICMP链接<ul>
<li>conn, err := net.Dial(“ip4:icmp”, “www.baidu.com”)</li>
<li>conn, err := net.Dial(“ip4:1”, “10.0.0.3”)</li>
</ul>
</li>
</ul>
</li>
<li>支持的协议<ul>
<li>tcp、tcp4、tcp6</li>
<li>udp、udp4、udp6</li>
<li>ip、ip4、ip6</li>
</ul>
</li>
<li>建立连接后，conn.Write()发送数据，conn.Read()接收数据。</li>
</ul>
<h3 id="HTTP编程"><a href="#HTTP编程" class="headerlink" title="HTTP编程"></a>HTTP编程</h3><h5 id="HTTP客户端"><a href="#HTTP客户端" class="headerlink" title="HTTP客户端"></a>HTTP客户端</h5><ul>
<li><p>http.Get()</p>
<pre><code>resp, err := http.Get(&quot;http://example.com/&quot;)
if err != nil {
    //处理错误...
    return
}

defer resp.Body.close()
io.Copy(os.Stdout, resp.Body)
</code></pre><ul>
<li>func (c <em>Client) Get(url string) (r </em>Response, err error)</li>
<li>等价于http.DefaultClient.Get()</li>
</ul>
</li>
<li><p>http.Post()</p>
<pre><code>resp, err := http.Post(&quot;http://example.com/upload&quot;, &quot;image/jpeg&quot;, &amp;imageDataBuf)
if err != nil {
    //处理错误
    return
}

if resp.StatusCode != http.StatusOK {
    //处理错误
    return
}
// ...
</code></pre><ul>
<li>func (c <em>Client) Post(url string, bodyType string, body io.Reader) (r </em>Response, err<br>error)</li>
</ul>
</li>
<li><p>http.PostForm()</p>
<pre><code>resp, err := http.PostForm(&quot;http://example.com/posts&quot;,url.Values{&quot;title&quot;:{&quot;article title&quot;}, &quot;content&quot;: {&quot;article body&quot;}})
if err != nil {
    //处理错误
    return
}
// ...
</code></pre><ul>
<li>实现了标准编码格式为application/x-www-form-urlencoded的表单提交</li>
<li>func (c <em>Client) PostForm(url string, data url.Values) (r </em>Response, err error)</li>
</ul>
</li>
<li>http.Head()<ul>
<li>resp, err := http.Head(“<a href="http://example.com/" target="_blank" rel="external">http://example.com/</a>“)</li>
<li>func (c <em>Client) Head(url string) (r </em>Response, err error)</li>
</ul>
</li>
<li><p>(*http.Client).Do()</p>
<pre><code>req, err := http.NewRequest(&quot;GET&quot;, &quot;http://example.com&quot;, nil)
// ...
req.Header.Add(&quot;User-Agent&quot;, &quot;Gobook Custom User-Agent&quot;)
// ...
client := &amp;http.Client{ //... }
resp, err := client.Do(req)
// ...
</code></pre><ul>
<li>func (c <em>Client) Do(req </em>Request) (resp *Response, err error)</li>
</ul>
</li>
<li>http.Get()、http.Post()、http.PostForm()和http.Head()方法其实都是在http.DefaultClient的基础上进行调用的,比如http.Get()等价于http.DefaultClient.Get()。</li>
<li><p>自定义http.Client</p>
<pre><code>type Client struct {
    //Transport用于确定HTTP请求的创建机制
    //如果为空，将会使用DefaultTransport
    Transport RoundTripper

    //CheckRedirect定义重定向策略
    //如果CheckRedirect不为空，客户端将在跟踪HTTP重定向前调用该函数
    //两个参数req和via分别为即将发起的请求和已经发起的所有请求，最早的已发起请求在最前面。
    //如果CheckRedirect返回错误，客户端将直接返回错误，不会再发起该请求
    //如果CheckRedirect为空，Client将采用一种确认策略，将在10个连续请求后终止
    CheckRedirect func(req *Request, via []*Request) error

    //如果Jar为空，Cookie将不会在请求中发送，并会在响应中被忽略
    Jar CookieJar
}
</code></pre></li>
</ul>
<h5 id="HTTP服务端"><a href="#HTTP服务端" class="headerlink" title="HTTP服务端"></a>HTTP服务端</h5><ul>
<li>处理HTTP请求<ul>
<li>net/http 包提供的http.ListenAndServe()方法</li>
<li>func ListenAndServe(addr string, handler Handler) error</li>
</ul>
</li>
<li>处理HTTPS请求<ul>
<li>net/http 包还提供 http.ListenAndServeTLS()方法</li>
<li>func ListenAndServeTLS(addr string, certFile string, keyFile string, handler Handler) error<ul>
<li>certFile对应SSL证书文件存放路径</li>
<li>keyFile对应证书私钥文件路径。</li>
<li>如果证书是由证书颁发机构签署的,certFile参数指定的路径必须是存放在服务器上的经由CA认证过的SSL证书。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="RPC编程"><a href="#RPC编程" class="headerlink" title="RPC编程"></a>RPC编程</h3><ul>
<li>RPC协议构建与TCP或UDP，或者是HTTP之上。</li>
</ul>
<h5 id="Go中的RPC支持与处理"><a href="#Go中的RPC支持与处理" class="headerlink" title="Go中的RPC支持与处理"></a>Go中的RPC支持与处理</h5><ul>
<li>RPC服务端,可将一个对象注册为可访问的服务,之后该对象的公开方法就能够以远程的方式提供访问。一个 RPC服务端可以注册多个不同类型的对象,但不允许注册同一类型的多个对象。</li>
<li>func (t <em>T) MethodName(argType T1, replyType </em>T2) error</li>
</ul>
<h3 id="JSON处理"><a href="#JSON处理" class="headerlink" title="JSON处理"></a>JSON处理</h3><h5 id="编码为JSON格式"><a href="#编码为JSON格式" class="headerlink" title="编码为JSON格式"></a>编码为JSON格式</h5><ul>
<li>func Marshal(v interface{}) ([]byte, error)</li>
<li>b, err := json.Marshal(gobook)</li>
</ul>
<h5 id="解码JSON数据"><a href="#解码JSON数据" class="headerlink" title="解码JSON数据"></a>解码JSON数据</h5><ul>
<li>func Unmarshal(data []byte, v interface{}) error</li>
<li>var book Book</li>
<li>err := json.Unmarshal(b, &amp;book)</li>
</ul>
<h5 id="解码未知结构的JSON数据"><a href="#解码未知结构的JSON数据" class="headerlink" title="解码未知结构的JSON数据"></a>解码未知结构的JSON数据</h5><ul>
<li>var r interface{}</li>
<li>err := json.Unmarshal(b, &amp;r)</li>
<li>r将会是一个键值对的map[string] interface{}结构</li>
<li>gobook, ok := r.(map[string]interface{})</li>
</ul>
<h5 id="JSON的流式读写"><a href="#JSON的流式读写" class="headerlink" title="JSON的流式读写"></a>JSON的流式读写</h5><ul>
<li>encoding/json 包还提供Decoder和Encoder两个类型,用于支持JSON数据的流式读写,并提供NewDecoder()和NewEncoder()两个函数来便于具体实现<ul>
<li>func NewDecoder(r io.Reader) *Decoder</li>
<li>func NewEncoder(w io.Writer) *Encoder</li>
</ul>
</li>
</ul>
<h3 id="网站开发"><a href="#网站开发" class="headerlink" title="网站开发"></a>网站开发</h3><h5 id="最简单的网站程序"><a href="#最简单的网站程序" class="headerlink" title="最简单的网站程序"></a>最简单的网站程序</h5><pre><code>package main

import (
    &quot;io&quot;
    &quot;log&quot;
    &quot;net/http&quot;
)

func helloHandler(w http.ResponseWriter, r *http.Request){
    io.WriteString(w, &quot;Hello, world!&quot;)
}

func main() {
    http.HandleFunc(&quot;/hello&quot;, helloHandler)
    err := http.ListenAndServe(&quot;:8080&quot;, nil)
    if err != nil {
        log.Fatal(&quot;ListenAndServe: &quot;, err.Error())
    }
}
</code></pre><hr>
<h1 id="安全编程"><a href="#安全编程" class="headerlink" title="安全编程"></a><center>安全编程</center></h1><h1 id="工程管理"><a href="#工程管理" class="headerlink" title="工程管理"></a><center>工程管理</center></h1><h3 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h3><h5 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h5><ul>
<li>变量、常量、全 函数、结构、接口、方法：任何需要对外暴露的名字必须以大写字母开头,不需要对外暴露的则应该以小写字母开头。</li>
<li>拥护驼峰命名法而排斥下划线法。</li>
</ul>
<h5 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h5><ul>
<li>约定了代码块中花括号的明确摆放位置。</li>
</ul>
<h5 id="代码格式代"><a href="#代码格式代" class="headerlink" title="代码格式代"></a>代码格式代</h5><ul>
<li>go fmt hello.go</li>
<li>若执行 go fmt，则格式化当前目录下所有代码。</li>
</ul>
<h3 id="远程import"><a href="#远程import" class="headerlink" title="远程import"></a>远程import</h3><pre><code>import (
    &quot;fmt&quot;
    &quot;github.com/myteam/exp/crc32&quot;
)
</code></pre><hr>
<h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a><center>开发工具</center></h1><h1 id="进阶话题"><a href="#进阶话题" class="headerlink" title="进阶话题"></a><center>进阶话题</center></h1><h3 id="反射-1"><a href="#反射-1" class="headerlink" title="反射"></a>反射</h3><ul>
<li>反射的代码可读性差，如非必要，不推荐使用。</li>
<li><p>Type与Value</p>
<pre><code>var reader io.Reader
reader = &amp;MyReader{&quot;a.txt&quot;}
</code></pre><ul>
<li>Type：被反射的变量本身的类型信息</li>
<li>Value：被反射的变量实例本身的信息</li>
<li>Type为io.Reader,Value为MyReader{“a.txt”}</li>
</ul>
</li>
<li><p>获取类型信息</p>
<pre><code>package main

import (
    &quot;fmt&quot;
      &quot;reflect&quot;
  )

func main() {
    var x float64 = 3.4
    fmt.Println(&quot;type:&quot;, reflect.TypeOf(x))
}
</code></pre><ul>
<li>reflect.TypeOf()</li>
<li>v := reflect.ValueOf(x)、v.Type()、v.Float()</li>
</ul>
</li>
</ul>
<h3 id="goroutine机理"><a href="#goroutine机理" class="headerlink" title="goroutine机理"></a>goroutine机理</h3><h5 id="协程-1"><a href="#协程-1" class="headerlink" title="协程"></a>协程</h5><ul>
<li>能够在单一的系统线程中模拟多个任务的并发执行。</li>
<li>在一个特定的时间,只有一个任务在执行,即并非真正地并行。</li>
<li>被动的任务调度方式,即任务没有主动抢占时间片的说法。当一个任务正在执行时,外部没有办法中止它。要进行任务切换,只能通过由该任务自身调用yield()来主动出让CPU使用权。</li>
<li>每个协程都有自己的堆栈和局部变量。</li>
<li>协程都包含3种运行状态:挂起、运行和停止。</li>
</ul>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    



                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/mamian" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">© 2016  <a href="http://www.mamian.net/" target="_blank">mamian</a>  All Rights Reserved</p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>