<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="第1章 初识容器与docker1.1 什么是docker
基于Go实现的开源容器项目
Docker可理解为一种轻量级的沙盒。每个容器内运行着一个应用，不同的容器相互隔离，容器之间也可以通过网络互相通信。
容器自身对系统资源的额外需求也十分有限，远低于传统虚拟机。

1.2 为什么要使用docker开">
    

    <!--Author-->
    
        <meta name="author" content="mamian">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="《Docker技术入门与实战》读书笔记"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="马面"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

        <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>《Docker技术入门与实战》读书笔记 - 马面</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    


</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">马面</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives/index.html">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags/index.html">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories/index.html">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/about/index.html">
                            
                                About
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/mamian">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('http://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>《Docker技术入门与实战》读书笔记</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        2017-07-23
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/docker/">#docker</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h1 id="第1章-初识容器与docker"><a href="#第1章-初识容器与docker" class="headerlink" title="第1章 初识容器与docker"></a>第1章 初识容器与docker</h1><h3 id="1-1-什么是docker"><a href="#1-1-什么是docker" class="headerlink" title="1.1 什么是docker"></a>1.1 什么是<a href="https://github.com/docker/docker" target="_blank" rel="external">docker</a></h3><ul>
<li>基于Go实现的开源容器项目</li>
<li>Docker可理解为一种轻量级的沙盒。每个容器内运行着一个应用，不同的容器相互隔离，容器之间也可以通过网络互相通信。</li>
<li>容器自身对系统资源的额外需求也十分有限，远低于传统虚拟机。</li>
</ul>
<h3 id="1-2-为什么要使用docker"><a href="#1-2-为什么要使用docker" class="headerlink" title="1.2 为什么要使用docker"></a>1.2 为什么要使用docker</h3><h5 id="开发和运维中的优势"><a href="#开发和运维中的优势" class="headerlink" title="开发和运维中的优势"></a>开发和运维中的优势</h5><ul>
<li>更快速的交付和部署</li>
<li>更高效的资源利用</li>
<li>更轻松的迁移和扩展</li>
<li>更简单的更新管理</li>
</ul>
<h5 id="与传统虚拟机相比"><a href="#与传统虚拟机相比" class="headerlink" title="与传统虚拟机相比"></a>与传统虚拟机相比</h5><ul>
<li>Docker容器很快，启动和停止可在秒级实现。</li>
<li>Docker对系统资源需求少，一台主机可同时运行数千个Docker容器。</li>
<li>Docker通过类似git设计理念的操作来方便用户获取、分发、更新应用镜像，存储复用，增量更新。</li>
<li>Docker通过 Dockerfile 支持灵活的自动化创建和部署机制，提高工效，使流程标准化。</li>
</ul>
<h3 id="1-3-docker与虚拟化"><a href="#1-3-docker与虚拟化" class="headerlink" title="1.3 docker与虚拟化"></a>1.3 docker与虚拟化</h3><ul>
<li>虚拟化核心为<code>对资源的抽象</code>，目标为在同一个主机上同时运行多个系统或应用，提高资源利用率、降低成本、方便管理、容错容灾。</li>
<li>虚拟化分类<ul>
<li>硬件虚拟化（很少）</li>
<li>软件虚拟化<ul>
<li>应用虚拟化<ul>
<li>模拟设备</li>
<li>wine等软件</li>
</ul>
</li>
<li>平台虚拟化<ul>
<li>完全虚拟化<ul>
<li>虚拟机模拟完整的底层硬件环境和特权指令执行过程，客户操作系统无须修改。如VMware Workstation、VirtualBox。</li>
</ul>
</li>
<li>硬件辅助虚拟化<ul>
<li>利用硬件（如CPU的虚拟化技术Intel-VT、AMD-V）处理敏感指令实现完全虚拟化功能，客户操作系统无须修改。如VMware Workstation、Xen、KVM。</li>
</ul>
</li>
<li>部分虚拟化<ul>
<li>部分硬件资源进行虚拟化，客户操作系统需进行修改。</li>
</ul>
</li>
<li>准虚拟化<ul>
<li>部分硬件接口以软件形式提供给客户机操作系统，客户操作系统需进行修改。如早期的 Xen。</li>
</ul>
</li>
<li><code>操作系统级虚拟化</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Docker容器在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，更轻量级。</li>
</ul>
<hr>
<h1 id="第2章-核心概念与安装配置"><a href="#第2章-核心概念与安装配置" class="headerlink" title="第2章 核心概念与安装配置"></a>第2章 核心概念与安装配置</h1><h3 id="2-1-核心概念"><a href="#2-1-核心概念" class="headerlink" title="2.1 核心概念"></a>2.1 核心概念</h3><ul>
<li>Docker镜像<ul>
<li>Docker镜像是一个<code>只读</code>的模板。</li>
<li>镜像是创建Docker容器的基础。通过版本管理和增量文件系统，Docker提供了十分简单的机制来创建和更新现有镜像。</li>
</ul>
</li>
<li><p>Docker容器</p>
<ul>
<li>Docker利用容器来<code>运行和隔离应用</code>。</li>
<li>容器是从镜像创建的应用运行实例。可以将其启动、开始、停止、删除，容器间彼此隔离、互不可见。</li>
<li>镜像自身是只读的。容器从镜像启动的时候，会在镜像的最上层创建一个<code>可写层</code>。</li>
</ul>
</li>
<li><p>Docker仓库</p>
<ul>
<li>类似于代码仓库，是Docker集中存放镜像文件的场所。</li>
<li><code>仓库注册服务器</code>是仓库的仓库，其上往往存放着多个仓库。</li>
<li>公开仓库、私有仓库。</li>
</ul>
</li>
</ul>
<h3 id="2-2-安装docker"><a href="#2-2-安装docker" class="headerlink" title="2.2 安装docker"></a>2.2 安装docker</h3><ul>
<li>Docker Platform<ul>
<li>支持在桌面系统或云平台安装Docker</li>
</ul>
</li>
<li>DockerHub<ul>
<li>官方云托管服务，提供公有或私有镜像仓库</li>
</ul>
</li>
<li>DockerCloud<ul>
<li>官方容器云服务，可完成容器部署与管理，可完整支持容器化项目，还有CI、CD功能。</li>
</ul>
</li>
<li>Docker DataCenter<ul>
<li>提供企业级的简单安全弹性的容器集群编排和管理。</li>
</ul>
</li>
</ul>
<blockquote>
<p>尽量使用Linux来运行Docker，Linux原生支持。</p>
</blockquote>
<h5 id="2-2-1-Ubuntu环境下安装docker"><a href="#2-2-1-Ubuntu环境下安装docker" class="headerlink" title="2.2.1 Ubuntu环境下安装docker"></a>2.2.1 Ubuntu环境下安装docker</h5><ul>
<li>系统要求：64位、内核&gt;3.10<ul>
<li>查询linux版本：uname -a 或 cat /proc/version</li>
<li>为让docker使用aufs存储，安装linux-image-extra软件包<ul>
<li>sudo apt-get install -y linux-image-extra-$(uname -r)</li>
</ul>
</li>
<li>ubuntu&gt;14.04 LTS</li>
</ul>
</li>
<li>添加镜像源<ul>
<li>安装apt-transport-https以支持https协议的源<ul>
<li>sudo apt-get install -y apt-transport-https</li>
</ul>
</li>
<li>添加源的gpg密钥<ul>
<li>sudo apt-key adv –keyserver hkp://p80.pool.sks-keyservers.net:80 –recv-keys 58118E89F3A912897C070ADBF76221572C52609D</li>
</ul>
</li>
<li>获取当前操作系统代号<ul>
<li>lsb_release -c</li>
<li>14.04 LTS代号为trusty</li>
</ul>
</li>
<li>添加docker官方apt源，通过以下命令创建/etc/apt/sources.list.d/docker.list，并写入源的地址。<ul>
<li>sudo cat &lt;<eof>&gt; /etc/apt/sources.list.d/docker.list<br>deb <a href="https://apt.dockerproject.org/repo" target="_blank" rel="external">https://apt.dockerproject.org/repo</a> ubuntu-trusty main<br>EOF</eof></li>
</ul>
</li>
<li>添加成功后，更新apt软件包缓存<ul>
<li>sudo apt-get update</li>
</ul>
</li>
</ul>
</li>
<li>开始安装docker<ul>
<li>sudo apt-get install -y docker-engine</li>
<li>除手动添加软件源方式安装，也可使用官方脚本自动化安装<ul>
<li>sudo curl -sSL <a href="https://get.docker.com/" target="_blank" rel="external">https://get.docker.com/</a> | sh</li>
</ul>
</li>
<li>安装成功后启动docker<ul>
<li>sudo service docker start</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2-2-2-Centos环境下安装docker"><a href="#2-2-2-Centos环境下安装docker" class="headerlink" title="2.2.2 Centos环境下安装docker"></a>2.2.2 Centos环境下安装docker</h5><ul>
<li><p>添加yum源</p>
<ul>
<li>sudo tee /etc/yum.repos.d/docker.repo &lt;&lt;-‘EOF’<br>name=Docker Repository<br>baseurl=<a href="https://yum.dockerproject.org/repo/main/centos/$releasever/" target="_blank" rel="external">https://yum.dockerproject.org/repo/main/centos/$releasever/</a><br>enabled=1<br>gpgcheck=1<br>gpgkey=<a href="https://yum.dockerproject.org/gpg" target="_blank" rel="external">https://yum.dockerproject.org/gpg</a><br>EOF</li>
</ul>
</li>
<li><p>更新yum软件源缓存</p>
<ul>
<li>sudo yum update</li>
</ul>
</li>
<li>安装docker-engine<ul>
<li>sudo yum install -y docker-engine</li>
</ul>
</li>
<li>centos7的CentOS_Extras源已内置docker，可直接安装。</li>
</ul>
<h5 id="2-2-3-通过脚本安装"><a href="#2-2-3-通过脚本安装" class="headerlink" title="2.2.3 通过脚本安装"></a>2.2.3 通过脚本安装</h5><ul>
<li>curl -fsSL <a href="https://get.docker.com/" target="_blank" rel="external">https://get.docker.com/</a> | sh<ul>
<li>或 wget -qo- <a href="https://get.docker.com/" target="_blank" rel="external">https://get.docker.com/</a> | sh</li>
</ul>
</li>
<li>安装预发布版<ul>
<li>curl -fsSL <a href="https://test.docker.com/" target="_blank" rel="external">https://test.docker.com/</a> | sh</li>
</ul>
</li>
</ul>
<h5 id="2-2-4-Mac-os环境下安装docker"><a href="#2-2-4-Mac-os环境下安装docker" class="headerlink" title="2.2.4 Mac os环境下安装docker"></a>2.2.4 Mac os环境下安装docker</h5><ul>
<li>略</li>
</ul>
<h5 id="2-2-5-Windows环境下安装docker"><a href="#2-2-5-Windows环境下安装docker" class="headerlink" title="2.2.5 Windows环境下安装docker"></a>2.2.5 Windows环境下安装docker</h5><ul>
<li>略</li>
</ul>
<h3 id="2-3-配置docker服务"><a href="#2-3-配置docker服务" class="headerlink" title="2.3 配置docker服务"></a>2.3 配置docker服务</h3><ul>
<li>将当前用户加入安装中自动创建的docker用户组（避免每次使用docker命令都要sudo）<ul>
<li>sudo usermod -aG docker USER_NAME</li>
<li>退出重新登录生效</li>
</ul>
</li>
<li>docker默认配置文件：<code>/etc/default/docker</code><ul>
<li>修改参数，如让docker服务通过本地2375端口接收来自外部的请求<ul>
<li>DOCKER_OPTS=”$DOCKER_OPTS -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock”</li>
</ul>
</li>
<li>修改后重启docker服务：<ul>
<li>sudo service docker restart</li>
</ul>
</li>
</ul>
</li>
<li>docker服务管理脚本：/etc/init.d/docker<ul>
<li>功能为将docker进程id写入/var/run/docker.pid，并通过ulimit调整系统资源限制。</li>
</ul>
</li>
<li>若通过upstart工具管理服务，则管理服务配置文件为/etc/init/docker.conf</li>
<li>CentOS、Redhat，服务可通过systemd管理<ul>
<li>sudo systemctl start docker.service</li>
</ul>
</li>
<li>如服务异常，可查看docker服务日志<ul>
<li>sudo tail /var/log/upstart/docker.log</li>
</ul>
</li>
<li>重启docker服务后，查看服务是否正常启动<ul>
<li>docker version</li>
</ul>
</li>
</ul>
<h3 id="2-4-推荐实践环境"><a href="#2-4-推荐实践环境" class="headerlink" title="2.4 推荐实践环境"></a>2.4 推荐实践环境</h3><ul>
<li>Ubuntu 14.04.3 LTS</li>
</ul>
<hr>
<h1 id="第3章-使用docker镜像"><a href="#第3章-使用docker镜像" class="headerlink" title="第3章 使用docker镜像"></a>第3章 使用docker镜像</h1><h3 id="3-1-获取镜像"><a href="#3-1-获取镜像" class="headerlink" title="3.1 获取镜像"></a>3.1 获取镜像</h3><ul>
<li>从官方docker hub镜像源下载镜像：<code>docker pull NAME[:TAG]</code><ul>
<li>NAME为境像仓库名，TAG为镜像标签（通常为版本）</li>
<li>获取ubuntu：<code>docker pull ubuntu:14.04</code></li>
<li>不显示指定TAG，默认选择latest标签</li>
</ul>
</li>
<li>从pull过程可知，镜像文件由若干层组成。当不同镜像包含相同的层时，本地仅存一份。</li>
<li>从不同的仓库下载镜像，可能重名。严格的说，镜像仓库名中应添加仓库地址，默认为从docker hub下载，前缀可忽略。<ul>
<li>docker pull registry.hub.docker.com/ubuntu:14.04 即 docker pull ubuntu:14.04</li>
</ul>
</li>
<li>下载镜像后，利用镜像创建容器，在容器中执行bash应用：<code>docker run -it ubuntu:14.04 bash</code>，bash中执行命令：<code>ping localhost</code></li>
</ul>
<h3 id="3-2-查看镜像信息"><a href="#3-2-查看镜像信息" class="headerlink" title="3.2 查看镜像信息"></a>3.2 查看镜像信息</h3><ul>
<li>列出镜像：<code>docker images</code><ul>
<li>镜像大小信息仅表示其逻辑大小，物理占用存储空间会小于各镜像逻辑体积之和。</li>
<li>images子命令选项<ul>
<li>-a, –all=true|false：列出所有镜像文件，默认为否</li>
<li>–digests=true|false：列出镜像数字摘要值，默认为否</li>
<li>-f, –filter=[]：过滤列出的镜像，如dangling=true只显示未被使用的镜像；也可指定带有特定标注的镜像。</li>
<li>–format=”TEMPLATE”：控制输出格式，如.ID代表ID信息，.Repository代表仓库信息。</li>
<li>–no-trunc=true|false：对输出结果中太长部分是否截断，如镜像ID，默认为是。</li>
<li>-q, –quiet=true|false：仅输出ID，默认为否。</li>
</ul>
</li>
<li>更多子命令：<code>man docker-images</code></li>
</ul>
</li>
<li>使用tag命令为本地镜像添加标签：<code>docker tag ubuntu:latest myubuntu:latest</code><ul>
<li>添加标签后，镜像ID并没有改变，只是一个别名。</li>
</ul>
</li>
<li>查看镜像详细信息：<code>docker inspect ubuntu:14.04</code></li>
<li>查看镜像历史(镜像创建过程)：<code>docker history ubuntu:14.04</code></li>
</ul>
<h3 id="3-3-搜寻镜像"><a href="#3-3-搜寻镜像" class="headerlink" title="3.3 搜寻镜像"></a>3.3 搜寻镜像</h3><ul>
<li>搜索远程仓库镜像：<code>docker search TERM</code></li>
<li>子命令<ul>
<li>–automated=true|false：仅显示自动创建的镜像，默认为否</li>
<li>–no-trunc=true|false：输出信息不截断显示，默认为否</li>
<li>-s, –stars=X：仅显示评价为指定星级以上的镜像，默认为0，即输出所有镜像</li>
</ul>
</li>
<li><code>docker search --automated -s 3 nginx</code></li>
<li>默认按星级评价排序</li>
</ul>
<h3 id="3-4-删除镜像"><a href="#3-4-删除镜像" class="headerlink" title="3.4 删除镜像"></a>3.4 删除镜像</h3><ul>
<li>docker rmi IMAGE [IMAGE…]<ul>
<li>IMAGE可以为标签或ID</li>
<li>docker rmi myubuntu:latest</li>
<li>若镜像有多个标签，docker rmi只会删除1个标签，镜像本身还存在；但若镜像只有一个标签，则会删除镜像文件的所有层。</li>
</ul>
</li>
<li>使用镜像ID删除镜像<ul>
<li>docker rmi ID，会先尝试删除镜像所有标签，再删除镜像文件本身。</li>
<li>当有镜像创建的容器存在，镜像文件默认无法删除</li>
<li>强行删除镜像（即使有容器存在）：docker rmi -f ubuntu:14.04</li>
<li>不推荐强行删除镜像，一般先删除镜像的所有容器，再删除镜像。</li>
</ul>
</li>
<li>查看本机上所有容器<ul>
<li>docker ps -a</li>
</ul>
</li>
</ul>
<h3 id="3-5-创建镜像（3种方式）"><a href="#3-5-创建镜像（3种方式）" class="headerlink" title="3.5 创建镜像（3种方式）"></a>3.5 创建镜像（3种方式）</h3><ul>
<li><p>基于已有镜像的容器创建</p>
<ul>
<li>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]<ul>
<li>-a, –author=””：作者</li>
<li>-c, –change=[]：提交时执行Dockerfile指令，包括CMD|ENTRYPOINT|ENV|EXPOSE|LABEL|ONBUILD|USER|VOLUME|WORKDIR等</li>
<li>-m, –message=””：提交消息</li>
<li>-p, –pause=true：提交时暂停容器运行。</li>
</ul>
</li>
<li>创建步骤<ul>
<li>启动容器：docker run -it ubuntu:14.04 /bin/bash</li>
<li>记住容器ID</li>
<li>在容器中进行修改</li>
<li>以容器为基准创建新镜像<ul>
<li>docker commit -m “修改的具体内容” -a “马面” 容器ID test:0.1</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>基于本地模板导入</p>
<ul>
<li>docker import [OPTIONS] file|URL|-[REPOSITORY[:TAG]]</li>
<li><a href="http://openvz.org/Download/templates/precreated" target="_blank" rel="external">OPENVZ模板下载</a></li>
<li>cat ubuntu-14.04-x86_64-minimal.tar.gz | docker import - ubuntu:14.04</li>
</ul>
</li>
<li><p>基于Dockerfile创建</p>
<ul>
<li>略</li>
</ul>
</li>
</ul>
<h3 id="3-6-存出和载入镜像"><a href="#3-6-存出和载入镜像" class="headerlink" title="3.6 存出和载入镜像"></a>3.6 存出和载入镜像</h3><ul>
<li>存出镜像：导出镜像到本地文件<ul>
<li>docker save -o ubuntu_14.04.tar ubuntu:14.04</li>
</ul>
</li>
<li>载入镜像<ul>
<li>docker load –input ubuntu_14.04.tar 或 docker load &lt; ubuntu_14.04.tar</li>
</ul>
</li>
</ul>
<h3 id="3-7-上传镜像"><a href="#3-7-上传镜像" class="headerlink" title="3.7 上传镜像"></a>3.7 上传镜像</h3><ul>
<li>docker push NAME[:TAG] | [REGISTRY_HOST[:REGISTRY_PORT]/]NAME[:TAG]</li>
<li>用户在docker hub网站注册后即可上传自制镜像<ul>
<li>docker tag test:latest user/test:latest</li>
<li>docker push user/test:latest</li>
</ul>
</li>
<li>第1次上传会提示输入登录信息。</li>
</ul>
<h3 id="3-8-本章小结"><a href="#3-8-本章小结" class="headerlink" title="3.8 本章小结"></a>3.8 本章小结</h3><hr>
<h1 id="第4章-操作docker容器"><a href="#第4章-操作docker容器" class="headerlink" title="第4章 操作docker容器"></a>第4章 操作docker容器</h1><ul>
<li>容器为镜像的运行实例，镜像为静态的只读文件，容器有可写文件层。</li>
</ul>
<h3 id="4-1-创建容器"><a href="#4-1-创建容器" class="headerlink" title="4.1 创建容器"></a>4.1 创建容器</h3><h5 id="新建容器"><a href="#新建容器" class="headerlink" title="新建容器"></a>新建容器</h5><ul>
<li>docker create -it ubuntu:latest</li>
<li>create后容器处于停止状态</li>
<li>create命令与容器运行模式相关的选项</li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a, –attach=[]</td>
<td>是否绑定到标准输入、输出和错误  </td>
</tr>
<tr>
<td>-d, – detach=true</td>
<td>false</td>
<td>是否在后台运行容器，默认否  </td>
</tr>
<tr>
<td>–detach-keys=””</td>
<td>从attach模式退出的快捷键</td>
</tr>
<tr>
<td>–entrypoint=””</td>
<td>镜像存在入口命令时，覆盖为新的命令</td>
</tr>
<tr>
<td>–expose=[]</td>
<td>指定容器暴露出来的端口或端口范围</td>
</tr>
<tr>
<td>–group-add=[]</td>
<td>运行容器的用户组</td>
</tr>
<tr>
<td>-i, –interactive=true</td>
<td>false</td>
<td>保持标准输入打开，默认否</td>
</tr>
<tr>
<td>–ipc=””</td>
<td>容器IPC命名空间，可以为其他容器或主机</td>
</tr>
<tr>
<td>–ioslation=”default”</td>
<td>容器使用的隔离机制</td>
</tr>
<tr>
<td>–log-driver=”json-file”</td>
<td>指定容器的日志驱动类型，可以为json-file、syslog、journald、gelf、fluentd、awslogs、splunk、etwlogs、gcplogs或none</td>
</tr>
<tr>
<td>–log-opt=[]</td>
<td>传递给日志驱动的选项</td>
</tr>
<tr>
<td>–net=”bridge”</td>
<td>指定容器网络模式，包括bridge、none、其他容器内网络、host的网络或某个现有网络等</td>
</tr>
<tr>
<td>–net-alias=[]</td>
<td>容器在网络中的别名</td>
</tr>
<tr>
<td>-P, –publish-all=true</td>
<td>false</td>
<td>通过NAT机制将容器标记暴露的端口自动映射到本地主机的监时端口</td>
</tr>
<tr>
<td>-p, –publish=[]</td>
<td>指定如何映射到本地主机端口，如 -p 11234-12234:1234-2234</td>
</tr>
<tr>
<td>–pid=host</td>
<td>容器的pid命名空间</td>
</tr>
<tr>
<td>–userns=””</td>
<td>启动userns-remap时配置用户命名空间的模式</td>
</tr>
<tr>
<td>–uts=host</td>
<td>容器的UTS命名空间</td>
</tr>
<tr>
<td>–restart=”no”</td>
<td>容器重启策略，包括no、on-failure[:max-retry]、always、uniess-stopped等</td>
</tr>
<tr>
<td>–rm=true</td>
<td>false</td>
<td>容器退出后是否自动删除，不能跟-d同时使用</td>
</tr>
<tr>
<td>-t, –tty=true</td>
<td>false</td>
<td>是否分配一个伪终端，默认否</td>
</tr>
<tr>
<td>–tmpfs=[]</td>
<td>挂载临时文件系统到容器</td>
</tr>
<tr>
<td>-v</td>
<td>–volume[=[[HOST-DIR:] CONTAINER-DIR[:OPTIONS]]]</td>
<td>挂载主机上的文件卷到容器内</td>
</tr>
<tr>
<td>–volume-driver=””</td>
<td>挂载文件卷的驱动类型</td>
</tr>
<tr>
<td>–volume-from=[]</td>
<td>从其他容器挂载卷</td>
</tr>
<tr>
<td>-w, –workdir=””</td>
<td>容器内的默认工作目录</td>
</tr>
</tbody>
</table>
<ul>
<li>create命令与容器环境和配置相关的选项</li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>–add-host=[]</td>
<td>在容器内添加一个主机名到IP地址的映射关系（通过/etc/hosts文件）</td>
</tr>
<tr>
<td>–device=[]</td>
<td>映射物理机上的设备到容器内</td>
</tr>
<tr>
<td>–dns-search=[]</td>
<td>DNS搜索域</td>
</tr>
<tr>
<td>–dns-opt=[]</td>
<td>自定义的DNS选项</td>
</tr>
<tr>
<td>–dns=[]</td>
<td>自定义的DNS服务器</td>
</tr>
<tr>
<td>-e, –env=[]</td>
<td>指定容器内环境变量</td>
</tr>
<tr>
<td>–env-file=[]</td>
<td>从文件中读取环境变量到容器内</td>
</tr>
<tr>
<td>-h, –hostname=””</td>
<td>指定容器内的主机名</td>
</tr>
<tr>
<td>–ip=””</td>
<td>指定容器的IPv4地址</td>
</tr>
<tr>
<td>–ip6=””</td>
<td>指定容器的IPv6地址</td>
</tr>
<tr>
<td>–link=[<name or="" id="">:alias]</name></td>
<td>链接到其他容器</td>
</tr>
<tr>
<td>–mac-address=””</td>
<td>指定容器的mac地址</td>
</tr>
<tr>
<td>–name=””</td>
<td>指定容器的别名</td>
</tr>
</tbody>
</table>
<ul>
<li>create命令与容器资源限制和安全保护相关的选项</li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>–blkio-weight=10~100</td>
<td>容器读写块设备的I/O性能权重，默认为0</td>
</tr>
<tr>
<td>–blkio-weight-device=[DEVICE_NAME:WEIGHT]</td>
<td>指定各个块设备的I/O性能权重</td>
</tr>
<tr>
<td>–cpu-shares=0</td>
<td>允许容器使用cpu资源的相对权重，默认一个容器能用满一个核的cpu</td>
</tr>
<tr>
<td>–cap-add=[]</td>
<td>增加容器的Linux指定安全能力</td>
</tr>
<tr>
<td>–cap-drop=[]</td>
<td>移除容器的Linux指定安全能力</td>
</tr>
<tr>
<td>–cgroup-parent=””</td>
<td>容器cgroups限制的创建路径</td>
</tr>
<tr>
<td>–cidfile=””</td>
<td>指定容器的进程ID号写到文件</td>
</tr>
<tr>
<td>–cpu-period=0</td>
<td>限制容器在CFS调度器下的CPU占用时间片</td>
</tr>
<tr>
<td>–cpuset-cpus=””</td>
<td>限制容器能使用哪些CPU核心</td>
</tr>
<tr>
<td>–cpuset-mems=””</td>
<td>NUMA架构下使用哪些核心的内存</td>
</tr>
<tr>
<td>–cpu-quota=0</td>
<td>限制容器在CFS调度器下的CPU配额</td>
</tr>
<tr>
<td>–device-read-bps=[]</td>
<td>挂载设备的读吞吐率（以bps为单位）限制</td>
</tr>
<tr>
<td>–device-write-bps=[]</td>
<td>挂载设备的写吞吐率（以bps为单位）限制</td>
</tr>
<tr>
<td>–device-read-iops=[]</td>
<td>挂载设备的读速率（以每秒i/o次数为单位）限制</td>
</tr>
<tr>
<td>–device-write-iops=[]</td>
<td>挂载设备的写速率（以每秒i/o次数为单位）限制</td>
</tr>
<tr>
<td>–kernel-memory=””</td>
<td>限制容器使用内核的内存大小，单位可以是b、k、m或g</td>
</tr>
<tr>
<td>-m, –memory=””</td>
<td>限制容器内应用使用的内存，单位可以是b、k、m或g</td>
</tr>
<tr>
<td>–memory-reservation=””</td>
<td>当系统中内存过低时，容器会强制限制内存到给定值，默认情况下等于内存限制值</td>
</tr>
<tr>
<td>–memory-swap=”LIMIT”</td>
<td>限制容器使用内存和交换区的总大小</td>
</tr>
<tr>
<td>–oom-kill-disable=true</td>
<td>false</td>
<td>内存耗尽时是否杀死容器</td>
</tr>
<tr>
<td>–pids-limit=””</td>
<td>限制容器的pid个数</td>
</tr>
<tr>
<td>–privileged=true</td>
<td>false</td>
<td>是否给容器以最高权限，这意味着容器内应用将不受权限下限制，一般不推荐</td>
</tr>
<tr>
<td>–read-only=true</td>
<td>false</td>
<td>是否让容器内的文件系统只读</td>
</tr>
<tr>
<td>–security-opt=[]</td>
<td>指定一些安全参数，包括权限、安全能力、apparmor等</td>
</tr>
<tr>
<td>–stop-signal=SIGTERM</td>
<td>指定停止容器的系统信号</td>
</tr>
<tr>
<td>–shm-size=””</td>
<td>/dev/shm 的大小</td>
</tr>
<tr>
<td>–sig-proxy=true</td>
<td>false</td>
<td>是否代理收到的信号给应用，默认为true，不能代理SIGCHLD、SIGSTOP和SIGKILL信号</td>
</tr>
<tr>
<td>–memory-swappiness=”0~100”</td>
<td>调整容器的内存交换区参数</td>
</tr>
<tr>
<td>-u, –user=””</td>
<td>指定在容器内执行命令的用户信息</td>
</tr>
<tr>
<td>–ulimit=[]</td>
<td>能过ulimit来限制最大文件数、最大进程数等</td>
</tr>
</tbody>
</table>
<ul>
<li>其他重要选项<ul>
<li>-l, –label=[]：以键值对方式指定容器的标签信息</li>
<li>–label-file=[]：从文件中读取标签信息</li>
</ul>
</li>
</ul>
<h5 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h5><ul>
<li>docker start af8f4f922daf</li>
</ul>
<h5 id="新建并启动容器"><a href="#新建并启动容器" class="headerlink" title="新建并启动容器"></a>新建并启动容器</h5><ul>
<li>docker run ubuntu /bin/echo “Hello World!”</li>
<li>等价于 docker create + docker run</li>
<li>启动容器并进入终端<ul>
<li>docker run -it ubuntu:latest /bin/bash</li>
<li>-t选项让docker分配一个伪终端并绑定到容器的标准输入上</li>
<li>-i选项让容器的标准输入保持打开</li>
<li>exit命令退出容器</li>
<li>exit退出后，容器自动处于退出状态</li>
</ul>
</li>
<li>docker run常见错误码<ul>
<li>125：docker daemon执行出错，不支持的docker命令参数</li>
<li>126：所指定命令无法执行，如权限出错</li>
<li>127：容器内命令无法找到</li>
</ul>
</li>
<li>守护态执行<ul>
<li>docker run <code>-d</code> ubuntu /bin/sh -c “while true; do echo hello world; sleep 1; done”</li>
<li>获取容器的输出信息：docker logs CONTAINER_ID</li>
</ul>
</li>
</ul>
<h3 id="4-2-终止容器"><a href="#4-2-终止容器" class="headerlink" title="4.2 终止容器"></a>4.2 终止容器</h3><ul>
<li>docker stop [-t|–time[=10]] [CONTAINER…]<ul>
<li>首先向容器发送SIGTERM信号，等待一段时间后再发送SIGKILL信号终止容器</li>
</ul>
</li>
<li>docker kill命令会直接发送SIGKILL信号强行终止容器</li>
<li>docker容器中应用终结时，容器也会自动停止</li>
<li>查看所有容器ID<ul>
<li>docker ps -qa</li>
</ul>
</li>
<li>重启终止状态的容器<ul>
<li>docker start [CONTAINER]</li>
</ul>
</li>
<li>重启容器<ul>
<li>docker restart [CONTAINER]</li>
</ul>
</li>
</ul>
<h3 id="4-3-进入容器"><a href="#4-3-进入容器" class="headerlink" title="4.3 进入容器"></a>4.3 进入容器</h3><ul>
<li>使用-d参数，容器启动后进入后台，无法查看和操作，若需进入容器操作，可使用官方的attach、exec命令或三方nsenter工具。</li>
</ul>
<h5 id="attach命令"><a href="#attach命令" class="headerlink" title="attach命令"></a>attach命令</h5><ul>
<li>docker attach [–detach-keys[=[]]] [–no-stdin] [–sig-proxy[=true]] CONTAINER<ul>
<li>docker attach CONTAINER</li>
</ul>
</li>
<li>–detach-keys[=[]]：退出attach模式的快捷键，默认CTRL-p、CTRL-q。</li>
<li>–no-stdin=true|false：是否关闭标准输入，默认打开。</li>
<li>–sig-proxy=true|false：是否代理收到的系统信号给应用进程，默认true。</li>
<li>缺点：多个窗口同时使用attach连到同一容器，所有窗口同步显示。</li>
</ul>
<h5 id="exec命令"><a href="#exec命令" class="headerlink" title="exec命令"></a><code>exec命令</code></h5><ul>
<li>docker exec [-d|–detach] [–detach-keys[=[]]] [-i|–interactive] [–privileged] [-t|–tty] [-u|–user[=USER]] CONTAINER COMMAND [ARG…]<ul>
<li>docker exec -it CONTAINER_NAME /bin/bash</li>
<li>it参数保持标准输入打开，并分配一个伪终端</li>
</ul>
</li>
<li>-i, –interactive=true|false：打开标准输入接受用户输入命令，默认false</li>
<li>–privileged=true|false：是否给执行命令以最高权限，默认false</li>
<li>-t, –tty=true|false：分配伪终端，默认false</li>
<li>-u, –user=””：执行命令的用户名或ID</li>
</ul>
<h5 id="nsenter工具"><a href="#nsenter工具" class="headerlink" title="nsenter工具"></a>nsenter工具</h5><ul>
<li>略</li>
</ul>
<h3 id="4-4-删除容器"><a href="#4-4-删除容器" class="headerlink" title="4.4 删除容器"></a>4.4 删除容器</h3><ul>
<li>docker rm [-f|–force] [-l|–link] [-v|–volumes] CONTAINER [CONTAINER…]<ul>
<li>-f, –force=false：是否强行终止并删除运行中的容器</li>
<li>-l, –link=false：删除容器连接，但保留容器</li>
<li>-v, –volumes=false：删除容器挂载的数据卷</li>
</ul>
</li>
<li>docker rm 默认只删除终止或退出状态容器</li>
<li>docker rm -f 直接删除运行中容器，会先发送SIGKILL信号给容器，终止应用，之后强行删除。</li>
</ul>
<h3 id="4-5-导入和导出容器"><a href="#4-5-导入和导出容器" class="headerlink" title="4.5 导入和导出容器"></a>4.5 导入和导出容器</h3><h5 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h5><ul>
<li>导出已创建好的容器到文件，不管容器是否处于运行状态</li>
<li>docker export [-o|–output[=””]] CONTAINER<ul>
<li>-o 指定导出的tar文件，也可通过重定向来实现<h5 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h5></li>
</ul>
</li>
<li>导出的文件通过docker import命令导入变成镜像</li>
<li>docker import [-c|–change[=[]]] [-m|–message[=MESSAGE]] file|URL|-[REPOSITORY[:TAG]]<ul>
<li>docker import XXX.tar - test/ubuntu:v1.0</li>
</ul>
</li>
<li>-c, –change=[]：在导入同时执行对容器进行修改的Dockerfile指令</li>
<li>docker load（镜像存储文件） 与 docker import（容器快照） 相似<ul>
<li>容器快照将丢弃所有历史记录和元数据信息；镜像存储文件将保存完整记录。从容器快照文件导入时可重新指定标签等元数据信息。</li>
</ul>
</li>
</ul>
<h3 id="4-6-本章小结"><a href="#4-6-本章小结" class="headerlink" title="4.6 本章小结"></a>4.6 本章小结</h3><ul>
<li>生产环境，使用容器时在一组容器前引入HA机制，如HAProxy工具来代理容器访问，这样容器故障时，可快速切换到功能正常的容器。</li>
<li>指定合适的容器重启策略，来自动重启退出的容器。</li>
</ul>
<hr>
<h1 id="第5章-访问docker仓库"><a href="#第5章-访问docker仓库" class="headerlink" title="第5章 访问docker仓库"></a>第5章 访问docker仓库</h1><ul>
<li>仓库：存放镜像</li>
<li>注册服务器：存放仓库的具体服务器</li>
<li>1个注册服务器有多个仓库，1个仓库有多个镜像</li>
<li>仓库地址mydocker.com/ubuntu，mydocker.com为注册服务器地址，ubuntu为仓库名</li>
</ul>
<h3 id="5-1-docker-hub公共镜像市场"><a href="#5-1-docker-hub公共镜像市场" class="headerlink" title="5.1 docker hub公共镜像市场"></a>5.1 docker hub公共镜像市场</h3><h5 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h5><ul>
<li>docker login</li>
<li>注册成功后本地生成 .dockercfg 保存用户认证信息。</li>
<li>登录成功后可上传镜像</li>
</ul>
<h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h5><ul>
<li>docker search</li>
<li>docker pull</li>
</ul>
<h5 id="自动创建"><a href="#自动创建" class="headerlink" title="自动创建"></a>自动创建</h5><ul>
<li>镜像内程序需频繁升级，可通过Docker Hub指定跟踪一个目标网站，一旦项目发生新的提交，则自动创建。</li>
<li>自动创建步骤<ul>
<li>登录 Docker Hub ，在目标网站中连接账户到 Docker Hub</li>
<li>在 Docker Hub 中配置一个“自动创建”</li>
<li>选取一个目标网站中的项目（需含Dockerfile）和分支</li>
<li>指定Dockerfile位置，并提交创建</li>
</ul>
</li>
</ul>
<h3 id="5-2-时速云镜像市场"><a href="#5-2-时速云镜像市场" class="headerlink" title="5.2 时速云镜像市场"></a>5.2 时速云镜像市场</h3><ul>
<li>略</li>
</ul>
<h3 id="5-3-搭建本地私有仓库"><a href="#5-3-搭建本地私有仓库" class="headerlink" title="5.3 搭建本地私有仓库"></a>5.3 搭建本地私有仓库</h3><h5 id="使用registry镜像创建私有仓库"><a href="#使用registry镜像创建私有仓库" class="headerlink" title="使用registry镜像创建私有仓库"></a>使用registry镜像创建私有仓库</h5><ul>
<li>通过官方registry镜像来搭建本地私有仓库<ul>
<li>docker run -d -p 5000:5000 registry</li>
</ul>
</li>
<li>默认仓库创建在容器的/tmp/registry下。存放到某目录<ul>
<li>docker run -d -p 5000:5000 -v /mypath/registry:/tmp/registry / registry</li>
</ul>
</li>
</ul>
<h5 id="管理私有仓库"><a href="#管理私有仓库" class="headerlink" title="管理私有仓库"></a>管理私有仓库</h5><ul>
<li>在远程机器a(10.0.2.2:5000)上搭建私有仓库</li>
<li>在本地机器上，对某镜像打tag<ul>
<li>docker tag ubuntu:14.04 10.0.2.2:5000/test</li>
<li>docker tag IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]</li>
</ul>
</li>
<li>上传镜像<ul>
<li>docker push 10.0.2.2:5000/test</li>
</ul>
</li>
<li>下载镜像<ul>
<li>docker pull 10.0.2.2:5000/test</li>
</ul>
</li>
</ul>
<hr>
<h1 id="第6章-docker数据管理"><a href="#第6章-docker数据管理" class="headerlink" title="第6章 docker数据管理"></a>第6章 docker数据管理</h1><ul>
<li>容器管理数据方式<ul>
<li>数据卷：容器内数据直接映射到本地主机环境</li>
<li>数据卷容器：使用特定容器维护数据卷</li>
</ul>
</li>
</ul>
<h3 id="6-1-数据卷"><a href="#6-1-数据卷" class="headerlink" title="6.1 数据卷"></a>6.1 数据卷</h3><ul>
<li>将主机操作系统目录映射进容器，类似linux中的mount操作。</li>
<li>优势<ul>
<li>容器间共享和重用、数据传递</li>
<li>对数据卷内数据修改会立马生效</li>
<li>对数据卷更新不会影响镜像，解耦应用与数据</li>
<li>卷一直存在，直到没有容器使用，可安全缷载</li>
</ul>
</li>
</ul>
<h5 id="容器内创建数据卷"><a href="#容器内创建数据卷" class="headerlink" title="容器内创建数据卷"></a>容器内创建数据卷</h5><ul>
<li>使用training/webapp镜像创建web容器，并创建数据卷挂载到容器的/webapp目录：<ul>
<li>docker run -d -p –name web -v /webapp training/webapp python app.py</li>
</ul>
</li>
</ul>
<h5 id="挂载一个主机目录作为数据卷"><a href="#挂载一个主机目录作为数据卷" class="headerlink" title="挂载一个主机目录作为数据卷"></a>挂载一个主机目录作为数据卷</h5><ul>
<li>加载主机的/src/webapp到容器的/opt/webapp<ul>
<li>docker run -d -p –name web -v /src/webapp:/opt/webapp training/webapp python app.py</li>
</ul>
</li>
<li>docker挂载数据卷的默认权限为rw，可通过ro指定为只读<ul>
<li>docker run -d -p –name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py</li>
</ul>
</li>
</ul>
<h5 id="挂载一个本地主机文件作为数据卷-不推荐"><a href="#挂载一个本地主机文件作为数据卷-不推荐" class="headerlink" title="挂载一个本地主机文件作为数据卷(不推荐)"></a>挂载一个本地主机文件作为数据卷(不推荐)</h5><ul>
<li>docker run –rm -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash</li>
</ul>
<h3 id="6-2-数据卷容器"><a href="#6-2-数据卷容器" class="headerlink" title="6.2 数据卷容器"></a>6.2 数据卷容器</h3><ul>
<li>多容器间共享持续更新的数据，使用数据卷容器较方便。其也是容器，专用来提供数据卷供其他容器挂载。</li>
<li>创建数据卷容器dbdata，并在其中创建一个数据卷挂载到/dbdata<ul>
<li>docker run -it -v /dbdata –name dbdata ubuntu</li>
<li>新建了一个名为dbdata的容器，容器中有个目录/dbdata，创建了数据卷挂载到容器dbdata的/dbdata目录下。</li>
</ul>
</li>
<li>其他容器(如db1、db2)挂载容器dbdata中的数据卷<ul>
<li>docker run -it –volumes-from dbdata –name db1 ubuntu</li>
<li>docker run -it –volumes-from dbdata –name db2 ubuntu</li>
<li>此时db1、db2都挂载同一个数据卷到相同的/dbdata目录。三个容器任何一方在该目录下写，其他容器均可见。</li>
</ul>
</li>
<li>多次使用–volumes-from从多个容器挂载多个数据卷。还可从其他已经挂载了容器卷的容器来挂载数据卷<ul>
<li>docker run -d –name db3 –volumes-from db1 training/postgres</li>
</ul>
</li>
<li>使用–volumes-from所挂载数据卷的容器自身并不需要保持在运行状态。</li>
<li>如删除挂载的容器，数据卷不会自动删除。如需删除数据卷，必须在删除最后一个还挂载着它的容器时显式使用docker rm -v命令来指定同时删除关联的容器。</li>
</ul>
<h3 id="6-3-利用数据卷容器来迁移数据"><a href="#6-3-利用数据卷容器来迁移数据" class="headerlink" title="6.3 利用数据卷容器来迁移数据"></a>6.3 利用数据卷容器来迁移数据</h3><ul>
<li>可利用数据卷容器对其中的数据进行备份、恢复，以实现数据迁移。</li>
</ul>
<h5 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h5><ul>
<li>备份dbdata数据卷容器内的数据卷<ul>
<li>docker run –volumes-from dbdata -v $(pwd):/backup –name worker ubuntu tar cvf /backup/backup.tar /dbdata</li>
<li>首先用ubuntu镜像创建了容器worker</li>
<li>使用 –volumes-from dbdata 让worker容器挂载dbdata容器的数据卷（即dbdata数据卷）</li>
<li>使用 -v $(pwd):/backup 来挂载本地的当前目录到worker容器的/backup目录</li>
<li>worker启动后，使用 tar cvf /backup/backup.tar /dbdata 将/dbdata下内容备份为容器内的 /backup/backup.tar，即宿主机当前目录下的backup.tar</li>
</ul>
</li>
</ul>
<h5 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h5><ul>
<li>创建一个带数据卷的容器dbdata2<ul>
<li>docker run -v /dbdata –name dbdata2 ubuntu /bin/bash</li>
</ul>
</li>
<li>创建另一个新容器，挂载dbdata2容器，并使用untar解压备份文件到所挂载的容器卷中<ul>
<li>docker run –volumes-from dbdata2 -v $(pwd):/backup busybox tar xvf /backup/backup.tar</li>
</ul>
</li>
</ul>
<hr>
<h1 id="第7章-端口映射与容器互联"><a href="#第7章-端口映射与容器互联" class="headerlink" title="第7章 端口映射与容器互联"></a>第7章 端口映射与容器互联</h1><ul>
<li>多容器间协作<ul>
<li>网络</li>
<li><code>映射容器内应用的服务端口到本地宿主主机</code></li>
<li><code>互联机制实现多个容器间通过容器名来快速访问</code></li>
</ul>
</li>
</ul>
<h3 id="7-1-端口映射实现访问容器"><a href="#7-1-端口映射实现访问容器" class="headerlink" title="7.1 端口映射实现访问容器"></a>7.1 端口映射实现访问容器</h3><h5 id="从外部访问容器应用"><a href="#从外部访问容器应用" class="headerlink" title="从外部访问容器应用"></a>从外部访问容器应用</h5><ul>
<li>默认情况，容器外无法通过网络访问容器内应用与服务。</li>
<li>-P 随机映射一个49000~49900端口到内部容器开放的网络端口<ul>
<li>docker run -d -P training/webapp python app.py</li>
<li>查看应用日志：docker logs -f CONTAINER_NAME</li>
</ul>
</li>
<li>-p 指定映射端口，一个指定端口仅可绑定一个容器<ul>
<li>IP:HostPort:ContainerPort</li>
<li>IP::ContainerPort</li>
<li>HostPort:ContainerPort</li>
</ul>
</li>
</ul>
<h5 id="映射所有接口地址"><a href="#映射所有接口地址" class="headerlink" title="映射所有接口地址"></a>映射所有接口地址</h5><ul>
<li>HostPort:ContainerPort将本地5000端口映射到容器5000端口<ul>
<li>docker run -d -p 5000:5000 training/webapp python app.py</li>
<li>默认绑定本地所有接口上的所有地址</li>
</ul>
</li>
<li>docker run -d -p 5000:5000 -p 3000:80 training/webapp python app.py</li>
</ul>
<h5 id="映射到指定地址的指定端口"><a href="#映射到指定地址的指定端口" class="headerlink" title="映射到指定地址的指定端口"></a>映射到指定地址的指定端口</h5><ul>
<li>IP:HostPort:ContainerPort指定映射使用一个特定地址<ul>
<li>docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</li>
</ul>
</li>
</ul>
<h5 id="映射到指定地址的任意端口"><a href="#映射到指定地址的任意端口" class="headerlink" title="映射到指定地址的任意端口"></a>映射到指定地址的任意端口</h5><ul>
<li>IP::ContainerPort绑定localhost任意端口到容器的5000端口，本地主机会自动分配一个端口<ul>
<li>docker run -d -p 127.0.0.1::5000 training/webapp python app.py</li>
</ul>
</li>
<li>使用udp指定udp端口<ul>
<li>docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</li>
</ul>
</li>
</ul>
<h5 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h5><ul>
<li>docker port CONTAINER 5000</li>
<li>容器有自己的内部网络和ip，查看容器具体信息<ul>
<li>docker inspect CONTAINER_ID</li>
</ul>
</li>
</ul>
<h3 id="7-2-互联机制实现便捷互动"><a href="#7-2-互联机制实现便捷互动" class="headerlink" title="7.2 互联机制实现便捷互动"></a>7.2 互联机制实现便捷互动</h3><ul>
<li>容器互联：多容器中应用快速交互。容器间建立连接，通过容器名快速访问，无需指定具体IP。</li>
</ul>
<h5 id="自定义容器命名"><a href="#自定义容器命名" class="headerlink" title="自定义容器命名"></a>自定义容器命名</h5><ul>
<li>创建容器时会有默认名称，但自定义名称：<ul>
<li>好记</li>
<li>使用方便：连接其他容器时（即便重启）可使用容器名</li>
</ul>
</li>
<li>docker run -d -P <code>--name web</code> training/webapp python app.py</li>
<li>查看容器名<ul>
<li>docker inspect -f “{ { .Name } }” CONTAINER_ID</li>
</ul>
</li>
<li>容器名唯一，如已命名web容器，当再次使用web名称时，需先docker rm删除之前的同名容器</li>
<li>容器终止时立即删除容器<ul>
<li>docker run … <code>--rm</code> …</li>
<li>–rm与-d不可同时使用</li>
</ul>
</li>
</ul>
<h5 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h5><ul>
<li>现有容器db：docker run -d –name db training/postgres</li>
<li>创建新容器web，并连接到db容器<ul>
<li>docker run -d -P –name web <code>--link db:db</code> training/webapp python app.py</li>
</ul>
</li>
<li>–link格式：–link name:alias<ul>
<li>name：要连接的容器</li>
<li>alias：这个连接的别名</li>
</ul>
</li>
<li>此时存在2个容器：db，web。容器db的2个name：db、web/db。</li>
<li>docker 相当于在2个互联的容器间创建虚拟通道，无需映射容器端口到宿主机。启动db时并没有使用-p，避免暴露数据库服务端口到外部网络。</li>
<li>docker公开容器连接信息方式<ul>
<li>更新环境变量</li>
<li>更新 /etc/hosts 文件</li>
</ul>
</li>
<li>查看web容器环境变量<ul>
<li>docker run –rm –name web2 –link db:db training/webapp <code>env</code></li>
<li>环境变量中以 DB_开头（即以大写的连接别名开头）的环境变量为 web容器连接db容器使用的。</li>
</ul>
</li>
<li>除环境变量，docker还添加host信息到父容器（web）的 /etc/hosts 文件<ul>
<li>docker run -t -i –rm –link db:db training/webapp /bin/bash</li>
<li>进入父容器后执行：cat /etc/hosts</li>
<li>由hosts文件可知：第1个为web容器自己，第2个为db容器的ip和主机名。</li>
</ul>
</li>
<li>可连接多个子容器到父容器，比如可连接多个web到同一个db容器。</li>
</ul>
<h3 id="7-3-本章小结"><a href="#7-3-本章小结" class="headerlink" title="7.3 本章小结"></a>7.3 本章小结</h3><ul>
<li>生产环境更复杂，包括跨主机或跨数据中心通信，需引入额外机制，如SDN(软件定义网络)、NFV(网络功能虚拟化)</li>
<li>docker使用libnetwork实现跨主机通信</li>
</ul>
<hr>
<h1 id="第8章-使用dockerfile创建镜像"><a href="#第8章-使用dockerfile创建镜像" class="headerlink" title="第8章 使用dockerfile创建镜像"></a>第8章 使用dockerfile创建镜像</h1><h3 id="8-1-基本结构"><a href="#8-1-基本结构" class="headerlink" title="8.1 基本结构"></a>8.1 基本结构</h3><ol>
<li>基础镜像信息</li>
<li>维护者信息</li>
<li>镜像操作指令</li>
<li>容器启动时执行指令</li>
</ol>
<h3 id="8-2-指令说明"><a href="#8-2-指令说明" class="headerlink" title="8.2 指令说明"></a>8.2 指令说明</h3><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>FROM</td>
<td>指定所创建的镜像的基础镜像</td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>指定维护者信息</td>
</tr>
<tr>
<td>RUN</td>
<td>运行命令</td>
</tr>
<tr>
<td>CMD</td>
<td>指定启动容器时默认执行的命令</td>
</tr>
<tr>
<td>LABEL</td>
<td>指定生成镜像的元数据标签信息</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>声明镜像内服务所监听的端口</td>
</tr>
<tr>
<td>ENV</td>
<td>指定环境变量</td>
</tr>
<tr>
<td>ADD</td>
<td>复制指定的<src>路径下的内容到容器的<dest>路径下，<src>可以为URL；如果为tar文件，会自动解压到<dest>路径下</dest></src></dest></src></td>
</tr>
<tr>
<td>COPY</td>
<td>复制本地主机的<src>路径下的内容到镜像中的<dest>路径下；一般情况下推荐使用COPY，而不是ADD</dest></src></td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>指定镜像的默认入口</td>
</tr>
<tr>
<td>VOLUME</td>
<td>创建数据卷挂载点</td>
</tr>
<tr>
<td>USER</td>
<td>指定运行容器时的用户名或UID</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>配置工作目录</td>
</tr>
<tr>
<td>ARG</td>
<td>指定镜像内使用的参数（例如版本号信息等）</td>
</tr>
<tr>
<td>ONBUILD</td>
<td>配置当所创建的镜像作为其他镜像的基础镜像时，所执行的创建操作指令</td>
</tr>
<tr>
<td>STOPSIGNAL</td>
<td>容器退出的信号值</td>
</tr>
<tr>
<td>HEALTHCHECK</td>
<td>如何进行健康检查</td>
</tr>
<tr>
<td>SHELL</td>
<td>指定使用shell时的默认shell类型</td>
</tr>
</tbody>
</table>
<h5 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h5><ul>
<li>所创建镜像的基础镜像</li>
<li>格式： FROM<image>、FROM<image>:<tag>、FROM<image>@<digest></digest></image></tag></image></image></li>
<li>dockerfile第一条指令必为FROM。同一dockerfile中创建多个镜像，可使用多个FROM（每个镜像一次）</li>
</ul>
<h5 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h5><ul>
<li>指定维护者信息</li>
<li>格式：MAINTAINER<name><ul>
<li>MAINTAINER image_creator@docker.com</li>
</ul>
</name></li>
<li>被写入生成镜像的Author属性域中。</li>
</ul>
<h5 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h5><ul>
<li>运行指定命令</li>
<li>格式：RUN<command>、RUN [“executable”,”param1”,”param2”]<ul>
<li>RUN [“executable”,”param1”,”param2”]会被解析为Json数组，必须用双引号；使用exec执行，不会启动shell</li>
<li>RUN<command>默认在shell中运行，即 /bin/sh -c</li>
</ul>
</li>
<li>每条Run指令在当前镜像基础上执行，并提交为新镜像</li>
</ul>
<h5 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h5><ul>
<li>启动容器时默认执行的命令</li>
<li>格式<ul>
<li>CMD [“executable”,”param1”,”param2”]：使用exec执行，推荐使用</li>
<li>CMD command param1 param2：在/bin/sh中执行，提供给需要交互的应用</li>
<li>CMD [“param1”,”param2”]：提供给ENTRYPOINT的默认参数</li>
</ul>
</li>
<li>每个dockerfile只能有一条CMD，若有多条只有最后一条生效</li>
<li>用户启动容器时手动指定了运行命令（run参数），则覆盖CMD。</li>
</ul>
<h5 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h5><ul>
<li>指定生成镜像的元数据标签信息</li>
<li><p>格式：LABEL &lt; key&gt;=&lt; value&gt; &lt; key&gt;=&lt; value&gt; &lt; key&gt;=&lt; value&gt;…</p>
<pre><code>LABLE version=&quot;1.0&quot;
LABEL description=&quot;XXX&quot;
</code></pre></li>
</ul>
<h5 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h5><ul>
<li>镜像内服务所监听端口</li>
<li>格式：EXPOST <port> [<port>…]<ul>
<li>EXPOST 22 80 8443</li>
</ul>
</port></port></li>
<li>仅声明，并不会自动完成端口映射</li>
<li>启动容器时需使用 -P，docker主机会自动分配宿主机的临时端口转发到指定端口；-p可具体指定宿主机的哪个本地端口映射。    </li>
</ul>
<h5 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h5><ul>
<li>指定环境变量，镜像生成过程中会被RUN指令使用，在镜像启动的容器中也会存在。</li>
<li><p>格式：ENV &lt; key&gt; &lt; value&gt;、ENV &lt; key&gt;=&lt; value&gt;…</p>
<pre><code>ENV PG_MAJOR 9.3
RUN XXX
ENV PATH /usr/local/XXX:$PATH
</code></pre></li>
<li>运行时可被覆盖，如docker run –env XXX build_image</li>
</ul>
<h5 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h5><ul>
<li>复制<src>路径下内容到容器的<dest></dest></src></li>
<li>格式：ADD <src> <dest><ul>
<li>src可以是dockerfile所在目录的一个相对路径；也可为URL；或tar文件（tar文件会自动解压到dest下）</li>
<li>dest可为镜像内绝对路径，或相对于工作目录（WORKDIR）的相对路径。</li>
<li>ADD *.c /code</li>
</ul>
</dest></src></li>
</ul>
<h5 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h5><ul>
<li>复制本地主机<src>(为dockerfile所在目录的相对路径、文件或目录)下内容到镜像中的<dest>下。目标路径不存在时自动创建</dest></src></li>
<li>格式：COPY <src> <dest></dest></src></li>
<li>使用本地目录为源目录时,推荐使用COPY</li>
</ul>
<h5 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h5><ul>
<li>指定镜像的默认入口命令，在启动容器时作为根命令执行，所有传入值作为该命令的参数。</li>
<li>格式<ul>
<li>ENTRYPOINT [“executable”,”param1”,”param2”]：exec调用执行</li>
<li>ENTRYPOINT command param1 param2：shell中执行</li>
</ul>
</li>
<li>CMD指令的指定值将作为根命令参数</li>
<li>每个dockerfile中只能有一个ENTRYPOINT，指定多个时仅最后一个生效。</li>
<li>运行时可被–entrypoint覆盖</li>
</ul>
<h5 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h5><ul>
<li>创建数据卷挂载点</li>
<li>格式：VOLUME [“/data”]</li>
<li>可从本地主机或其他容器挂载数据卷，一般用来存放数据库和需要保存的数据</li>
</ul>
<h5 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h5><ul>
<li>指定运行容器时的用户名或UID，后续RUN指令也会使用此用户。</li>
<li>格式：USER daemon</li>
<li>服务无需管理员权限时，可通过此命令指定运行用户，并可在之前创建所需用户<ul>
<li>RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</li>
</ul>
</li>
<li>要临时获取管理员权限可使用gosu或sudo</li>
</ul>
<h5 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h5><ul>
<li>为后续的RUN、CMD、ENTRYPOINT指令配置工作目录。可多个WORKDIR，后续命令如为相对路径，则会基于之前指定的WORKDIR。</li>
<li><p>格式：WORKDIR /path/XXX</p>
<pre><code>WORKDIR /a
WORKDIR b
WORKDIR c
</code></pre><ul>
<li>则最终路径为/a/b/c</li>
</ul>
</li>
</ul>
<h5 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h5><ul>
<li>指定镜像内使用的参数，这些参数在执行docker build命令时才以–build-arg&lt; varname&gt;=&lt; value&gt;格式传入。</li>
<li>格式：ARG&lt; name&gt;[=&lt; default value&gt;]</li>
<li>可用 docker build –build-arg&lt; name&gt;=&lt; value&gt; 来指定参数值。</li>
</ul>
<h5 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h5><ul>
<li>当创建的镜像作为其他镜像的基础镜像时，所执行的创建操作指令。</li>
<li>格式：ONBUILD [INSTRUCTION]</li>
<li><p>如image-A镜像的dockerfile包含</p>
<pre><code>ONBUILD ADD . /app/src
ONBUILD RUN /usr/local/bin/python-build --dir /app/src
</code></pre><ul>
<li>则基于image-A创建新镜像时，新dockerfile中使用FROM image-A，会自动执行如上ONBUILD指令。</li>
</ul>
</li>
<li><p>使用ONBUILD指令的镜像，推荐在标签中注册，如ruby:1.9-onbuild</p>
</li>
</ul>
<h5 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h5><ul>
<li>指定所创建镜像启动的容器，接收退出的信号值</li>
<li>格式：STOPSIGNAL signal</li>
</ul>
<h5 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h5><ul>
<li>配置所启动容器如何进行健康检查</li>
<li>格式<ul>
<li>HEALTHCHECK [OPTIONS] CMD command：根据所执行命令返回值是否为0来判断</li>
<li>HEALTHCHECK NONE：禁止基础镜像中的健康检查</li>
</ul>
</li>
<li>OPTION支持<ul>
<li>–interval=DURATION(默认30s)：多久检查1次</li>
<li>–timeout=DURATION(默认30s)：每次检查等待结果的超时</li>
<li>–retries=N(默认3)：如失败，重试几次才确定失败</li>
</ul>
</li>
</ul>
<h5 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h5><ul>
<li>指定其他命令使用shell时的默认shell类型。</li>
<li>格式：SHELL [“executable”,”parameters”]<ul>
<li>默认：[“/bin/bash”,”-c”]</li>
</ul>
</li>
</ul>
<h3 id="8-3-创建镜像"><a href="#8-3-创建镜像" class="headerlink" title="8.3 创建镜像"></a>8.3 创建镜像</h3><ul>
<li>编写完dockerfile后通过 <code>docker build</code> 来创建镜像。</li>
<li>指定dockerfile路径为/tmp/docker_builder/，且生成镜像标签为build_repo/first_image<ul>
<li>docker build -t build_repo/first_image /tmp/docker_builder/</li>
</ul>
</li>
<li>一般建议放置dockerfile的目录为空目录。docker build将读取指定路径下的dockerfile，并将此路径下所有内容发送给docker服务端。</li>
</ul>
<h3 id="8-4-使用-dockerignore文件"><a href="#8-4-使用-dockerignore文件" class="headerlink" title="8.4 使用.dockerignore文件"></a>8.4 使用.dockerignore文件</h3><ul>
<li>使用.dockerignore来让docker忽略匹配模式路径下的目录和文件。</li>
</ul>
<h3 id="8-5-最佳实践"><a href="#8-5-最佳实践" class="headerlink" title="8.5 最佳实践"></a>8.5 最佳实践</h3><ol>
<li>精减镜像用途：避免大而复杂、多功能的镜像</li>
<li>选用合适的基础镜像：大镜像太臃肿，推荐小巧的debian镜像</li>
<li>提供足够清晰的命令注释和维护者信息：dockerfile文件清晰</li>
<li>正确使用版本号：使用明确版本号而不是latest</li>
<li>减少镜像层数：尽量合并指令（多个RUN合并为一条）可减少层数</li>
<li>及时删除临时文件和缓存文件：执行apt-get后/var/cache/apt下会缓存安装包</li>
<li>提高生成速度：合理用缓存，减少内容目录下文件；或使用.dockerignore</li>
<li>调整合理的指令顺序：开启缓存时，内容不变的指令尽量放前面，可尽量复用</li>
<li>减少外部源的干扰：使用外部资源需指定持久地址并带有版本信息</li>
</ol>
<hr>
<h1 id="第9章-操作系统"><a href="#第9章-操作系统" class="headerlink" title="第9章 操作系统"></a>第9章 操作系统</h1><h3 id="9-1-BusyBox"><a href="#9-1-BusyBox" class="headerlink" title="9.1 BusyBox"></a>9.1 BusyBox</h3><ul>
<li>集成常用linux指令，只有几M大小（2M）。</li>
<li>docker pull busybox:latest</li>
<li>docker run -it busybox</li>
</ul>
<h3 id="9-2-Alpine"><a href="#9-2-Alpine" class="headerlink" title="9.2 Alpine"></a>9.2 Alpine</h3><ul>
<li>面向安全的轻型linux发行版</li>
<li>体积小：5M左右</li>
<li>采用了 musl libc 和 busybox</li>
</ul>
<h5 id="使用官方镜像"><a href="#使用官方镜像" class="headerlink" title="使用官方镜像"></a>使用官方镜像</h5><ul>
<li>docker run alpine echo ‘123’</li>
</ul>
<h5 id="迁移至Alpine基础镜像"><a href="#迁移至Alpine基础镜像" class="headerlink" title="迁移至Alpine基础镜像"></a>迁移至Alpine基础镜像</h5><ul>
<li>大部分docker官方镜像已支持alpine作为基础镜像，很容易进行迁移。<ul>
<li>ubuntu/debian &gt; alpine</li>
<li>python:2.7 &gt; python:2.7-alpine</li>
<li>ruby:2.3 &gt; ruby:2.3-alpine</li>
</ul>
</li>
<li>使用alpine替换ubuntu作基础镜像，需使用apk替换apt工具安装软件。<ul>
<li>apk add –no-cache <package></package></li>
</ul>
</li>
</ul>
<h3 id="9-3-Debian-Ubuntu"><a href="#9-3-Debian-Ubuntu" class="headerlink" title="9.3 Debian/Ubuntu"></a>9.3 Debian/Ubuntu</h3><ul>
<li>docker清除了ubuntu的apt仓库信息<ul>
<li>apt-get update</li>
<li>apt-get install XXX</li>
</ul>
</li>
</ul>
<h3 id="9-4-CentOS-Fedora"><a href="#9-4-CentOS-Fedora" class="headerlink" title="9.4 CentOS/Fedora"></a>9.4 CentOS/Fedora</h3><h3 id="9-5-本章小结"><a href="#9-5-本章小结" class="headerlink" title="9.5 本章小结"></a>9.5 本章小结</h3><ul>
<li>出于安全考虑，几乎所有官方镜像均无SSH服务，无法使用用户名、密码直接登录。</li>
</ul>
<hr>
<h1 id="第10章-为镜像添加SSH服务"><a href="#第10章-为镜像添加SSH服务" class="headerlink" title="第10章 为镜像添加SSH服务"></a>第10章 为镜像添加SSH服务</h1><ul>
<li>使用attach、exec可进入容器内进行操作，但无法远程操作容器。远程需SSH</li>
</ul>
<h3 id="10-1-基于commit命令创建"><a href="#10-1-基于commit命令创建" class="headerlink" title="10.1 基于commit命令创建"></a>10.1 基于commit命令创建</h3><ul>
<li>基于容器创建镜像：docker commit CONTAINER [REPOSITORY[:TAG]]</li>
</ul>
<h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><ul>
<li>docker run -it ubuntu:14.04 /bin/bash</li>
<li>进入容器后执行命令：apt-get update</li>
</ul>
<h5 id="安装和配置SSH服务"><a href="#安装和配置SSH服务" class="headerlink" title="安装和配置SSH服务"></a>安装和配置SSH服务</h5><ul>
<li>容器内执行命令：apt-get install openssh-server -y<ul>
<li>/var/run/sshd 必须存在，不存在则手动创建。</li>
</ul>
</li>
<li>容器内启动SSH服务<ul>
<li>mkdir -p /var/run/sshd</li>
<li>/usr/sbin/sshd -D &amp;</li>
</ul>
</li>
<li>查看容器的22端口（SSH服务默认监听的端口）<ul>
<li>netstat -tunlp</li>
</ul>
</li>
<li>修改SSH服务的安全登录配置，取消 pam 登录限制<ul>
<li>sed -ri ‘s/session required pam_loginuid.so/#session required pam_loginuid.so/g’ /etc/pam.d/sshd</li>
</ul>
</li>
<li>root用户目录下创建.ssh目录，复制需要登录的公钥信息（一般为本地主机用户目录下的.ssh/id_rsa.pub文件，可由ssh-keygen -t rsa命令生成）到authorized_keys文件中<ul>
<li>mkdir root/.ssh</li>
<li>vi /root/.ssh/authorized_keys</li>
</ul>
</li>
<li><p>创建自动启动SSH服务的可执行文件run.sh，并添加可执行权限</p>
<ul>
<li>vi /run.sh</li>
<li>chmod -x run.sh</li>
<li><p>run.sh内容如下</p>
<pre><code>#!/bin/bash
/usr/sbin/sshd -D
</code></pre></li>
</ul>
</li>
<li>退出容器<ul>
<li>exit</li>
</ul>
</li>
</ul>
<h5 id="保存镜像"><a href="#保存镜像" class="headerlink" title="保存镜像"></a>保存镜像</h5><ul>
<li>将所退出的容器用docker commit保存为一个新的sshd:ubuntu镜像<ul>
<li>docker commit fc1XXXX sshd:ubuntu</li>
</ul>
</li>
</ul>
<h5 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h5><ul>
<li>启动容器，添加端口映射10022&gt;22。10022为宿主主机端口，22为容器的SSH服务监听端口<ul>
<li>docker run -p 10022:22 -d sshd:ubuntu /run.sh</li>
</ul>
</li>
<li>其他主机上使用ssh访问10022端口来登录容器<ul>
<li>ssh 192.168.1.200 -p 10022</li>
</ul>
</li>
</ul>
<h3 id="10-2-使用dockerfile创建"><a href="#10-2-使用dockerfile创建" class="headerlink" title="10.2 使用dockerfile创建"></a>10.2 使用dockerfile创建</h3><h5 id="创建工作目录"><a href="#创建工作目录" class="headerlink" title="创建工作目录"></a>创建工作目录</h5><ul>
<li>创建sshd_ubuntu工作目录<ul>
<li>mkdir sshd_ubuntu</li>
</ul>
</li>
<li>创建dockerfile和run.sh<ul>
<li>cd sshd_ubuntu</li>
<li>touch Dockerfile run.sh</li>
</ul>
</li>
</ul>
<h5 id="编写-run-sh-脚本和-authorized-keys-文件"><a href="#编写-run-sh-脚本和-authorized-keys-文件" class="headerlink" title="编写 run.sh 脚本和 authorized_keys 文件"></a>编写 run.sh 脚本和 authorized_keys 文件</h5><ul>
<li><p>run.sh内容</p>
<pre><code>#!/bin/bash
/usr/sbin/sshd -D
</code></pre></li>
<li>宿主机上生成SSH密钥对，创建authorized_keys<ul>
<li>ssh-keygen -t rsa</li>
<li>cat ~/.ssh/id_rsa.pub &gt; authorized_keys</li>
</ul>
</li>
</ul>
<h5 id="编写dockerfile"><a href="#编写dockerfile" class="headerlink" title="编写dockerfile"></a>编写dockerfile</h5><pre><code># 设置继承镜像
FROM ubuntu:14.04

# 提供一些作者的信息
MAINTAINER docker_user (user@docker.com)

# 下面开始运行更新命令
RUN apt-get update

# 安装ssh服务
RUN apt-get install -y openssh-server
RUN mkdir -p /var/run/sshd
RUN mkdir -p /root/.ssh
# 取消pam限制
RUN sed -ri &apos;s/session required pam_loginuid.so/#session required pam_loginuid.so/g&apos; /etc/pam.d/sshd

# 复制配置文件到相应位置，并赋予脚本可执行权限
ADD authorized_keys /root/.ssh/authorized_keys
ADD run.sh /run.sh
RUN chmod 755 /run.sh

# 开放端口
EXPOSE 22

# 设置自启动命令
CMD [&quot;/run.sh&quot;]
</code></pre><h5 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h5><ul>
<li>在sshd_ubuntu目录下，使用docker build创建镜像。命令中的.表示使用当前目录中的dockerfile<ul>
<li>cd sshd_ubuntu</li>
<li>docker build -t sshd:dockerfile .</li>
</ul>
</li>
<li>使用dockerfile创建自定义镜像，docker会删除中间临时创建的层。</li>
</ul>
<h5 id="测试镜像，运行容器"><a href="#测试镜像，运行容器" class="headerlink" title="测试镜像，运行容器"></a>测试镜像，运行容器</h5><ul>
<li>docker run -d -p 10122:22 sshd:dockerfile</li>
<li>ssh 192.168.1.200 -p 10122</li>
</ul>
<hr>
<h1 id="第11章-Web服务与应用"><a href="#第11章-Web服务与应用" class="headerlink" title="第11章 Web服务与应用"></a>第11章 Web服务与应用</h1><ul>
<li>操作简单的镜像使用dockerfile创建；复杂应用（如weblogic）使用commit方式创建。</li>
</ul>
<h3 id="11-1-Apache"><a href="#11-1-Apache" class="headerlink" title="11.1 Apache"></a>11.1 Apache</h3><h5 id="使用官方镜像-1"><a href="#使用官方镜像-1" class="headerlink" title="使用官方镜像"></a>使用官方镜像</h5><ul>
<li><p>编写dockerfile</p>
<pre><code>FROM httpd:2.4
COPY ./public-html /usr/local/apache2/htdocs/
</code></pre></li>
<li>创建public-html目录，创建index.html</li>
<li>构建镜像<ul>
<li>docker build -t apache2-image .</li>
</ul>
</li>
<li>运行镜像<ul>
<li>docker run -it –rm –name apache-container -p 80:80 apacha2-image</li>
</ul>
</li>
<li>不创建镜像，通过映射目录方式运行apache<ul>
<li>docker run -it –rm –name my-apache-app -p 80:80 -v “$PWD”:/usr/local/apache2/htdocs/ httpd:2.4</li>
</ul>
</li>
</ul>
<h5 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h5><ul>
<li>略</li>
</ul>
<h3 id="11-2-Nginx"><a href="#11-2-Nginx" class="headerlink" title="11.2 Nginx"></a>11.2 Nginx</h3><ul>
<li>支持协议：http、https、smtp、pop3、imap</li>
<li>官方镜像：docker run -d -p 80:80 –name webserver nginx</li>
<li>自定义web页面<ul>
<li>docker run –name nginx-container -p 80:80 -v index.html:/usr/share/nginx/html:ro -d nginx</li>
</ul>
</li>
<li><p>dockerfile构建镜像</p>
<pre><code>FROM nginx
COPY ./index.html /usr/share/nginx/html
</code></pre><ul>
<li>docker build -t my-nginx .</li>
<li>docker run –name nginx-container -d my-nginx</li>
</ul>
</li>
</ul>
<h3 id="11-3-Tomcat"><a href="#11-3-Tomcat" class="headerlink" title="11.3 Tomcat"></a>11.3 Tomcat</h3><h5 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h5><ul>
<li>创建dockerfile、run.sh<ul>
<li>mkdir tomcat7_jdk6</li>
<li>cd tomcat7_jdk6</li>
<li>touch Dockerfile run.sh</li>
<li>下载tomcat并解压到tomcat7_jdk6</li>
<li>Dockerfile、run.sh、apache-tomcat-7.0.56 jdk</li>
</ul>
</li>
</ul>
<h5 id="dockerfile文件、脚本文件"><a href="#dockerfile文件、脚本文件" class="headerlink" title="dockerfile文件、脚本文件"></a>dockerfile文件、脚本文件</h5><ul>
<li><p>Dockerfile</p>
<pre><code>FROM sshd:dockerfile
# 设置继承自用户创建的sshd镜像
MAINTAINER docker_user (user@docker.com)
# 下面是一些创建者的基本信息

# 设置环境变量，所有操作都是非交互式的
ENV DEBIAN_FRONTEND noninteractive

# 注意这里要更改系统的时区设置
RUN echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone &amp;&amp; dpkg-reconfigure -f noninteractive tzdata

# 安装跟 tomcat 用户认证相关的软件
RUN apt-get install -yq --no-install-recommends wget pwgen ca-certificates &amp;&amp; apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/*

# 设置 tomcat 的环境变量，若读者有其他环境变量需要设置，也可在此添加
ENV CATALINA_HOME /tomcat
ENV JAVA_HOME /jdk

# 复制 tomcat 和 jdk 文件到镜像中
ADD apache-tomcat-7.0.56 /tomcat
ADD jdk /jdk

ADD create_tomcat_admin_user.sh /create_tomcat_admin_user.sh
ADD run.sh /run.sh
RUN chmod +x /*.sh
RUN chmod +x /tomcat/bin/*.sh

EXPOSE 8080
CMD [&quot;/run.sh&quot;]
</code></pre></li>
<li><p>创建 tomcat 用户和密码脚本文件 create_tomcat_admin_user.sh</p>
<pre><code>#!/bin/bash

if [ -f /.tomcat_admin_created ]; then
    echo &quot;Tomcat &apos;admin&apos; user already created&quot;
    exit 0
fi

#generate password
PASS=${TOMCAT_PASS:-$(pwgen -s 12 1)}
_word=$( [ ${TOMCAT_PASS}] &amp;&amp; echo &quot;preset&quot; || echo &quot;random&quot; )

echo &quot;=&gt; Creating and admin user with a ${_word} password in Tomcat&quot;
sed -i -r &apos;s/&lt;\/tomcat-users&gt;//&apos; ${CATALINA_HOME}/conf/tomcat-users.xml
echo &apos;&lt;role rolename=&quot;manager-gui&quot;/&gt;&apos; &gt;&gt; ${CATALINA_HOME}/conf/tomcat-users.xml
echo &apos;&lt;role rolename=&quot;manager-script&quot;/&gt;&apos; &gt;&gt; ${CATALINA_HOME}/conf/tomcat-users.xml
echo &apos;&lt;role rolename=&quot;manager-jmx&quot;/&gt;&apos; &gt;&gt; ${CATALINA_HOME}/conf/tomcat-users.xml
echo &apos;&lt;role rolename=&quot;admin-gui&quot;/&gt;&apos; &gt;&gt; ${CATALINA_HOME}/conf/tomcat-users.xml
echo &apos;&lt;role rolename=&quot;admin&quot;-script&quot;/&gt;&apos; &gt;&gt; ${CATALINA_HOME}/conf/tomcat-users.xml
echo &quot;&lt;user username=\&quot;admin\&quot; password=\&quot;${PASS}\&quot; roles=\&quot;manager-gui,manager-script,manager-jmx,admin-gui,admin-script\&quot;/&gt;&quot; &gt;&gt; ${CATALINA_HOME}/conf/tomcat-users.xml
echo &apos;&lt;/tomcat-users&gt;&apos; &gt;&gt; ${CATALINA_HOME}/conf/tomcat-users.xml
echo &quot;=&gt; Done!&quot;
touch /.tomcat_admin_created

echo &quot;======================&quot;
echo &quot;You can now configure to this Tomcat server using:&quot;
echo &quot;&quot;
echo &quot;   admin:${PASS}&quot;
echo &quot;&quot;
echo &quot;======================&quot;
</code></pre></li>
<li><p>run.sh</p>
<pre><code>#!/bin/bash

if [ ! -f /.tomcat_admin_created ]; then
    /create_tomcat_admin_user.sh
fi
/usr/sbin/sshd -D &amp; exec ${CATALINA_HOME}/bin/catalina.sh run
</code></pre></li>
</ul>
<h5 id="创建、测试镜像"><a href="#创建、测试镜像" class="headerlink" title="创建、测试镜像"></a>创建、测试镜像</h5><ul>
<li>docker build -t tomcat7:jdk6</li>
<li>docker run -d -P tomcat7:jdk6</li>
<li>获取 tomcat 密码：docker logs CONTAINER_ID</li>
<li>docker ps</li>
<li>可用-v来挂载Tomcat日志文件、程序所在目录、tomcat相关配置。</li>
</ul>
<h3 id="11-4-Jetty"><a href="#11-4-Jetty" class="headerlink" title="11.4 Jetty"></a>11.4 Jetty</h3><ul>
<li>docker run -d jetty<ul>
<li>docker run -d -p 80:8080 -p 443:8443 jetty</li>
</ul>
</li>
<li>container-ip:8080</li>
</ul>
<h3 id="11-5-LAMP"><a href="#11-5-LAMP" class="headerlink" title="11.5 LAMP"></a>11.5 LAMP</h3><h5 id="linode-lamp镜像"><a href="#linode-lamp镜像" class="headerlink" title="linode/lamp镜像"></a>linode/lamp镜像</h5><ul>
<li>docker run -p 80:80 -t -i linode/lamp /bin/bash</li>
<li>进入容器启动apache、mysql<ul>
<li>service apache2 start</li>
<li>service mysql start</li>
</ul>
</li>
</ul>
<h5 id="tutum-lamp镜像"><a href="#tutum-lamp镜像" class="headerlink" title="tutum/lamp镜像"></a>tutum/lamp镜像</h5><ul>
<li>docker run -d -p 80:80 -p 3306:3306 tutum/lamp</li>
</ul>
<h3 id="11-6-CMS"><a href="#11-6-CMS" class="headerlink" title="11.6 CMS"></a>11.6 CMS</h3><h5 id="11-6-1-WordPress"><a href="#11-6-1-WordPress" class="headerlink" title="11.6.1 WordPress"></a>11.6.1 WordPress</h5><ul>
<li>基于 PHP 和 Mysql</li>
<li>使用官方镜像<ul>
<li>下载：docker pull wordpress</li>
<li>创建wordpress容器，连接mysql容器<ul>
<li>docker run –name some-wordpress –link some-mysql:mysql -p 8080:80 -d wordpress</li>
</ul>
</li>
</ul>
</li>
<li><p>使用Compose一键搭建Wordpress应用</p>
<ul>
<li><p>创建docker-compose.yml</p>
<pre><code>wordpress:
    image: wordpress
    links:
        - db:mysql
    ports:
        - 8080:80

db:
    -image: mariadb
    environment:
        MYSQL_ROOT_PASSWORD: example
</code></pre></li>
<li><p>执行：docker-compose up</p>
</li>
<li>如无docker-compose命令，可通过pip install docker-compose在线安装</li>
<li>通过80端口打开wordpress配置页。</li>
</ul>
</li>
</ul>
<h5 id="11-6-2-Ghost"><a href="#11-6-2-Ghost" class="headerlink" title="11.6.2 Ghost"></a>11.6.2 Ghost</h5><ul>
<li>开源博客平台，Javascript编写。</li>
<li>docker run –name ghost-container -d ghost<ul>
<li>默认监听2368端口</li>
<li>docker run –name ghost-container -p 8080:2368 -d ghost</li>
</ul>
</li>
<li>挂载已有的内容到Ghost容器内<ul>
<li>docker run –name some-ghost -v /path/to/ghost/blog:/var/lib/ghost ghost</li>
</ul>
</li>
</ul>
<h3 id="11-7-持续开发与管理"><a href="#11-7-持续开发与管理" class="headerlink" title="11.7 持续开发与管理"></a>11.7 持续开发与管理</h3><ul>
<li>持续集成CI，持续交付CD</li>
</ul>
<h5 id="11-7-1-Jenkins"><a href="#11-7-1-Jenkins" class="headerlink" title="11.7.1 Jenkins"></a>11.7.1 Jenkins</h5><ul>
<li>jenkins官方提供了Docker镜像</li>
<li>宿主机：mkdir jenkins_data</li>
<li>数据持久化<ul>
<li>数据卷机制<ul>
<li>docker run -p 8080:8080 -p 50000:50000 -v /var/jenkins_data:/var/jenkins_home jenkins</li>
</ul>
</li>
<li>数据卷容器<ul>
<li>docker run –name myjenkins -p 8080:8080 -p 50000:50000 -v /var/jenkins_home jenkins</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="11-7-2-Gitlab"><a href="#11-7-2-Gitlab" class="headerlink" title="11.7.2 Gitlab"></a>11.7.2 Gitlab</h5><ul>
<li>gitlab官方提供DockerHub镜像</li>
<li><p>命令</p>
<pre><code>docker run --detach \
    --hostname ip:port \
    --publish 443:443 --publish 80:80 --publish 23:23 \
    --name gitlab \
    --restart always \
    --volume /srv/gitlab/config:/etc/gitlab \
    --volume /srv/gitlab/logs:/var/log/gitlab \
    --volume /srv/gitlab/data:/var/opt/gitlab \
    gitlab/gitlab-ce:latest
</code></pre><ul>
<li>hostname指外网ip或域名，git项目地址即为<a href="http://ip:port/projectname" target="_blank" rel="external">http://ip:port/projectname</a></li>
<li>本地目录/srv/gitlab/*提前创建好</li>
<li>几分钟后gitlab启动成功</li>
</ul>
</li>
</ul>
<h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><ul>
<li>对于程序代码、程序资源目录、日志、数据库文件等需实时更新的数据，一定要通过-v映射到宿主主机的目录，避免数据丢失。</li>
</ul>
<hr>
<h1 id="第12章-数据库应用"><a href="#第12章-数据库应用" class="headerlink" title="第12章 数据库应用"></a>第12章 数据库应用</h1><h3 id="12-1-MySQL"><a href="#12-1-MySQL" class="headerlink" title="12.1 MySQL"></a>12.1 MySQL</h3><ul>
<li>官方镜像<ul>
<li>docker run –name hi-mysql -e MYSQL_ROOT_PASSWORD=123 -d mysql:latest</li>
<li>以上容器名为hi-mysql，密码为123</li>
</ul>
</li>
<li><p>将应用容器连接到mysql容器</p>
<ul>
<li>docker run –name some-app –link some-mysql:mysql -d application-that-uses-mysql</li>
<li>修改mysql配置<ul>
<li>docker run -it –link some-mysql:mysql –rm mysql sh -c ‘exec mysql -h”$MYSQL_PORT_3306_TCP_ADDR” -P”$MYSQL_PORT_3306_TCP_PORT” -uroot -p”$MYSQL_ENV_MYSQL_ROOT_PASSWORD”‘</li>
</ul>
</li>
</ul>
</li>
<li><p>mysql容器作为客户端连接非docker或远程mysql实例</p>
<ul>
<li>docker run -it –rm mysql mysql -hsome.mysql.host -usome-mysql-user -p</li>
</ul>
</li>
</ul>
<h5 id="系统与日志访问"><a href="#系统与日志访问" class="headerlink" title="系统与日志访问"></a>系统与日志访问</h5><ul>
<li>使用docker exec指令调用内部系统bash shell，以访问容器内部系统<ul>
<li>docker exec -it some-mysql bash</li>
</ul>
</li>
<li>查看mysql日志<ul>
<li>docker logs some-mysql</li>
</ul>
</li>
</ul>
<h5 id="使用自定义配置文件"><a href="#使用自定义配置文件" class="headerlink" title="使用自定义配置文件"></a>使用自定义配置文件</h5><ul>
<li>创建cnf配置文件(如/mypath/config-file.cnf)，并挂载至容器的/etc/mysql/conf.d目录<ul>
<li>docker run –name some-mysql -v /mypath:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</li>
</ul>
</li>
<li>新容器启动后会结合使用/etc/mysql/my.cnf和/mypath/config-file.cnf两个配置文件。</li>
</ul>
<h5 id="脱离cnf文件进行配置"><a href="#脱离cnf文件进行配置" class="headerlink" title="脱离cnf文件进行配置"></a>脱离cnf文件进行配置</h5><ul>
<li>很多配置项可通过标签传给mysqld进程，这样用户可脱离cnf对容器进行弹性的定制。</li>
<li>改变表编码为uft8mb4<ul>
<li>docker run –name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag –character-set-server=utf8mb4 –collation-server=utf8mb4_unicode_ci</li>
</ul>
</li>
<li>查看命令<ul>
<li>docker run -it –rm mysql:tag –verbose –help</li>
</ul>
</li>
</ul>
<h3 id="12-2-MongoDB"><a href="#12-2-MongoDB" class="headerlink" title="12.2 MongoDB"></a>12.2 MongoDB</h3><h5 id="12-2-1-使用官方镜像"><a href="#12-2-1-使用官方镜像" class="headerlink" title="12.2.1 使用官方镜像"></a>12.2.1 使用官方镜像</h5><ul>
<li>docker run –name mongo-container -d mongo</li>
<li>进入mongo容器<ul>
<li>docker exec -it CONTAINER_ID sh</li>
<li>启动mongo：mongo</li>
<li>show dbs</li>
<li>db.status()</li>
</ul>
</li>
<li>查看环境变量：容器内执行 env 命令</li>
<li><p>默认端口 27017</p>
</li>
<li><p>连接已创建的 mongodb 容器</p>
<ul>
<li>docker run -it –link mongo-container:db alpine sh</li>
<li>ping db</li>
</ul>
</li>
<li>直接使用 mongo cli 指令<ul>
<li>在宿主机上直接使用 mongodb 镜像，可在 docker run 后加入 entrypoint 指令，即可直接进入 mongo cli 了。</li>
<li>docker run -it –link mongo-container:db –entrypoint mongo mongo –host db</li>
<li>可设置存储引擎：docker run –name mongo-container -d mongo –storageEngine wiredTiger</li>
</ul>
</li>
</ul>
<h5 id="12-2-2-使用自定义Dockerfile"><a href="#12-2-2-使用自定义Dockerfile" class="headerlink" title="12.2.2 使用自定义Dockerfile"></a>12.2.2 使用自定义Dockerfile</h5><ul>
<li><h3 id="12-3-Redis"><a href="#12-3-Redis" class="headerlink" title="12.3 Redis"></a>12.3 Redis</h3><h3 id="12-4-Memcached"><a href="#12-4-Memcached" class="headerlink" title="12.4 Memcached"></a>12.4 Memcached</h3><h3 id="12-5-CouchDB"><a href="#12-5-CouchDB" class="headerlink" title="12.5 CouchDB"></a>12.5 CouchDB</h3><h3 id="12-6-Cassandra"><a href="#12-6-Cassandra" class="headerlink" title="12.6 Cassandra"></a>12.6 Cassandra</h3><h3 id="12-7-本章小结"><a href="#12-7-本章小结" class="headerlink" title="12.7 本章小结"></a>12.7 本章小结</h3></li>
</ul>
<hr>
<h1 id="第13章-分布式处理与大数据平台"><a href="#第13章-分布式处理与大数据平台" class="headerlink" title="第13章 分布式处理与大数据平台"></a>第13章 分布式处理与大数据平台</h1><h3 id="13-1-RabbitMQ"><a href="#13-1-RabbitMQ" class="headerlink" title="13.1 RabbitMQ"></a>13.1 RabbitMQ</h3><h3 id="13-2-Celery"><a href="#13-2-Celery" class="headerlink" title="13.2 Celery"></a>13.2 Celery</h3><h3 id="13-3-Hadoop"><a href="#13-3-Hadoop" class="headerlink" title="13.3 Hadoop"></a>13.3 Hadoop</h3><h3 id="13-4-Spark"><a href="#13-4-Spark" class="headerlink" title="13.4 Spark"></a>13.4 Spark</h3><h5 id="13-4-1-使用官方镜像"><a href="#13-4-1-使用官方镜像" class="headerlink" title="13.4.1 使用官方镜像"></a>13.4.1 使用官方镜像</h5><h5 id="13-4-2-验证"><a href="#13-4-2-验证" class="headerlink" title="13.4.2 验证"></a>13.4.2 验证</h5><h3 id="13-5-Storm"><a href="#13-5-Storm" class="headerlink" title="13.5 Storm"></a>13.5 Storm</h3><h3 id="13-6-ElasticSearch"><a href="#13-6-ElasticSearch" class="headerlink" title="13.6 ElasticSearch"></a>13.6 ElasticSearch</h3><h3 id="13-7-本章小结"><a href="#13-7-本章小结" class="headerlink" title="13.7 本章小结"></a>13.7 本章小结</h3><hr>
<h1 id="第14章-编程开发"><a href="#第14章-编程开发" class="headerlink" title="第14章 编程开发"></a>第14章 编程开发</h1><h3 id="14-1-C-C"><a href="#14-1-C-C" class="headerlink" title="14.1 C/C++"></a>14.1 C/C++</h3><h5 id="14-1-1-GCC"><a href="#14-1-1-GCC" class="headerlink" title="14.1.1 GCC"></a>14.1.1 GCC</h5><h5 id="14-1-2-LLVM"><a href="#14-1-2-LLVM" class="headerlink" title="14.1.2 LLVM"></a>14.1.2 LLVM</h5><h5 id="14-1-3-Clang"><a href="#14-1-3-Clang" class="headerlink" title="14.1.3 Clang"></a>14.1.3 Clang</h5><h3 id="14-2-Java"><a href="#14-2-Java" class="headerlink" title="14.2 Java"></a>14.2 Java</h3><h3 id="14-3-Python"><a href="#14-3-Python" class="headerlink" title="14.3 Python"></a>14.3 Python</h3><h5 id="14-3-1-使用官方的Python镜像"><a href="#14-3-1-使用官方的Python镜像" class="headerlink" title="14.3.1 使用官方的Python镜像"></a>14.3.1 使用官方的Python镜像</h5><h5 id="14-3-2-使用PyPy"><a href="#14-3-2-使用PyPy" class="headerlink" title="14.3.2 使用PyPy"></a>14.3.2 使用PyPy</h5><h3 id="14-4-JavaScript"><a href="#14-4-JavaScript" class="headerlink" title="14.4 JavaScript"></a>14.4 JavaScript</h3><h3 id="14-5-Go"><a href="#14-5-Go" class="headerlink" title="14.5 Go"></a>14.5 Go</h3><h5 id="14-5-1-搭建并运行Go容器"><a href="#14-5-1-搭建并运行Go容器" class="headerlink" title="14.5.1 搭建并运行Go容器"></a>14.5.1 搭建并运行Go容器</h5><h5 id="14-5-2-Beego"><a href="#14-5-2-Beego" class="headerlink" title="14.5.2 Beego"></a>14.5.2 Beego</h5><h5 id="14-5-3-Gogs-基于Go的Git服务"><a href="#14-5-3-Gogs-基于Go的Git服务" class="headerlink" title="14.5.3 Gogs:基于Go的Git服务"></a>14.5.3 Gogs:基于Go的Git服务</h5><h3 id="14-6-PHP"><a href="#14-6-PHP" class="headerlink" title="14.6 PHP"></a>14.6 PHP</h3><h3 id="14-7-Ruby"><a href="#14-7-Ruby" class="headerlink" title="14.7 Ruby"></a>14.7 Ruby</h3><h5 id="14-7-1-使用Ruby官方镜像"><a href="#14-7-1-使用Ruby官方镜像" class="headerlink" title="14.7.1 使用Ruby官方镜像"></a>14.7.1 使用Ruby官方镜像</h5><h5 id="14-7-2-JRuby"><a href="#14-7-2-JRuby" class="headerlink" title="14.7.2 JRuby"></a>14.7.2 JRuby</h5><h5 id="14-7-3-Ruby-on-Rails"><a href="#14-7-3-Ruby-on-Rails" class="headerlink" title="14.7.3 Ruby on Rails"></a>14.7.3 Ruby on Rails</h5><h3 id="14-8-Perl"><a href="#14-8-Perl" class="headerlink" title="14.8 Perl"></a>14.8 Perl</h3><h3 id="14-9-R"><a href="#14-9-R" class="headerlink" title="14.9 R"></a>14.9 R</h3><h3 id="14-10-Erlang"><a href="#14-10-Erlang" class="headerlink" title="14.10 Erlang"></a>14.10 Erlang</h3><h3 id="14-11-本章小结"><a href="#14-11-本章小结" class="headerlink" title="14.11 本章小结"></a>14.11 本章小结</h3><hr>
<h1 id="第15章-容器与云服务"><a href="#第15章-容器与云服务" class="headerlink" title="第15章 容器与云服务"></a>第15章 容器与云服务</h1><h3 id="15-1-公有云容器服务"><a href="#15-1-公有云容器服务" class="headerlink" title="15.1 公有云容器服务"></a>15.1 公有云容器服务</h3><h5 id="15-1-1-AWS"><a href="#15-1-1-AWS" class="headerlink" title="15.1.1 AWS"></a>15.1.1 AWS</h5><h5 id="15-1-2-Google-Cloud-Platform"><a href="#15-1-2-Google-Cloud-Platform" class="headerlink" title="15.1.2 Google Cloud Platform"></a>15.1.2 Google Cloud Platform</h5><h5 id="15-1-3-Azure"><a href="#15-1-3-Azure" class="headerlink" title="15.1.3 Azure"></a>15.1.3 Azure</h5><h5 id="15-1-4-腾讯云"><a href="#15-1-4-腾讯云" class="headerlink" title="15.1.4 腾讯云"></a>15.1.4 腾讯云</h5><h5 id="15-1-5-阿里云"><a href="#15-1-5-阿里云" class="headerlink" title="15.1.5 阿里云"></a>15.1.5 阿里云</h5><h5 id="15-1-6-华为云"><a href="#15-1-6-华为云" class="headerlink" title="15.1.6 华为云"></a>15.1.6 华为云</h5><h5 id="15-1-7-UCloud"><a href="#15-1-7-UCloud" class="headerlink" title="15.1.7 UCloud"></a>15.1.7 UCloud</h5><h3 id="15-2-容器云服务"><a href="#15-2-容器云服务" class="headerlink" title="15.2 容器云服务"></a>15.2 容器云服务</h3><h5 id="15-2-1-基本要素与关键特性"><a href="#15-2-1-基本要素与关键特性" class="headerlink" title="15.2.1 基本要素与关键特性"></a>15.2.1 基本要素与关键特性</h5><h5 id="15-2-2-网易蜂巢"><a href="#15-2-2-网易蜂巢" class="headerlink" title="15.2.2 网易蜂巢"></a>15.2.2 网易蜂巢</h5><h5 id="15-2-3-时速云"><a href="#15-2-3-时速云" class="headerlink" title="15.2.3 时速云"></a>15.2.3 时速云</h5><h5 id="15-2-4-Daocloud"><a href="#15-2-4-Daocloud" class="headerlink" title="15.2.4 Daocloud"></a>15.2.4 Daocloud</h5><h5 id="15-2-5-灵雀云"><a href="#15-2-5-灵雀云" class="headerlink" title="15.2.5 灵雀云"></a>15.2.5 灵雀云</h5><h5 id="15-2-6-数人云"><a href="#15-2-6-数人云" class="headerlink" title="15.2.6 数人云"></a>15.2.6 数人云</h5><h3 id="15-3-阿里云容器服务"><a href="#15-3-阿里云容器服务" class="headerlink" title="15.3 阿里云容器服务"></a>15.3 阿里云容器服务</h3><h3 id="15-4-时速云容器平台"><a href="#15-4-时速云容器平台" class="headerlink" title="15.4 时速云容器平台"></a>15.4 时速云容器平台</h3><h3 id="15-5-本章小结"><a href="#15-5-本章小结" class="headerlink" title="15.5 本章小结"></a>15.5 本章小结</h3><hr>
<h1 id="第16章-容器实战思考"><a href="#第16章-容器实战思考" class="headerlink" title="第16章 容器实战思考"></a>第16章 容器实战思考</h1><h3 id="16-1-docker为什么会成功"><a href="#16-1-docker为什么会成功" class="headerlink" title="16.1 docker为什么会成功"></a>16.1 docker为什么会成功</h3><h3 id="16-2-研发人员该如何看容器"><a href="#16-2-研发人员该如何看容器" class="headerlink" title="16.2 研发人员该如何看容器"></a>16.2 研发人员该如何看容器</h3><h3 id="16-3-容器化开发模式"><a href="#16-3-容器化开发模式" class="headerlink" title="16.3 容器化开发模式"></a>16.3 容器化开发模式</h3><h3 id="16-4-容器与生产环境"><a href="#16-4-容器与生产环境" class="headerlink" title="16.4 容器与生产环境"></a>16.4 容器与生产环境</h3><h3 id="16-5-本章小结"><a href="#16-5-本章小结" class="headerlink" title="16.5 本章小结"></a>16.5 本章小结</h3><hr>
<h1 id="第17章-docker核心实现技术"><a href="#第17章-docker核心实现技术" class="headerlink" title="第17章 docker核心实现技术"></a>第17章 docker核心实现技术</h1><h3 id="17-1-基本架构"><a href="#17-1-基本架构" class="headerlink" title="17.1 基本架构"></a>17.1 基本架构</h3><h3 id="17-2-命名空间"><a href="#17-2-命名空间" class="headerlink" title="17.2 命名空间"></a>17.2 命名空间</h3><h3 id="17-3-控制组"><a href="#17-3-控制组" class="headerlink" title="17.3 控制组"></a>17.3 控制组</h3><h3 id="17-4-联合文件系统"><a href="#17-4-联合文件系统" class="headerlink" title="17.4 联合文件系统"></a>17.4 联合文件系统</h3><h3 id="17-5-Linux网络虚拟化"><a href="#17-5-Linux网络虚拟化" class="headerlink" title="17.5 Linux网络虚拟化"></a>17.5 Linux网络虚拟化</h3><h3 id="17-6-本章小结"><a href="#17-6-本章小结" class="headerlink" title="17.6 本章小结"></a>17.6 本章小结</h3><hr>
<h1 id="第18章-配置私有仓库"><a href="#第18章-配置私有仓库" class="headerlink" title="第18章 配置私有仓库"></a>第18章 配置私有仓库</h1><h3 id="18-1-安装Docker-Registry"><a href="#18-1-安装Docker-Registry" class="headerlink" title="18.1 安装Docker Registry"></a>18.1 安装Docker Registry</h3><h3 id="18-2-配置TLS证书"><a href="#18-2-配置TLS证书" class="headerlink" title="18.2 配置TLS证书"></a>18.2 配置TLS证书</h3><h3 id="18-3-管理访问权限"><a href="#18-3-管理访问权限" class="headerlink" title="18.3 管理访问权限"></a>18.3 管理访问权限</h3><h3 id="18-4-配置Registry"><a href="#18-4-配置Registry" class="headerlink" title="18.4 配置Registry"></a>18.4 配置Registry</h3><h5 id="18-4-1-示例配置"><a href="#18-4-1-示例配置" class="headerlink" title="18.4.1 示例配置"></a>18.4.1 示例配置</h5><h5 id="18-4-2-选项"><a href="#18-4-2-选项" class="headerlink" title="18.4.2 选项"></a>18.4.2 选项</h5><h3 id="18-5-批量管理镜像"><a href="#18-5-批量管理镜像" class="headerlink" title="18.5 批量管理镜像"></a>18.5 批量管理镜像</h3><h3 id="18-6-使用通知系统"><a href="#18-6-使用通知系统" class="headerlink" title="18.6 使用通知系统"></a>18.6 使用通知系统</h3><h5 id="18-6-1-相关配置"><a href="#18-6-1-相关配置" class="headerlink" title="18.6.1 相关配置"></a>18.6.1 相关配置</h5><h5 id="18-6-2-Notification的使用场景"><a href="#18-6-2-Notification的使用场景" class="headerlink" title="18.6.2 Notification的使用场景"></a>18.6.2 Notification的使用场景</h5><h3 id="18-7-本章小结"><a href="#18-7-本章小结" class="headerlink" title="18.7 本章小结"></a>18.7 本章小结</h3><hr>
<h1 id="第19章-安全防护与配置"><a href="#第19章-安全防护与配置" class="headerlink" title="第19章 安全防护与配置"></a>第19章 安全防护与配置</h1><h3 id="19-1-命名空间隔离的安全"><a href="#19-1-命名空间隔离的安全" class="headerlink" title="19.1 命名空间隔离的安全"></a>19.1 命名空间隔离的安全</h3><h3 id="19-2-控制组资源控制的安全"><a href="#19-2-控制组资源控制的安全" class="headerlink" title="19.2 控制组资源控制的安全"></a>19.2 控制组资源控制的安全</h3><h3 id="19-3-内核能力机制"><a href="#19-3-内核能力机制" class="headerlink" title="19.3 内核能力机制"></a>19.3 内核能力机制</h3><h3 id="19-4-Docker服务端的防护"><a href="#19-4-Docker服务端的防护" class="headerlink" title="19.4 Docker服务端的防护"></a>19.4 Docker服务端的防护</h3><h3 id="19-5-更多安全特性的使用"><a href="#19-5-更多安全特性的使用" class="headerlink" title="19.5 更多安全特性的使用"></a>19.5 更多安全特性的使用</h3><h3 id="19-6-使用第三方检测工具"><a href="#19-6-使用第三方检测工具" class="headerlink" title="19.6 使用第三方检测工具"></a>19.6 使用第三方检测工具</h3><h5 id="19-6-1-Docker-Bench"><a href="#19-6-1-Docker-Bench" class="headerlink" title="19.6.1 Docker Bench"></a>19.6.1 Docker Bench</h5><h5 id="19-6-2-clair"><a href="#19-6-2-clair" class="headerlink" title="19.6.2 clair"></a>19.6.2 clair</h5><h3 id="19-7-本章小结"><a href="#19-7-本章小结" class="headerlink" title="19.7 本章小结"></a>19.7 本章小结</h3><hr>
<h1 id="第20章-高级网络功能"><a href="#第20章-高级网络功能" class="headerlink" title="第20章 高级网络功能"></a>第20章 高级网络功能</h1><h3 id="20-1-网络启动与配置参数"><a href="#20-1-网络启动与配置参数" class="headerlink" title="20.1 网络启动与配置参数"></a>20.1 网络启动与配置参数</h3><h3 id="20-2-配置容器DNS和主机名"><a href="#20-2-配置容器DNS和主机名" class="headerlink" title="20.2 配置容器DNS和主机名"></a>20.2 配置容器DNS和主机名</h3><h3 id="20-3-容器访问控制"><a href="#20-3-容器访问控制" class="headerlink" title="20.3 容器访问控制"></a>20.3 容器访问控制</h3><h3 id="20-4-映射容器端口到宿主主机的实现"><a href="#20-4-映射容器端口到宿主主机的实现" class="headerlink" title="20.4 映射容器端口到宿主主机的实现"></a>20.4 映射容器端口到宿主主机的实现</h3><h3 id="20-5-配置docker0网桥"><a href="#20-5-配置docker0网桥" class="headerlink" title="20.5 配置docker0网桥"></a>20.5 配置docker0网桥</h3><h3 id="20-6-自定义网桥"><a href="#20-6-自定义网桥" class="headerlink" title="20.6 自定义网桥"></a>20.6 自定义网桥</h3><h3 id="20-7-使用OpenvSwitch网桥"><a href="#20-7-使用OpenvSwitch网桥" class="headerlink" title="20.7 使用OpenvSwitch网桥"></a>20.7 使用OpenvSwitch网桥</h3><h3 id="20-8-创建一个点到点连接"><a href="#20-8-创建一个点到点连接" class="headerlink" title="20.8 创建一个点到点连接"></a>20.8 创建一个点到点连接</h3><h3 id="20-9-本章小结"><a href="#20-9-本章小结" class="headerlink" title="20.9 本章小结"></a>20.9 本章小结</h3><hr>
<h1 id="第21章-libnetwork插件化网络功能"><a href="#第21章-libnetwork插件化网络功能" class="headerlink" title="第21章 libnetwork插件化网络功能"></a>第21章 libnetwork插件化网络功能</h1><h3 id="21-1-容器网络模型"><a href="#21-1-容器网络模型" class="headerlink" title="21.1 容器网络模型"></a>21.1 容器网络模型</h3><h3 id="21-2-docker网络相关命令"><a href="#21-2-docker网络相关命令" class="headerlink" title="21.2 docker网络相关命令"></a>21.2 docker网络相关命令</h3><h3 id="21-3-构建跨主机容器网络"><a href="#21-3-构建跨主机容器网络" class="headerlink" title="21.3 构建跨主机容器网络"></a>21.3 构建跨主机容器网络</h3><h3 id="21-4-本章小结"><a href="#21-4-本章小结" class="headerlink" title="21.4 本章小结"></a>21.4 本章小结</h3><hr>
<h1 id="第22章-Etcd–高可用的键值数据库"><a href="#第22章-Etcd–高可用的键值数据库" class="headerlink" title="第22章 Etcd–高可用的键值数据库"></a>第22章 Etcd–高可用的键值数据库</h1><h3 id="22-1-简介"><a href="#22-1-简介" class="headerlink" title="22.1 简介"></a>22.1 简介</h3><h3 id="22-2-安装和使用Etcd"><a href="#22-2-安装和使用Etcd" class="headerlink" title="22.2 安装和使用Etcd"></a>22.2 安装和使用Etcd</h3><h3 id="22-3-使用etcdctl客户端"><a href="#22-3-使用etcdctl客户端" class="headerlink" title="22.3 使用etcdctl客户端"></a>22.3 使用etcdctl客户端</h3><h5 id="22-3-1-数据类操作"><a href="#22-3-1-数据类操作" class="headerlink" title="22.3.1 数据类操作"></a>22.3.1 数据类操作</h5><h5 id="22-3-2-非数据类操作"><a href="#22-3-2-非数据类操作" class="headerlink" title="22.3.2 非数据类操作"></a>22.3.2 非数据类操作</h5><h3 id="22-4-Etcd集群管理"><a href="#22-4-Etcd集群管理" class="headerlink" title="22.4 Etcd集群管理"></a>22.4 Etcd集群管理</h3><h5 id="22-4-1-构建集群"><a href="#22-4-1-构建集群" class="headerlink" title="22.4.1 构建集群"></a>22.4.1 构建集群</h5><h5 id="22-4-2-集群参数配置"><a href="#22-4-2-集群参数配置" class="headerlink" title="22.4.2 集群参数配置"></a>22.4.2 集群参数配置</h5><h3 id="22-5-本章小结"><a href="#22-5-本章小结" class="headerlink" title="22.5 本章小结"></a>22.5 本章小结</h3><hr>
<h1 id="第23章-Docker三剑客之Docker-Machine"><a href="#第23章-Docker三剑客之Docker-Machine" class="headerlink" title="第23章 Docker三剑客之Docker Machine"></a>第23章 Docker三剑客之Docker Machine</h1><h3 id="23-1-简介"><a href="#23-1-简介" class="headerlink" title="23.1 简介"></a>23.1 简介</h3><h3 id="23-2-安装Machine"><a href="#23-2-安装Machine" class="headerlink" title="23.2 安装Machine"></a>23.2 安装Machine</h3><h3 id="23-3-使用Machine"><a href="#23-3-使用Machine" class="headerlink" title="23.3 使用Machine"></a>23.3 使用Machine</h3><h3 id="23-4-Machine命令"><a href="#23-4-Machine命令" class="headerlink" title="23.4 Machine命令"></a>23.4 Machine命令</h3><h3 id="23-5-本章小结"><a href="#23-5-本章小结" class="headerlink" title="23.5 本章小结"></a>23.5 本章小结</h3><hr>
<h1 id="第24章-Docker三剑客之Docker-Compose"><a href="#第24章-Docker三剑客之Docker-Compose" class="headerlink" title="第24章 Docker三剑客之Docker Compose"></a>第24章 Docker三剑客之Docker Compose</h1><h3 id="24-1简介"><a href="#24-1简介" class="headerlink" title="24.1简介"></a>24.1简介</h3><h3 id="24-2-安装与卸载"><a href="#24-2-安装与卸载" class="headerlink" title="24.2 安装与卸载"></a>24.2 安装与卸载</h3><h3 id="24-3-Compose命令说明"><a href="#24-3-Compose命令说明" class="headerlink" title="24.3 Compose命令说明"></a>24.3 Compose命令说明</h3><h3 id="24-4-Compose环境变量"><a href="#24-4-Compose环境变量" class="headerlink" title="24.4 Compose环境变量"></a>24.4 Compose环境变量</h3><h3 id="24-5-Compose模板文件"><a href="#24-5-Compose模板文件" class="headerlink" title="24.5 Compose模板文件"></a>24.5 Compose模板文件</h3><h3 id="24-6-Compose应用案例一-Web负载均衡"><a href="#24-6-Compose应用案例一-Web负载均衡" class="headerlink" title="24.6 Compose应用案例一:Web负载均衡"></a>24.6 Compose应用案例一:Web负载均衡</h3><h3 id="24-7-Compose应用案例二-大数据Spark集群"><a href="#24-7-Compose应用案例二-大数据Spark集群" class="headerlink" title="24.7 Compose应用案例二:大数据Spark集群"></a>24.7 Compose应用案例二:大数据Spark集群</h3><h3 id="24-8-本章小结"><a href="#24-8-本章小结" class="headerlink" title="24.8 本章小结"></a>24.8 本章小结</h3><hr>
<h1 id="第25章-Docker三剑客之Docker-Swarm"><a href="#第25章-Docker三剑客之Docker-Swarm" class="headerlink" title="第25章 Docker三剑客之Docker Swarm"></a>第25章 Docker三剑客之Docker Swarm</h1><h3 id="25-1-简介"><a href="#25-1-简介" class="headerlink" title="25.1 简介"></a>25.1 简介</h3><h3 id="25-2-安装Swarm"><a href="#25-2-安装Swarm" class="headerlink" title="25.2 安装Swarm"></a>25.2 安装Swarm</h3><h3 id="25-3-使用Swarm"><a href="#25-3-使用Swarm" class="headerlink" title="25.3 使用Swarm"></a>25.3 使用Swarm</h3><h3 id="25-4-使用其他服务发现后端"><a href="#25-4-使用其他服务发现后端" class="headerlink" title="25.4 使用其他服务发现后端"></a>25.4 使用其他服务发现后端</h3><h3 id="25-5-Swarm中的调度器"><a href="#25-5-Swarm中的调度器" class="headerlink" title="25.5 Swarm中的调度器"></a>25.5 Swarm中的调度器</h3><h3 id="25-6-Swarm中的过滤器"><a href="#25-6-Swarm中的过滤器" class="headerlink" title="25.6 Swarm中的过滤器"></a>25.6 Swarm中的过滤器</h3><h3 id="25-7-本章小结"><a href="#25-7-本章小结" class="headerlink" title="25.7 本章小结"></a>25.7 本章小结</h3><hr>
<h1 id="第26章-Mesos–优秀的集群资源调度平台"><a href="#第26章-Mesos–优秀的集群资源调度平台" class="headerlink" title="第26章 Mesos–优秀的集群资源调度平台"></a>第26章 Mesos–优秀的集群资源调度平台</h1><h3 id="26-1-简介"><a href="#26-1-简介" class="headerlink" title="26.1 简介"></a>26.1 简介</h3><h3 id="26-2-Mesos安装与使用"><a href="#26-2-Mesos安装与使用" class="headerlink" title="26.2 Mesos安装与使用"></a>26.2 Mesos安装与使用</h3><h3 id="26-3-原理与架构"><a href="#26-3-原理与架构" class="headerlink" title="26.3 原理与架构"></a>26.3 原理与架构</h3><h5 id="26-3-1-架构"><a href="#26-3-1-架构" class="headerlink" title="26.3.1 架构"></a>26.3.1 架构</h5><h5 id="26-3-2-基本单元"><a href="#26-3-2-基本单元" class="headerlink" title="26.3.2 基本单元"></a>26.3.2 基本单元</h5><h5 id="26-3-3-调度"><a href="#26-3-3-调度" class="headerlink" title="26.3.3 调度"></a>26.3.3 调度</h5><h5 id="26-3-4-高可用性"><a href="#26-3-4-高可用性" class="headerlink" title="26.3.4 高可用性"></a>26.3.4 高可用性</h5><h3 id="26-4-Mesos配置项解析"><a href="#26-4-Mesos配置项解析" class="headerlink" title="26.4 Mesos配置项解析"></a>26.4 Mesos配置项解析</h3><h5 id="26-4-1-通用项"><a href="#26-4-1-通用项" class="headerlink" title="26.4.1 通用项"></a>26.4.1 通用项</h5><h5 id="26-4-2-master专属项"><a href="#26-4-2-master专属项" class="headerlink" title="26.4.2 master专属项"></a>26.4.2 master专属项</h5><h5 id="26-4-3-slave专属项"><a href="#26-4-3-slave专属项" class="headerlink" title="26.4.3 slave专属项"></a>26.4.3 slave专属项</h5><h3 id="26-5-日志与监控"><a href="#26-5-日志与监控" class="headerlink" title="26.5 日志与监控"></a>26.5 日志与监控</h3><h3 id="26-6-常见应用框架"><a href="#26-6-常见应用框架" class="headerlink" title="26.6 常见应用框架"></a>26.6 常见应用框架</h3><h3 id="26-7-本章小结"><a href="#26-7-本章小结" class="headerlink" title="26.7 本章小结"></a>26.7 本章小结</h3><hr>
<h1 id="第27章-Kubernetes–生产级容器集群平台"><a href="#第27章-Kubernetes–生产级容器集群平台" class="headerlink" title="第27章 Kubernetes–生产级容器集群平台"></a>第27章 Kubernetes–生产级容器集群平台</h1><h3 id="27-1-简介"><a href="#27-1-简介" class="headerlink" title="27.1 简介"></a>27.1 简介</h3><h3 id="27-2-核心概念"><a href="#27-2-核心概念" class="headerlink" title="27.2 核心概念"></a>27.2 核心概念</h3><h5 id="27-2-1-集群组件"><a href="#27-2-1-集群组件" class="headerlink" title="27.2.1 集群组件"></a>27.2.1 集群组件</h5><h5 id="27-2-2-资源抽象"><a href="#27-2-2-资源抽象" class="headerlink" title="27.2.2 资源抽象"></a>27.2.2 资源抽象</h5><h5 id="27-2-3-辅助概念"><a href="#27-2-3-辅助概念" class="headerlink" title="27.2.3 辅助概念"></a>27.2.3 辅助概念</h5><h3 id="27-3-快速体验"><a href="#27-3-快速体验" class="headerlink" title="27.3 快速体验"></a>27.3 快速体验</h3><h3 id="27-4-安装部署"><a href="#27-4-安装部署" class="headerlink" title="27.4 安装部署"></a>27.4 安装部署</h3><h3 id="27-5-重要组件"><a href="#27-5-重要组件" class="headerlink" title="27.5 重要组件"></a>27.5 重要组件</h3><h5 id="27-5-1-Etcd"><a href="#27-5-1-Etcd" class="headerlink" title="27.5.1 Etcd"></a>27.5.1 Etcd</h5><h5 id="27-5-2-kube-apiserver"><a href="#27-5-2-kube-apiserver" class="headerlink" title="27.5.2 kube-apiserver"></a>27.5.2 kube-apiserver</h5><h5 id="27-5-3-kube-scheduler"><a href="#27-5-3-kube-scheduler" class="headerlink" title="27.5.3 kube-scheduler"></a>27.5.3 kube-scheduler</h5><h5 id="27-5-4-kube-controller-manager"><a href="#27-5-4-kube-controller-manager" class="headerlink" title="27.5.4 kube-controller-manager"></a>27.5.4 kube-controller-manager</h5><h5 id="27-5-5-kubelet"><a href="#27-5-5-kubelet" class="headerlink" title="27.5.5 kubelet"></a>27.5.5 kubelet</h5><h5 id="27-5-6-kube-proxy"><a href="#27-5-6-kube-proxy" class="headerlink" title="27.5.6 kube-proxy"></a>27.5.6 kube-proxy</h5><h3 id="27-6-使用kubectl"><a href="#27-6-使用kubectl" class="headerlink" title="27.6 使用kubectl"></a>27.6 使用kubectl</h3><h5 id="27-6-1-获取kubectl"><a href="#27-6-1-获取kubectl" class="headerlink" title="27.6.1 获取kubectl"></a>27.6.1 获取kubectl</h5><h5 id="27-6-2-命令格式"><a href="#27-6-2-命令格式" class="headerlink" title="27.6.2 命令格式"></a>27.6.2 命令格式</h5><h5 id="27-6-3-全局参数"><a href="#27-6-3-全局参数" class="headerlink" title="27.6.3 全局参数"></a>27.6.3 全局参数</h5><h5 id="27-6-4-子命令"><a href="#27-6-4-子命令" class="headerlink" title="27.6.4 子命令"></a>27.6.4 子命令</h5><h3 id="27-7-网络设计"><a href="#27-7-网络设计" class="headerlink" title="27.7 网络设计"></a>27.7 网络设计</h3><h3 id="27-8-本章小结"><a href="#27-8-本章小结" class="headerlink" title="27.8 本章小结"></a>27.8 本章小结</h3><hr>
<h1 id="第28章-其他相关项目"><a href="#第28章-其他相关项目" class="headerlink" title="第28章 其他相关项目"></a>第28章 其他相关项目</h1><h3 id="28-1-平台即服务方案"><a href="#28-1-平台即服务方案" class="headerlink" title="28.1 平台即服务方案"></a>28.1 平台即服务方案</h3><h5 id="28-1-1-Deis"><a href="#28-1-1-Deis" class="headerlink" title="28.1.1 Deis"></a>28.1.1 Deis</h5><h5 id="28-1-2-Flynn"><a href="#28-1-2-Flynn" class="headerlink" title="28.1.2 Flynn"></a>28.1.2 Flynn</h5><h3 id="28-2-持续集成平台-Drone"><a href="#28-2-持续集成平台-Drone" class="headerlink" title="28.2 持续集成平台 Drone"></a>28.2 持续集成平台 Drone</h3><h3 id="28-3-容器管理"><a href="#28-3-容器管理" class="headerlink" title="28.3 容器管理"></a>28.3 容器管理</h3><h5 id="28-3-1-Citadel"><a href="#28-3-1-Citadel" class="headerlink" title="28.3.1 Citadel"></a>28.3.1 Citadel</h5><h5 id="28-3-2-Shipyard"><a href="#28-3-2-Shipyard" class="headerlink" title="28.3.2 Shipyard"></a>28.3.2 Shipyard</h5><h5 id="28-3-3-DockerUI"><a href="#28-3-3-DockerUI" class="headerlink" title="28.3.3 DockerUI"></a>28.3.3 DockerUI</h5><h5 id="28-3-4-Panamax"><a href="#28-3-4-Panamax" class="headerlink" title="28.3.4 Panamax"></a>28.3.4 Panamax</h5><h5 id="28-3-5-Seagull"><a href="#28-3-5-Seagull" class="headerlink" title="28.3.5 Seagull"></a>28.3.5 Seagull</h5><h5 id="28-3-6-Dockerboard"><a href="#28-3-6-Dockerboard" class="headerlink" title="28.3.6 Dockerboard"></a>28.3.6 Dockerboard</h5><h3 id="28-4-编程开发"><a href="#28-4-编程开发" class="headerlink" title="28.4 编程开发"></a>28.4 编程开发</h3><h3 id="28-5-网络支持"><a href="#28-5-网络支持" class="headerlink" title="28.5 网络支持"></a>28.5 网络支持</h3><h5 id="28-5-1-pipework"><a href="#28-5-1-pipework" class="headerlink" title="28.5.1 pipework"></a>28.5.1 pipework</h5><h5 id="28-5-2-Flannel"><a href="#28-5-2-Flannel" class="headerlink" title="28.5.2 Flannel"></a>28.5.2 Flannel</h5><h5 id="28-5-3-Weave-Net"><a href="#28-5-3-Weave-Net" class="headerlink" title="28.5.3 Weave Net"></a>28.5.3 Weave Net</h5><h5 id="28-5-4-Calico"><a href="#28-5-4-Calico" class="headerlink" title="28.5.4 Calico"></a>28.5.4 Calico</h5><h3 id="28-6-日志处理"><a href="#28-6-日志处理" class="headerlink" title="28.6 日志处理"></a>28.6 日志处理</h3><h5 id="28-6-1-Docker-Fluentd"><a href="#28-6-1-Docker-Fluentd" class="headerlink" title="28.6.1 Docker-Fluentd"></a>28.6.1 Docker-Fluentd</h5><h5 id="28-6-2-Logspout"><a href="#28-6-2-Logspout" class="headerlink" title="28.6.2 Logspout"></a>28.6.2 Logspout</h5><h5 id="28-6-3-Sematext-agent-docker"><a href="#28-6-3-Sematext-agent-docker" class="headerlink" title="28.6.3 Sematext-agent-docker"></a>28.6.3 Sematext-agent-docker</h5><h3 id="28-7-服务代理工具"><a href="#28-7-服务代理工具" class="headerlink" title="28.7 服务代理工具"></a>28.7 服务代理工具</h3><h5 id="28-7-1-Traefik"><a href="#28-7-1-Traefik" class="headerlink" title="28.7.1 Traefik"></a>28.7.1 Traefik</h5><h5 id="28-7-2-Muguet"><a href="#28-7-2-Muguet" class="headerlink" title="28.7.2 Muguet"></a>28.7.2 Muguet</h5><h5 id="28-7-3-nginx-proxy"><a href="#28-7-3-nginx-proxy" class="headerlink" title="28.7.3 nginx-proxy"></a>28.7.3 nginx-proxy</h5><h3 id="28-8-标准与规范"><a href="#28-8-标准与规范" class="headerlink" title="28.8 标准与规范"></a>28.8 标准与规范</h3><h3 id="28-9-其他项目"><a href="#28-9-其他项目" class="headerlink" title="28.9 其他项目"></a>28.9 其他项目</h3><h5 id="28-9-1-CoreOS"><a href="#28-9-1-CoreOS" class="headerlink" title="28.9.1 CoreOS"></a>28.9.1 CoreOS</h5><h5 id="28-9-2-OpenStack支持"><a href="#28-9-2-OpenStack支持" class="headerlink" title="28.9.2 OpenStack支持"></a>28.9.2 OpenStack支持</h5><h5 id="28-9-3-dockerize"><a href="#28-9-3-dockerize" class="headerlink" title="28.9.3 dockerize"></a>28.9.3 dockerize</h5><h5 id="28-9-4-Unikernel"><a href="#28-9-4-Unikernel" class="headerlink" title="28.9.4 Unikernel"></a>28.9.4 Unikernel</h5><h5 id="28-9-5-容器化的虚拟机"><a href="#28-9-5-容器化的虚拟机" class="headerlink" title="28.9.5 容器化的虚拟机"></a>28.9.5 容器化的虚拟机</h5><h3 id="28-10-本章小结"><a href="#28-10-本章小结" class="headerlink" title="28.10 本章小结"></a>28.10 本章小结</h3><hr>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h3 id="附录A-常见问题总结"><a href="#附录A-常见问题总结" class="headerlink" title="附录A 常见问题总结"></a>附录A 常见问题总结</h3><h3 id="附录B-Docker命令查询"><a href="#附录B-Docker命令查询" class="headerlink" title="附录B Docker命令查询"></a>附录B Docker命令查询</h3><h3 id="附录C-参考资源链接"><a href="#附录C-参考资源链接" class="headerlink" title="附录C 参考资源链接"></a>附录C 参考资源链接</h3>

                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


    <hr />
    <h3>Kommentare:</h3>
    <div id="fb-root"></div>
    <script>
        (function(d, s, id) {
            var js, fjs = d.getElementsByTagName(s)[0];
            if (d.getElementById(id)) return;
            js = d.createElement(s); js.id = id;
            js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=397462077298331";
            fjs.parentNode.insertBefore(js, fjs);
        }(document, 'script', 'facebook-jssdk'));
    </script>

    <div class="fb-comments" data-href="http://www.mamian.net/2017/07/23/《Docker技术入门与实战》读书笔记/index.html" data-num-posts="5" data-width="100%" data-colorscheme="light"></div>


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/mamian" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">© 2016  <a href="http://www.mamian.net/" target="_blank">mamian</a>  All Rights Reserved</p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>