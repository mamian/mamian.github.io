<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="第1章 初识容器与docker1.1 什么是docker
基于Go实现的开源容器项目
Docker可理解为一种轻量级的沙盒。每个容器内运行着一个应用，不同的容器相互隔离，容器之间也可以通过网络互相通信。
容器自身对系统资源的额外需求也十分有限，远低于传统虚拟机。

1.2 为什么要使用docker开">
    

    <!--Author-->
    
        <meta name="author" content="mamian">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="《Docker技术入门与实战》读书笔记"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="马面"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

        <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>《Docker技术入门与实战》读书笔记 - 马面</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    


</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">马面</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives/index.html">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags/index.html">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories/index.html">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/about/index.html">
                            
                                About
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/mamian">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('http://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>《Docker技术入门与实战》读书笔记</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        2017-07-23
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/docker/">#docker</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h1 id="第1章-初识容器与docker"><a href="#第1章-初识容器与docker" class="headerlink" title="第1章 初识容器与docker"></a>第1章 初识容器与docker</h1><h3 id="1-1-什么是docker"><a href="#1-1-什么是docker" class="headerlink" title="1.1 什么是docker"></a>1.1 什么是<a href="https://github.com/docker/docker" target="_blank" rel="external">docker</a></h3><ul>
<li>基于Go实现的开源容器项目</li>
<li>Docker可理解为一种轻量级的沙盒。每个容器内运行着一个应用，不同的容器相互隔离，容器之间也可以通过网络互相通信。</li>
<li>容器自身对系统资源的额外需求也十分有限，远低于传统虚拟机。</li>
</ul>
<h3 id="1-2-为什么要使用docker"><a href="#1-2-为什么要使用docker" class="headerlink" title="1.2 为什么要使用docker"></a>1.2 为什么要使用docker</h3><h5 id="开发和运维中的优势"><a href="#开发和运维中的优势" class="headerlink" title="开发和运维中的优势"></a>开发和运维中的优势</h5><ul>
<li>更快速的交付和部署</li>
<li>更高效的资源利用</li>
<li>更轻松的迁移和扩展</li>
<li>更简单的更新管理</li>
</ul>
<h5 id="与传统虚拟机相比"><a href="#与传统虚拟机相比" class="headerlink" title="与传统虚拟机相比"></a>与传统虚拟机相比</h5><ul>
<li>Docker容器很快，启动和停止可在秒级实现。</li>
<li>Docker对系统资源需求少，一台主机可同时运行数千个Docker容器。</li>
<li>Docker通过类似git设计理念的操作来方便用户获取、分发、更新应用镜像，存储复用，增量更新。</li>
<li>Docker通过 Dockerfile 支持灵活的自动化创建和部署机制，提高工效，使流程标准化。</li>
</ul>
<h3 id="1-3-docker与虚拟化"><a href="#1-3-docker与虚拟化" class="headerlink" title="1.3 docker与虚拟化"></a>1.3 docker与虚拟化</h3><ul>
<li>虚拟化核心为<code>对资源的抽象</code>，目标为在同一个主机上同时运行多个系统或应用，提高资源利用率、降低成本、方便管理、容错容灾。</li>
<li>虚拟化分类<ul>
<li>硬件虚拟化（很少）</li>
<li>软件虚拟化<ul>
<li>应用虚拟化<ul>
<li>模拟设备</li>
<li>wine等软件</li>
</ul>
</li>
<li>平台虚拟化<ul>
<li>完全虚拟化<ul>
<li>虚拟机模拟完整的底层硬件环境和特权指令执行过程，客户操作系统无须修改。如VMware Workstation、VirtualBox。</li>
</ul>
</li>
<li>硬件辅助虚拟化<ul>
<li>利用硬件（如CPU的虚拟化技术Intel-VT、AMD-V）处理敏感指令实现完全虚拟化功能，客户操作系统无须修改。如VMware Workstation、Xen、KVM。</li>
</ul>
</li>
<li>部分虚拟化<ul>
<li>部分硬件资源进行虚拟化，客户操作系统需进行修改。</li>
</ul>
</li>
<li>准虚拟化<ul>
<li>部分硬件接口以软件形式提供给客户机操作系统，客户操作系统需进行修改。如早期的 Xen。</li>
</ul>
</li>
<li><code>操作系统级虚拟化</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Docker容器在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，更轻量级。</li>
</ul>
<hr>
<h1 id="第2章-核心概念与安装配置"><a href="#第2章-核心概念与安装配置" class="headerlink" title="第2章 核心概念与安装配置"></a>第2章 核心概念与安装配置</h1><h3 id="2-1-核心概念"><a href="#2-1-核心概念" class="headerlink" title="2.1 核心概念"></a>2.1 核心概念</h3><ul>
<li>Docker镜像<ul>
<li>Docker镜像是一个<code>只读</code>的模板。</li>
<li>镜像是创建Docker容器的基础。通过版本管理和增量文件系统，Docker提供了十分简单的机制来创建和更新现有镜像。</li>
</ul>
</li>
<li><p>Docker容器</p>
<ul>
<li>Docker利用容器来<code>运行和隔离应用</code>。</li>
<li>容器是从镜像创建的应用运行实例。可以将其启动、开始、停止、删除，容器间彼此隔离、互不可见。</li>
<li>镜像自身是只读的。容器从镜像启动的时候，会在镜像的最上层创建一个<code>可写层</code>。</li>
</ul>
</li>
<li><p>Docker仓库</p>
<ul>
<li>类似于代码仓库，是Docker集中存放镜像文件的场所。</li>
<li><code>仓库注册服务器</code>是仓库的仓库，其上往往存放着多个仓库。</li>
<li>公开仓库、私有仓库。</li>
</ul>
</li>
</ul>
<h3 id="2-2-安装docker"><a href="#2-2-安装docker" class="headerlink" title="2.2 安装docker"></a>2.2 安装docker</h3><ul>
<li>Docker Platform<ul>
<li>支持在桌面系统或云平台安装Docker</li>
</ul>
</li>
<li>DockerHub<ul>
<li>官方云托管服务，提供公有或私有镜像仓库</li>
</ul>
</li>
<li>DockerCloud<ul>
<li>官方容器云服务，可完成容器部署与管理，可完整支持容器化项目，还有CI、CD功能。</li>
</ul>
</li>
<li>Docker DataCenter<ul>
<li>提供企业级的简单安全弹性的容器集群编排和管理。</li>
</ul>
</li>
</ul>
<blockquote>
<p>尽量使用Linux来运行Docker，Linux原生支持。</p>
</blockquote>
<h5 id="2-2-1-Ubuntu环境下安装docker"><a href="#2-2-1-Ubuntu环境下安装docker" class="headerlink" title="2.2.1 Ubuntu环境下安装docker"></a>2.2.1 Ubuntu环境下安装docker</h5><ul>
<li>系统要求：64位、内核&gt;3.10<ul>
<li>查询linux版本：uname -a 或 cat /proc/version</li>
<li>为让docker使用aufs存储，安装linux-image-extra软件包<ul>
<li>sudo apt-get install -y linux-image-extra-$(uname -r)</li>
</ul>
</li>
<li>ubuntu&gt;14.04 LTS</li>
</ul>
</li>
<li>添加镜像源<ul>
<li>安装apt-transport-https以支持https协议的源<ul>
<li>sudo apt-get install -y apt-transport-https</li>
</ul>
</li>
<li>添加源的gpg密钥<ul>
<li>sudo apt-key adv –keyserver hkp://p80.pool.sks-keyservers.net:80 –recv-keys 58118E89F3A912897C070ADBF76221572C52609D</li>
</ul>
</li>
<li>获取当前操作系统代号<ul>
<li>lsb_release -c</li>
<li>14.04 LTS代号为trusty</li>
</ul>
</li>
<li>添加docker官方apt源，通过以下命令创建/etc/apt/sources.list.d/docker.list，并写入源的地址。<ul>
<li>sudo cat &lt;<eof>&gt; /etc/apt/sources.list.d/docker.list<br>deb <a href="https://apt.dockerproject.org/repo" target="_blank" rel="external">https://apt.dockerproject.org/repo</a> ubuntu-trusty main<br>EOF</eof></li>
</ul>
</li>
<li>添加成功后，更新apt软件包缓存<ul>
<li>sudo apt-get update</li>
</ul>
</li>
</ul>
</li>
<li>开始安装docker<ul>
<li>sudo apt-get install -y docker-engine</li>
<li>除手动添加软件源方式安装，也可使用官方脚本自动化安装<ul>
<li>sudo curl -sSL <a href="https://get.docker.com/" target="_blank" rel="external">https://get.docker.com/</a> | sh</li>
</ul>
</li>
<li>安装成功后启动docker<ul>
<li>sudo service docker start</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2-2-2-Centos环境下安装docker"><a href="#2-2-2-Centos环境下安装docker" class="headerlink" title="2.2.2 Centos环境下安装docker"></a>2.2.2 Centos环境下安装docker</h5><ul>
<li><p>添加yum源</p>
<ul>
<li>sudo tee /etc/yum.repos.d/docker.repo &lt;&lt;-‘EOF’<br>[docker]<br>name=Docker Repository<br>baseurl=<a href="https://yum.dockerproject.org/repo/main/centos/$releasever/" target="_blank" rel="external">https://yum.dockerproject.org/repo/main/centos/$releasever/</a><br>enabled=1<br>gpgcheck=1<br>gpgkey=<a href="https://yum.dockerproject.org/gpg" target="_blank" rel="external">https://yum.dockerproject.org/gpg</a><br>EOF</li>
</ul>
</li>
<li><p>更新yum软件源缓存</p>
<ul>
<li>sudo yum update</li>
</ul>
</li>
<li>安装docker-engine<ul>
<li>sudo yum install -y docker-engine</li>
</ul>
</li>
<li>centos7的CentOS_Extras源已内置docker，可直接安装。</li>
</ul>
<h5 id="2-2-3-通过脚本安装"><a href="#2-2-3-通过脚本安装" class="headerlink" title="2.2.3 通过脚本安装"></a>2.2.3 通过脚本安装</h5><ul>
<li>curl -fsSL <a href="https://get.docker.com/" target="_blank" rel="external">https://get.docker.com/</a> | sh<ul>
<li>或 wget -qo- <a href="https://get.docker.com/" target="_blank" rel="external">https://get.docker.com/</a> | sh</li>
</ul>
</li>
<li>安装预发布版<ul>
<li>curl -fsSL <a href="https://test.docker.com/" target="_blank" rel="external">https://test.docker.com/</a> | sh</li>
</ul>
</li>
</ul>
<h5 id="2-2-4-Mac-os环境下安装docker"><a href="#2-2-4-Mac-os环境下安装docker" class="headerlink" title="2.2.4 Mac os环境下安装docker"></a>2.2.4 Mac os环境下安装docker</h5><ul>
<li>略</li>
</ul>
<h5 id="2-2-5-Windows环境下安装docker"><a href="#2-2-5-Windows环境下安装docker" class="headerlink" title="2.2.5 Windows环境下安装docker"></a>2.2.5 Windows环境下安装docker</h5><ul>
<li>略</li>
</ul>
<h3 id="2-3-配置docker服务"><a href="#2-3-配置docker服务" class="headerlink" title="2.3 配置docker服务"></a>2.3 配置docker服务</h3><ul>
<li>将当前用户加入安装中自动创建的docker用户组（避免每次使用docker命令都要sudo）<ul>
<li>sudo usermod -aG docker USER_NAME</li>
<li>退出重新登录生效</li>
</ul>
</li>
<li>docker默认配置文件：<code>/etc/default/docker</code><ul>
<li>修改参数，如让docker服务通过本地2375端口接收来自外部的请求<ul>
<li>DOCKER_OPTS=”$DOCKER_OPTS -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock”</li>
</ul>
</li>
<li>修改后重启docker服务：<ul>
<li>sudo service docker restart</li>
</ul>
</li>
</ul>
</li>
<li>docker服务管理脚本：/etc/init.d/docker<ul>
<li>功能为将docker进程id写入/var/run/docker.pid，并通过ulimit调整系统资源限制。</li>
</ul>
</li>
<li>若通过upstart工具管理服务，则管理服务配置文件为/etc/init/docker.conf</li>
<li>CentOS、Redhat，服务可通过systemd管理<ul>
<li>sudo systemctl start docker.service</li>
</ul>
</li>
<li>如服务异常，可查看docker服务日志<ul>
<li>sudo tail /var/log/upstart/docker.log</li>
</ul>
</li>
<li>重启docker服务后，查看服务是否正常启动<ul>
<li>docker version</li>
</ul>
</li>
</ul>
<h3 id="2-4-推荐实践环境"><a href="#2-4-推荐实践环境" class="headerlink" title="2.4 推荐实践环境"></a>2.4 推荐实践环境</h3><ul>
<li>Ubuntu 14.04.3 LTS</li>
</ul>
<hr>
<h1 id="第3章-使用docker镜像"><a href="#第3章-使用docker镜像" class="headerlink" title="第3章 使用docker镜像"></a>第3章 使用docker镜像</h1><h3 id="3-1-获取镜像"><a href="#3-1-获取镜像" class="headerlink" title="3.1 获取镜像"></a>3.1 获取镜像</h3><ul>
<li>从官方docker hub镜像源下载镜像：<code>docker pull NAME[:TAG]</code><ul>
<li>NAME为境像仓库名，TAG为镜像标签（通常为版本）</li>
<li>获取ubuntu：<code>docker pull ubuntu:14.04</code></li>
<li>不显示指定TAG，默认选择latest标签</li>
</ul>
</li>
<li>从pull过程可知，镜像文件由若干层组成。当不同镜像包含相同的层时，本地仅存一份。</li>
<li>从不同的仓库下载镜像，可能重名。严格的说，镜像仓库名中应添加仓库地址，默认为从docker hub下载，前缀可忽略。<ul>
<li>docker pull registry.hub.docker.com/ubuntu:14.04 即 docker pull ubuntu:14.04</li>
</ul>
</li>
<li>下载镜像后，利用镜像创建容器，在容器中执行bash应用：<code>docker run -it ubuntu:14.04 bash</code>，bash中执行命令：<code>ping localhost</code></li>
</ul>
<h3 id="3-2-查看镜像信息"><a href="#3-2-查看镜像信息" class="headerlink" title="3.2 查看镜像信息"></a>3.2 查看镜像信息</h3><ul>
<li>列出镜像：<code>docker images</code><ul>
<li>镜像大小信息仅表示其逻辑大小，物理占用存储空间会小于各镜像逻辑体积之和。</li>
<li>images子命令选项<ul>
<li>-a, –all=true|false：列出所有镜像文件，默认为否</li>
<li>–digests=true|false：列出镜像数字摘要值，默认为否</li>
<li>-f, –filter=[]：过滤列出的镜像，如dangling=true只显示未被使用的镜像；也可指定带有特定标注的镜像。</li>
<li>–format=”TEMPLATE”：控制输出格式，如.ID代表ID信息，.Repository代表仓库信息。</li>
<li>–no-trunc=true|false：对输出结果中太长部分是否截断，如镜像ID，默认为是。</li>
<li>-q, –quiet=true|false：仅输出ID，默认为否。</li>
</ul>
</li>
<li>更多子命令：<code>man docker-images</code></li>
</ul>
</li>
<li>使用tag命令为本地镜像添加标签：<code>docker tag ubuntu:latest myubuntu:latest</code><ul>
<li>添加标签后，镜像ID并没有改变，只是一个别名。</li>
</ul>
</li>
<li>查看镜像详细信息：<code>docker inspect ubuntu:14.04</code></li>
<li>查看镜像历史(镜像创建过程)：<code>docker history ubuntu:14.04</code></li>
</ul>
<h3 id="3-3-搜寻镜像"><a href="#3-3-搜寻镜像" class="headerlink" title="3.3 搜寻镜像"></a>3.3 搜寻镜像</h3><ul>
<li>搜索远程仓库镜像：<code>docker search TERM</code></li>
<li>子命令<ul>
<li>–automated=true|false：仅显示自动创建的镜像，默认为否</li>
<li>–no-trunc=true|false：输出信息不截断显示，默认为否</li>
<li>-s, –stars=X：仅显示评价为指定星级以上的镜像，默认为0，即输出所有镜像</li>
</ul>
</li>
<li><code>docker search --automated -s 3 nginx</code></li>
<li>默认按星级评价排序</li>
</ul>
<h3 id="3-4-删除镜像"><a href="#3-4-删除镜像" class="headerlink" title="3.4 删除镜像"></a>3.4 删除镜像</h3><ul>
<li>docker rmi IMAGE [IMAGE…]<ul>
<li>IMAGE可以为标签或ID</li>
<li>docker rmi myubuntu:latest</li>
<li>若镜像有多个标签，docker rmi只会删除1个标签，镜像本身还存在；但若镜像只有一个标签，则会删除镜像文件的所有层。</li>
</ul>
</li>
<li>使用镜像ID删除镜像<ul>
<li>docker rmi ID，会先尝试删除镜像所有标签，再删除镜像文件本身。</li>
<li>当有镜像创建的容器存在，镜像文件默认无法删除</li>
<li>强行删除镜像（即使有容器存在）：docker rmi -f ubuntu:14.04</li>
<li>不推荐强行删除镜像，一般先删除镜像的所有容器，再删除镜像。</li>
</ul>
</li>
<li>查看本机上所有容器<ul>
<li>docker ps -a</li>
</ul>
</li>
</ul>
<h3 id="3-5-创建镜像（3种方式）"><a href="#3-5-创建镜像（3种方式）" class="headerlink" title="3.5 创建镜像（3种方式）"></a>3.5 创建镜像（3种方式）</h3><ul>
<li><p>基于已有镜像的容器创建</p>
<ul>
<li>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]<ul>
<li>-a, –author=””：作者</li>
<li>-c, –change=[]：提交时执行Dockerfile指令，包括CMD|ENTRYPOINT|ENV|EXPOSE|LABEL|ONBUILD|USER|VOLUME|WORKDIR等</li>
<li>-m, –message=””：提交消息</li>
<li>-p, –pause=true：提交时暂停容器运行。</li>
</ul>
</li>
<li>创建步骤<ul>
<li>启动容器：docker run -it ubuntu:14.04 /bin/bash</li>
<li>记住容器ID</li>
<li>在容器中进行修改</li>
<li>以容器为基准创建新镜像<ul>
<li>docker commit -m “修改的具体内容” -a “马面” 容器ID test:0.1</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>基于本地模板导入</p>
<ul>
<li>docker import [OPTIONS] file|URL|-[REPOSITORY[:TAG]]</li>
<li><a href="http://openvz.org/Download/templates/precreated" target="_blank" rel="external">OPENVZ模板下载</a></li>
<li>cat ubuntu-14.04-x86_64-minimal.tar.gz | docker import - ubuntu:14.04</li>
</ul>
</li>
<li><p>基于Dockerfile创建</p>
<ul>
<li>略</li>
</ul>
</li>
</ul>
<h3 id="3-6-存出和载入镜像"><a href="#3-6-存出和载入镜像" class="headerlink" title="3.6 存出和载入镜像"></a>3.6 存出和载入镜像</h3><ul>
<li>存出镜像：导出镜像到本地文件<ul>
<li>docker save -o ubuntu_14.04.tar ubuntu:14.04</li>
</ul>
</li>
<li>载入镜像<ul>
<li>docker load –input ubuntu_14.04.tar 或 docker load &lt; ubuntu_14.04.tar</li>
</ul>
</li>
</ul>
<h3 id="3-7-上传镜像"><a href="#3-7-上传镜像" class="headerlink" title="3.7 上传镜像"></a>3.7 上传镜像</h3><ul>
<li>docker push NAME[:TAG] | [REGISTRY_HOST[:REGISTRY_PORT]/]NAME[:TAG]</li>
<li>用户在docker hub网站注册后即可上传自制镜像<ul>
<li>docker tag test:latest user/test:latest</li>
<li>docker push user/test:latest</li>
</ul>
</li>
<li>第1次上传会提示输入登录信息。</li>
</ul>
<h3 id="3-8-本章小结"><a href="#3-8-本章小结" class="headerlink" title="3.8 本章小结"></a>3.8 本章小结</h3><hr>
<h1 id="第4章-操作docker容器"><a href="#第4章-操作docker容器" class="headerlink" title="第4章 操作docker容器"></a>第4章 操作docker容器</h1><ul>
<li>容器为镜像的运行实例，镜像为静态的只读文件，容器有可写文件层。</li>
</ul>
<h3 id="4-1-创建容器"><a href="#4-1-创建容器" class="headerlink" title="4.1 创建容器"></a>4.1 创建容器</h3><h5 id="新建容器"><a href="#新建容器" class="headerlink" title="新建容器"></a>新建容器</h5><ul>
<li>docker create -it ubuntu:latest</li>
<li>create后容器处于停止状态</li>
<li>create命令与容器运行模式相关的选项</li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a, –attach=[]</td>
<td>是否绑定到标准输入、输出和错误  </td>
</tr>
<tr>
<td>-d, – detach=true</td>
<td>false</td>
<td>是否在后台运行容器，默认否  </td>
</tr>
<tr>
<td>–detach-keys=””</td>
<td>从attach模式退出的快捷键</td>
</tr>
<tr>
<td>–entrypoint=””</td>
<td>镜像存在入口命令时，覆盖为新的命令</td>
</tr>
<tr>
<td>–expose=[]</td>
<td>指定容器暴露出来的端口或端口范围</td>
</tr>
<tr>
<td>–group-add=[]</td>
<td>运行容器的用户组</td>
</tr>
<tr>
<td>-i, –interactive=true</td>
<td>false</td>
<td>保持标准输入打开，默认否</td>
</tr>
<tr>
<td>–ipc=””</td>
<td>容器IPC命名空间，可以为其他容器或主机</td>
</tr>
<tr>
<td>–ioslation=”default”</td>
<td>容器使用的隔离机制</td>
</tr>
<tr>
<td>–log-driver=”json-file”</td>
<td>指定容器的日志驱动类型，可以为json-file、syslog、journald、gelf、fluentd、awslogs、splunk、etwlogs、gcplogs或none</td>
</tr>
<tr>
<td>–log-opt=[]</td>
<td>传递给日志驱动的选项</td>
</tr>
<tr>
<td>–net=”bridge”</td>
<td>指定容器网络模式，包括bridge、none、其他容器内网络、host的网络或某个现有网络等</td>
</tr>
<tr>
<td>–net-alias=[]</td>
<td>容器在网络中的别名</td>
</tr>
<tr>
<td>-P, –publish-all=true</td>
<td>false</td>
<td>通过NAT机制将容器标记暴露的端口自动映射到本地主机的监时端口</td>
</tr>
<tr>
<td>-p, –publish=[]</td>
<td>指定如何映射到本地主机端口，如 -p 11234-12234:1234-2234</td>
</tr>
<tr>
<td>–pid=host</td>
<td>容器的pid命名空间</td>
</tr>
<tr>
<td>–userns=””</td>
<td>启动userns-remap时配置用户命名空间的模式</td>
</tr>
<tr>
<td>–uts=host</td>
<td>容器的UTS命名空间</td>
</tr>
<tr>
<td>–restart=”no”</td>
<td>容器重启策略，包括no、on-failure[:max-retry]、always、uniess-stopped等</td>
</tr>
<tr>
<td>–rm=true</td>
<td>false</td>
<td>容器退出后是否自动删除，不能跟-d同时使用</td>
</tr>
<tr>
<td>-t, –tty=true</td>
<td>false</td>
<td>是否分配一个伪终端，默认否</td>
</tr>
<tr>
<td>–tmpfs=[]</td>
<td>挂载临时文件系统到容器</td>
</tr>
<tr>
<td>-v</td>
<td>–volume[=[[HOST-DIR:] CONTAINER-DIR[:OPTIONS]]]</td>
<td>挂载主机上的文件卷到容器内</td>
</tr>
<tr>
<td>–volume-driver=””</td>
<td>挂载文件卷的驱动类型</td>
</tr>
<tr>
<td>–volume-from=[]</td>
<td>从其他容器挂载卷</td>
</tr>
<tr>
<td>-w, –workdir=””</td>
<td>容器内的默认工作目录</td>
</tr>
</tbody>
</table>
<ul>
<li>create命令与容器环境和配置相关的选项</li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>–add-host=[]</td>
<td>在容器内添加一个主机名到IP地址的映射关系（通过/etc/hosts文件）</td>
</tr>
<tr>
<td>–device=[]</td>
<td>映射物理机上的设备到容器内</td>
</tr>
<tr>
<td>–dns-search=[]</td>
<td>DNS搜索域</td>
</tr>
<tr>
<td>–dns-opt=[]</td>
<td>自定义的DNS选项</td>
</tr>
<tr>
<td>–dns=[]</td>
<td>自定义的DNS服务器</td>
</tr>
<tr>
<td>-e, –env=[]</td>
<td>指定容器内环境变量</td>
</tr>
<tr>
<td>–env-file=[]</td>
<td>从文件中读取环境变量到容器内</td>
</tr>
<tr>
<td>-h, –hostname=””</td>
<td>指定容器内的主机名</td>
</tr>
<tr>
<td>–ip=””</td>
<td>指定容器的IPv4地址</td>
</tr>
<tr>
<td>–ip6=””</td>
<td>指定容器的IPv6地址</td>
</tr>
<tr>
<td>–link=[<name or="" id="">:alias]</name></td>
<td>链接到其他容器</td>
</tr>
<tr>
<td>–mac-address=””</td>
<td>指定容器的mac地址</td>
</tr>
<tr>
<td>–name=””</td>
<td>指定容器的别名</td>
</tr>
</tbody>
</table>
<ul>
<li>create命令与容器资源限制和安全保护相关的选项</li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>–blkio-weight=10~100</td>
<td>容器读写块设备的I/O性能权重，默认为0</td>
</tr>
<tr>
<td>–blkio-weight-device=[DEVICE_NAME:WEIGHT]</td>
<td>指定各个块设备的I/O性能权重</td>
</tr>
<tr>
<td>–cpu-shares=0</td>
<td>允许容器使用cpu资源的相对权重，默认一个容器能用满一个核的cpu</td>
</tr>
<tr>
<td>–cap-add=[]</td>
<td>增加容器的Linux指定安全能力</td>
</tr>
<tr>
<td>–cap-drop=[]</td>
<td>移除容器的Linux指定安全能力</td>
</tr>
<tr>
<td>–cgroup-parent=””</td>
<td>容器cgroups限制的创建路径</td>
</tr>
<tr>
<td>–cidfile=””</td>
<td>指定容器的进程ID号写到文件</td>
</tr>
<tr>
<td>–cpu-period=0</td>
<td>限制容器在CFS调度器下的CPU占用时间片</td>
</tr>
<tr>
<td>–cpuset-cpus=””</td>
<td>限制容器能使用哪些CPU核心</td>
</tr>
<tr>
<td>–cpuset-mems=””</td>
<td>NUMA架构下使用哪些核心的内存</td>
</tr>
<tr>
<td>–cpu-quota=0</td>
<td>限制容器在CFS调度器下的CPU配额</td>
</tr>
<tr>
<td>–device-read-bps=[]</td>
<td>挂载设备的读吞吐率（以bps为单位）限制</td>
</tr>
<tr>
<td>–device-write-bps=[]</td>
<td>挂载设备的写吞吐率（以bps为单位）限制</td>
</tr>
<tr>
<td>–device-read-iops=[]</td>
<td>挂载设备的读速率（以每秒i/o次数为单位）限制</td>
</tr>
<tr>
<td>–device-write-iops=[]</td>
<td>挂载设备的写速率（以每秒i/o次数为单位）限制</td>
</tr>
<tr>
<td>–kernel-memory=””</td>
<td>限制容器使用内核的内存大小，单位可以是b、k、m或g</td>
</tr>
<tr>
<td>-m, –memory=””</td>
<td>限制容器内应用使用的内存，单位可以是b、k、m或g</td>
</tr>
<tr>
<td>–memory-reservation=””</td>
<td>当系统中内存过低时，容器会强制限制内存到给定值，默认情况下等于内存限制值</td>
</tr>
<tr>
<td>–memory-swap=”LIMIT”</td>
<td>限制容器使用内存和交换区的总大小</td>
</tr>
<tr>
<td>–oom-kill-disable=true</td>
<td>false</td>
<td>内存耗尽时是否杀死容器</td>
</tr>
<tr>
<td>–pids-limit=””</td>
<td>限制容器的pid个数</td>
</tr>
<tr>
<td>–privileged=true</td>
<td>false</td>
<td>是否给容器以最高权限，这意味着容器内应用将不受权限下限制，一般不推荐</td>
</tr>
<tr>
<td>–read-only=true</td>
<td>false</td>
<td>是否让容器内的文件系统只读</td>
</tr>
<tr>
<td>–security-opt=[]</td>
<td>指定一些安全参数，包括权限、安全能力、apparmor等</td>
</tr>
<tr>
<td>–stop-signal=SIGTERM</td>
<td>指定停止容器的系统信号</td>
</tr>
<tr>
<td>–shm-size=””</td>
<td>/dev/shm 的大小</td>
</tr>
<tr>
<td>–sig-proxy=true</td>
<td>false</td>
<td>是否代理收到的信号给应用，默认为true，不能代理SIGCHLD、SIGSTOP和SIGKILL信号</td>
</tr>
<tr>
<td>–memory-swappiness=”0~100”</td>
<td>调整容器的内存交换区参数</td>
</tr>
<tr>
<td>-u, –user=””</td>
<td>指定在容器内执行命令的用户信息</td>
</tr>
<tr>
<td>–ulimit=[]</td>
<td>能过ulimit来限制最大文件数、最大进程数等</td>
</tr>
</tbody>
</table>
<ul>
<li>其他重要选项<ul>
<li>-l, –label=[]：以键值对方式指定容器的标签信息</li>
<li>–label-file=[]：从文件中读取标签信息</li>
</ul>
</li>
</ul>
<h5 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h5><ul>
<li>docker start af8f4f922daf</li>
</ul>
<h5 id="新建并启动容器"><a href="#新建并启动容器" class="headerlink" title="新建并启动容器"></a>新建并启动容器</h5><ul>
<li>docker run ubuntu /bin/echo “Hello World!”</li>
<li>等价于 docker create + docker run</li>
<li>启动容器并进入终端<ul>
<li>docker run -it ubuntu:latest /bin/bash</li>
<li>-t选项让docker分配一个伪终端并绑定到容器的标准输入上</li>
<li>-i选项让容器的标准输入保持打开</li>
<li>exit命令退出容器</li>
<li>exit退出后，容器自动处于退出状态</li>
</ul>
</li>
<li>docker run常见错误码<ul>
<li>125：docker daemon执行出错，不支持的docker命令参数</li>
<li>126：所指定命令无法执行，如权限出错</li>
<li>127：容器内命令无法找到</li>
</ul>
</li>
<li>守护态执行<ul>
<li>docker run <code>-d</code> ubuntu /bin/sh -c “while true; do echo hello world; sleep 1; done”</li>
<li>获取容器的输出信息：docker logs CONTAINER_ID</li>
</ul>
</li>
</ul>
<h3 id="4-2-终止容器"><a href="#4-2-终止容器" class="headerlink" title="4.2 终止容器"></a>4.2 终止容器</h3><ul>
<li>docker stop [-t|–time[=10]] [CONTAINER…]<ul>
<li>首先向容器发送SIGTERM信号，等待一段时间后再发送SIGKILL信号终止容器</li>
</ul>
</li>
<li>docker kill命令会直接发送SIGKILL信号强行终止容器</li>
<li>docker容器中应用终结时，容器也会自动停止</li>
<li>查看所有容器ID<ul>
<li>docker ps -qa</li>
</ul>
</li>
<li>重启终止状态的容器<ul>
<li>docker start [CONTAINER]</li>
</ul>
</li>
<li>重启容器<ul>
<li>docker restart [CONTAINER]</li>
</ul>
</li>
</ul>
<h3 id="4-3-进入容器"><a href="#4-3-进入容器" class="headerlink" title="4.3 进入容器"></a>4.3 进入容器</h3><ul>
<li>使用-d参数，容器启动后进入后台，无法查看和操作，若需进入容器操作，可使用官方的attach、exec命令或三方nsenter工具。</li>
</ul>
<h5 id="attach命令"><a href="#attach命令" class="headerlink" title="attach命令"></a>attach命令</h5><ul>
<li>docker attach [–detach-keys[=[]]] [–no-stdin] [–sig-proxy[=true]] CONTAINER<ul>
<li>docker attach CONTAINER</li>
</ul>
</li>
<li>–detach-keys[=[]]：退出attach模式的快捷键，默认CTRL-p、CTRL-q。</li>
<li>–no-stdin=true|false：是否关闭标准输入，默认打开。</li>
<li>–sig-proxy=true|false：是否代理收到的系统信号给应用进程，默认true。</li>
<li>缺点：多个窗口同时使用attach连到同一容器，所有窗口同步显示。</li>
</ul>
<h5 id="exec命令"><a href="#exec命令" class="headerlink" title="exec命令"></a><code>exec命令</code></h5><ul>
<li>docker exec [-d|–detach] [–detach-keys[=[]]] [-i|–interactive] [–privileged] [-t|–tty] [-u|–user[=USER]] CONTAINER COMMAND [ARG…]<ul>
<li>docker exec -it CONTAINER_NAME /bin/bash</li>
<li>it参数保持标准输入打开，并分配一个伪终端</li>
</ul>
</li>
<li>-i, –interactive=true|false：打开标准输入接受用户输入命令，默认false</li>
<li>–privileged=true|false：是否给执行命令以最高权限，默认false</li>
<li>-t, –tty=true|false：分配伪终端，默认false</li>
<li>-u, –user=””：执行命令的用户名或ID</li>
</ul>
<h5 id="nsenter工具"><a href="#nsenter工具" class="headerlink" title="nsenter工具"></a>nsenter工具</h5><ul>
<li>略</li>
</ul>
<h3 id="4-4-删除容器"><a href="#4-4-删除容器" class="headerlink" title="4.4 删除容器"></a>4.4 删除容器</h3><ul>
<li>docker rm [-f|–force] [-l|–link] [-v|–volumes] CONTAINER [CONTAINER…]<ul>
<li>-f, –force=false：是否强行终止并删除运行中的容器</li>
<li>-l, –link=false：删除容器连接，但保留容器</li>
<li>-v, –volumes=false：删除容器挂载的数据卷</li>
</ul>
</li>
<li>docker rm 默认只删除终止或退出状态容器</li>
<li>docker rm -f 直接删除运行中容器，会先发送SIGKILL信号给容器，终止应用，之后强行删除。</li>
</ul>
<h3 id="4-5-导入和导出容器"><a href="#4-5-导入和导出容器" class="headerlink" title="4.5 导入和导出容器"></a>4.5 导入和导出容器</h3><h5 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h5><ul>
<li>导出已创建好的容器到文件，不管容器是否处于运行状态</li>
<li>docker export [-o|–output[=””]] CONTAINER<ul>
<li>-o 指定导出的tar文件，也可通过重定向来实现<h5 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h5></li>
</ul>
</li>
<li>导出的文件通过docker import命令导入变成镜像</li>
<li>docker import [-c|–change[=[]]] [-m|–message[=MESSAGE]] file|URL|-[REPOSITORY[:TAG]]<ul>
<li>docker import XXX.tar - test/ubuntu:v1.0</li>
</ul>
</li>
<li>-c, –change=[]：在导入同时执行对容器进行修改的Dockerfile指令</li>
<li>docker load（镜像存储文件） 与 docker import（容器快照） 相似<ul>
<li>容器快照将丢弃所有历史记录和元数据信息；镜像存储文件将保存完整记录。从容器快照文件导入时可重新指定标签等元数据信息。</li>
</ul>
</li>
</ul>
<h3 id="4-6-本章小结"><a href="#4-6-本章小结" class="headerlink" title="4.6 本章小结"></a>4.6 本章小结</h3><ul>
<li>生产环境，使用容器时在一组容器前引入HA机制，如HAProxy工具来代理容器访问，这样容器故障时，可快速切换到功能正常的容器。</li>
<li>指定合适的容器重启策略，来自动重启退出的容器。</li>
</ul>
<hr>
<h1 id="第5章-访问docker仓库"><a href="#第5章-访问docker仓库" class="headerlink" title="第5章 访问docker仓库"></a>第5章 访问docker仓库</h1><ul>
<li>仓库：存放镜像</li>
<li>注册服务器：存放仓库的具体服务器</li>
<li>1个注册服务器有多个仓库，1个仓库有多个镜像</li>
<li>仓库地址mydocker.com/ubuntu，mydocker.com为注册服务器地址，ubuntu为仓库名</li>
</ul>
<h3 id="5-1-docker-hub公共镜像市场"><a href="#5-1-docker-hub公共镜像市场" class="headerlink" title="5.1 docker hub公共镜像市场"></a>5.1 docker hub公共镜像市场</h3><h5 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h5><ul>
<li>docker login</li>
<li>注册成功后本地生成 .dockercfg 保存用户认证信息。</li>
<li>登录成功后可上传镜像</li>
</ul>
<h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h5><ul>
<li>docker search</li>
<li>docker pull</li>
</ul>
<h5 id="自动创建"><a href="#自动创建" class="headerlink" title="自动创建"></a>自动创建</h5><ul>
<li>镜像内程序需频繁升级，可通过Docker Hub指定跟踪一个目标网站，一旦项目发生新的提交，则自动创建。</li>
<li>自动创建步骤<ul>
<li>登录 Docker Hub ，在目标网站中连接账户到 Docker Hub</li>
<li>在 Docker Hub 中配置一个“自动创建”</li>
<li>选取一个目标网站中的项目（需含Dockerfile）和分支</li>
<li>指定Dockerfile位置，并提交创建</li>
</ul>
</li>
</ul>
<h3 id="5-2-时速云镜像市场"><a href="#5-2-时速云镜像市场" class="headerlink" title="5.2 时速云镜像市场"></a>5.2 时速云镜像市场</h3><ul>
<li>略</li>
</ul>
<h3 id="5-3-搭建本地私有仓库"><a href="#5-3-搭建本地私有仓库" class="headerlink" title="5.3 搭建本地私有仓库"></a>5.3 搭建本地私有仓库</h3><h5 id="使用registry镜像创建私有仓库"><a href="#使用registry镜像创建私有仓库" class="headerlink" title="使用registry镜像创建私有仓库"></a>使用registry镜像创建私有仓库</h5><ul>
<li>通过官方registry镜像来搭建本地私有仓库<ul>
<li>docker run -d -p 5000:5000 registry</li>
</ul>
</li>
<li>默认仓库创建在容器的/tmp/registry下。存放到某目录<ul>
<li>docker run -d -p 5000:5000 -v /mypath/registry:/tmp/registry / registry</li>
</ul>
</li>
</ul>
<h5 id="管理私有仓库"><a href="#管理私有仓库" class="headerlink" title="管理私有仓库"></a>管理私有仓库</h5><ul>
<li>在远程机器a(10.0.2.2:5000)上搭建私有仓库</li>
<li>在本地机器上，对某镜像打tag<ul>
<li>docker tag ubuntu:14.04 10.0.2.2:5000/test</li>
<li>docker tag IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]</li>
</ul>
</li>
<li>上传镜像<ul>
<li>docker push 10.0.2.2:5000/test</li>
</ul>
</li>
<li>下载镜像<ul>
<li>docker pull 10.0.2.2:5000/test</li>
</ul>
</li>
</ul>
<hr>
<h1 id="第6章-docker数据管理"><a href="#第6章-docker数据管理" class="headerlink" title="第6章 docker数据管理"></a>第6章 docker数据管理</h1><ul>
<li>容器管理数据方式<ul>
<li>数据卷：容器内数据直接映射到本地主机环境</li>
<li>数据卷容器：使用特定容器维护数据卷</li>
</ul>
</li>
</ul>
<h3 id="6-1-数据卷"><a href="#6-1-数据卷" class="headerlink" title="6.1 数据卷"></a>6.1 数据卷</h3><ul>
<li>将主机操作系统目录映射进容器，类似linux中的mount操作。</li>
<li>优势<ul>
<li>容器间共享和重用、数据传递</li>
<li>对数据卷内数据修改会立马生效</li>
<li>对数据卷更新不会影响镜像，解耦应用与数据</li>
<li>卷一直存在，直到没有容器使用，可安全缷载</li>
</ul>
</li>
</ul>
<h5 id="容器内创建数据卷"><a href="#容器内创建数据卷" class="headerlink" title="容器内创建数据卷"></a>容器内创建数据卷</h5><ul>
<li>使用training/webapp镜像创建web容器，并创建数据卷挂载到容器的/webapp目录：<ul>
<li>docker run -d -p –name web -v /webapp training/webapp python app.py</li>
</ul>
</li>
</ul>
<h5 id="挂载一个主机目录作为数据卷"><a href="#挂载一个主机目录作为数据卷" class="headerlink" title="挂载一个主机目录作为数据卷"></a>挂载一个主机目录作为数据卷</h5><ul>
<li>加载主机的/src/webapp到容器的/opt/webapp<ul>
<li>docker run -d -p –name web -v /src/webapp:/opt/webapp training/webapp python app.py</li>
</ul>
</li>
<li>docker挂载数据卷的默认权限为rw，可通过ro指定为只读<ul>
<li>docker run -d -p –name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py</li>
</ul>
</li>
</ul>
<h5 id="挂载一个本地主机文件作为数据卷-不推荐"><a href="#挂载一个本地主机文件作为数据卷-不推荐" class="headerlink" title="挂载一个本地主机文件作为数据卷(不推荐)"></a>挂载一个本地主机文件作为数据卷(不推荐)</h5><ul>
<li>docker run –rm -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash</li>
</ul>
<h3 id="6-2-数据卷容器"><a href="#6-2-数据卷容器" class="headerlink" title="6.2 数据卷容器"></a>6.2 数据卷容器</h3><ul>
<li>多容器间共享持续更新的数据，使用数据卷容器较方便。其也是容器，专用来提供数据卷供其他容器挂载。</li>
<li>创建数据卷容器dbdata，并在其中创建一个数据卷挂载到/dbdata<ul>
<li>docker run -it -v /dbdata –name dbdata ubuntu</li>
<li>新建了一个名为dbdata的容器，容器中有个目录/dbdata，创建了数据卷挂载到容器dbdata的/dbdata目录下。</li>
</ul>
</li>
<li>其他容器(如db1、db2)挂载容器dbdata中的数据卷<ul>
<li>docker run -it –volumes-from dbdata –name db1 ubuntu</li>
<li>docker run -it –volumes-from dbdata –name db2 ubuntu</li>
<li>此时db1、db2都挂载同一个数据卷到相同的/dbdata目录。三个容器任何一方在该目录下写，其他容器均可见。</li>
</ul>
</li>
<li>多次使用–volumes-from从多个容器挂载多个数据卷。还可从其他已经挂载了容器卷的容器来挂载数据卷<ul>
<li>docker run -d –name db3 –volumes-from db1 training/postgres</li>
</ul>
</li>
<li>使用–volumes-from所挂载数据卷的容器自身并不需要保持在运行状态。</li>
<li>如删除挂载的容器，数据卷不会自动删除。如需删除数据卷，必须在删除最后一个还挂载着它的容器时显式使用docker rm -v命令来指定同时删除关联的容器。</li>
</ul>
<h3 id="6-3-利用数据卷容器来迁移数据"><a href="#6-3-利用数据卷容器来迁移数据" class="headerlink" title="6.3 利用数据卷容器来迁移数据"></a>6.3 利用数据卷容器来迁移数据</h3><ul>
<li>可利用数据卷容器对其中的数据进行备份、恢复，以实现数据迁移。</li>
</ul>
<h5 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h5><ul>
<li>备份dbdata数据卷容器内的数据卷<ul>
<li>docker run –volumes-from dbdata -v $(pwd):/backup –name worker ubuntu tar cvf /backup/backup.tar /dbdata</li>
<li>首先用ubuntu镜像创建了容器worker</li>
<li>使用 –volumes-from dbdata 让worker容器挂载dbdata容器的数据卷（即dbdata数据卷）</li>
<li>使用 -v $(pwd):/backup 来挂载本地的当前目录到worker容器的/backup目录</li>
<li>worker启动后，使用 tar cvf /backup/backup.tar /dbdata 将/dbdata下内容备份为容器内的 /backup/backup.tar，即宿主机当前目录下的backup.tar</li>
</ul>
</li>
</ul>
<h5 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h5><ul>
<li>创建一个带数据卷的容器dbdata2<ul>
<li>docker run -v /dbdata –name dbdata2 ubuntu /bin/bash</li>
</ul>
</li>
<li>创建另一个新容器，挂载dbdata2容器，并使用untar解压备份文件到所挂载的容器卷中<ul>
<li>docker run –volumes-from dbdata2 -v $(pwd):/backup busybox tar xvf /backup/backup.tar</li>
</ul>
</li>
</ul>
<hr>
<h1 id="第7章-端口映射与容器互联"><a href="#第7章-端口映射与容器互联" class="headerlink" title="第7章 端口映射与容器互联"></a>第7章 端口映射与容器互联</h1><ul>
<li>多容器间协作<ul>
<li>网络</li>
<li><code>映射容器内应用的服务端口到本地宿主主机</code></li>
<li><code>互联机制实现多个容器间通过容器名来快速访问</code></li>
</ul>
</li>
</ul>
<h3 id="7-1-端口映射实现访问容器"><a href="#7-1-端口映射实现访问容器" class="headerlink" title="7.1 端口映射实现访问容器"></a>7.1 端口映射实现访问容器</h3><h5 id="从外部访问容器应用"><a href="#从外部访问容器应用" class="headerlink" title="从外部访问容器应用"></a>从外部访问容器应用</h5><ul>
<li>默认情况，容器外无法通过网络访问容器内应用与服务。</li>
<li>-P 随机映射一个49000~49900端口到内部容器开放的网络端口<ul>
<li>docker run -d -P training/webapp python app.py</li>
<li>查看应用日志：docker logs -f CONTAINER_NAME</li>
</ul>
</li>
<li>-p 指定映射端口，一个指定端口仅可绑定一个容器<ul>
<li>IP:HostPort:ContainerPort</li>
<li>IP::ContainerPort</li>
<li>HostPort:ContainerPort</li>
</ul>
</li>
</ul>
<h5 id="映射所有接口地址"><a href="#映射所有接口地址" class="headerlink" title="映射所有接口地址"></a>映射所有接口地址</h5><ul>
<li>HostPort:ContainerPort将本地5000端口映射到容器5000端口<ul>
<li>docker run -d -p 5000:5000 training/webapp python app.py</li>
<li>默认绑定本地所有接口上的所有地址</li>
</ul>
</li>
<li>docker run -d -p 5000:5000 -p 3000:80 training/webapp python app.py</li>
</ul>
<h5 id="映射到指定地址的指定端口"><a href="#映射到指定地址的指定端口" class="headerlink" title="映射到指定地址的指定端口"></a>映射到指定地址的指定端口</h5><ul>
<li>IP:HostPort:ContainerPort指定映射使用一个特定地址<ul>
<li>docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</li>
</ul>
</li>
</ul>
<h5 id="映射到指定地址的任意端口"><a href="#映射到指定地址的任意端口" class="headerlink" title="映射到指定地址的任意端口"></a>映射到指定地址的任意端口</h5><ul>
<li>IP::ContainerPort绑定localhost任意端口到容器的5000端口，本地主机会自动分配一个端口<ul>
<li>docker run -d -p 127.0.0.1::5000 training/webapp python app.py</li>
</ul>
</li>
<li>使用udp指定udp端口<ul>
<li>docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</li>
</ul>
</li>
</ul>
<h5 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h5><ul>
<li>docker port CONTAINER 5000</li>
<li>容器有自己的内部网络和ip，查看容器具体信息<ul>
<li>docker inspect CONTAINER_ID</li>
</ul>
</li>
</ul>
<h3 id="7-2-互联机制实现便捷互动"><a href="#7-2-互联机制实现便捷互动" class="headerlink" title="7.2 互联机制实现便捷互动"></a>7.2 互联机制实现便捷互动</h3><ul>
<li>容器互联：多容器中应用快速交互。容器间建立连接，通过容器名快速访问，无需指定具体IP。</li>
</ul>
<h5 id="自定义容器命名"><a href="#自定义容器命名" class="headerlink" title="自定义容器命名"></a>自定义容器命名</h5><ul>
<li>创建容器时会有默认名称，但自定义名称：<ul>
<li>好记</li>
<li>使用方便：连接其他容器时（即便重启）可使用容器名</li>
</ul>
</li>
<li>docker run -d -P <code>--name web</code> training/webapp python app.py</li>
<li>查看容器名<ul>
<li>docker inspect -f “{ { .Name } }” CONTAINER_ID</li>
</ul>
</li>
<li>容器名唯一，如已命名web容器，当再次使用web名称时，需先docker rm删除之前的同名容器</li>
<li>容器终止时立即删除容器<ul>
<li>docker run … <code>--rm</code> …</li>
<li>–rm与-d不可同时使用</li>
</ul>
</li>
</ul>
<h5 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h5><ul>
<li>现有容器db：docker run -d –name db training/postgres</li>
<li>创建新容器web，并连接到db容器<ul>
<li>docker run -d -P –name web <code>--link db:db</code> training/webapp python app.py</li>
</ul>
</li>
<li>–link格式：–link name:alias<ul>
<li>name：要连接的容器</li>
<li>alias：这个连接的别名</li>
</ul>
</li>
<li>此时存在2个容器：db，web。容器db的2个name：db、web/db。</li>
<li>docker 相当于在2个互联的容器间创建虚拟通道，无需映射容器端口到宿主机。启动db时并没有使用-p，避免暴露数据库服务端口到外部网络。</li>
<li>docker公开容器连接信息方式<ul>
<li>更新环境变量</li>
<li>更新 /etc/hosts 文件</li>
</ul>
</li>
<li>查看web容器环境变量<ul>
<li>docker run –rm –name web2 –link db:db training/webapp <code>env</code></li>
<li>环境变量中以 DB_开头（即以大写的连接别名开头）的环境变量为 web容器连接db容器使用的。</li>
</ul>
</li>
<li>除环境变量，docker还添加host信息到父容器（web）的 /etc/hosts 文件<ul>
<li>docker run -t -i –rm –link db:db training/webapp /bin/bash</li>
<li>进入父容器后执行：cat /etc/hosts</li>
<li>由hosts文件可知：第1个为web容器自己，第2个为db容器的ip和主机名。</li>
</ul>
</li>
<li>可连接多个子容器到父容器，比如可连接多个web到同一个db容器。</li>
</ul>
<h3 id="7-3-本章小结"><a href="#7-3-本章小结" class="headerlink" title="7.3 本章小结"></a>7.3 本章小结</h3><ul>
<li>生产环境更复杂，包括跨主机或跨数据中心通信，需引入额外机制，如SDN(软件定义网络)、NFV(网络功能虚拟化)</li>
<li>docker使用libnetwork实现跨主机通信</li>
</ul>
<hr>
<h1 id="第8章-使用dockerfile创建镜像"><a href="#第8章-使用dockerfile创建镜像" class="headerlink" title="第8章 使用dockerfile创建镜像"></a>第8章 使用dockerfile创建镜像</h1><h3 id="8-1-基本结构"><a href="#8-1-基本结构" class="headerlink" title="8.1 基本结构"></a>8.1 基本结构</h3><ol>
<li>基础镜像信息</li>
<li>维护者信息</li>
<li>镜像操作指令</li>
<li>容器启动时执行指令</li>
</ol>
<h3 id="8-2-指令说明"><a href="#8-2-指令说明" class="headerlink" title="8.2 指令说明"></a>8.2 指令说明</h3><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>FROM</td>
<td>指定所创建的镜像的基础镜像</td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>指定维护者信息</td>
</tr>
<tr>
<td>RUN</td>
<td>运行命令</td>
</tr>
<tr>
<td>CMD</td>
<td>指定启动容器时默认执行的命令</td>
</tr>
<tr>
<td>LABEL</td>
<td>指定生成镜像的元数据标签信息</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>声明镜像内服务所监听的端口</td>
</tr>
<tr>
<td>ENV</td>
<td>指定环境变量</td>
</tr>
<tr>
<td>ADD</td>
<td>复制指定的<src>路径下的内容到容器的<dest>路径下，<src>可以为URL；如果为tar文件，会自动解压到<dest>路径下</dest></src></dest></src></td>
</tr>
<tr>
<td>COPY</td>
<td>复制本地主机的<src>路径下的内容到镜像中的<dest>路径下；一般情况下推荐使用COPY，而不是ADD</dest></src></td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>指定镜像的默认入口</td>
</tr>
<tr>
<td>VOLUME</td>
<td>创建数据卷挂载点</td>
</tr>
<tr>
<td>USER</td>
<td>指定运行容器时的用户名或UID</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>配置工作目录</td>
</tr>
<tr>
<td>ARG</td>
<td>指定镜像内使用的参数（例如版本号信息等）</td>
</tr>
<tr>
<td>ONBUILD</td>
<td>配置当所创建的镜像作为其他镜像的基础镜像时，所执行的创建操作指令</td>
</tr>
<tr>
<td>STOPSIGNAL</td>
<td>容器退出的信号值</td>
</tr>
<tr>
<td>HEALTHCHECK</td>
<td>如何进行健康检查</td>
</tr>
<tr>
<td>SHELL</td>
<td>指定使用shell时的默认shell类型</td>
</tr>
</tbody>
</table>
<h5 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h5><ul>
<li>所创建镜像的基础镜像</li>
<li>格式： FROM<image>、FROM<image>:<tag>、FROM<image>@<digest></digest></image></tag></image></image></li>
<li>dockerfile第一条指令必为FROM。同一dockerfile中创建多个镜像，可使用多个FROM（每个镜像一次）</li>
</ul>
<h5 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h5><ul>
<li>指定维护者信息</li>
<li>格式：MAINTAINER<name><ul>
<li>MAINTAINER image_creator@docker.com</li>
</ul>
</name></li>
<li>被写入生成镜像的Author属性域中。</li>
</ul>
<h5 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h5><ul>
<li>运行指定命令</li>
<li>格式：RUN<command>、RUN [“executable”,”param1”,”param2”]<ul>
<li>RUN [“executable”,”param1”,”param2”]会被解析为Json数组，必须用双引号；使用exec执行，不会启动shell</li>
<li>RUN<command>默认在shell中运行，即 /bin/sh -c</li>
</ul>
</li>
<li>每条Run指令在当前镜像基础上执行，并提交为新镜像</li>
</ul>
<h5 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h5><ul>
<li>启动容器时默认执行的命令</li>
<li>格式<ul>
<li>CMD [“executable”,”param1”,”param2”]：使用exec执行，推荐使用</li>
<li>CMD command param1 param2：在/bin/sh中执行，提供给需要交互的应用</li>
<li>CMD [“param1”,”param2”]：提供给ENTRYPOINT的默认参数</li>
</ul>
</li>
<li>每个dockerfile只能有一条CMD，若有多条只有最后一条生效</li>
<li>用户启动容器时手动指定了运行命令（run参数），则覆盖CMD。</li>
</ul>
<h5 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h5><ul>
<li>指定生成镜像的元数据标签信息</li>
<li><p>格式：LABEL &lt; key&gt;=&lt; value&gt; &lt; key&gt;=&lt; value&gt; &lt; key&gt;=&lt; value&gt;…</p>
<pre><code>LABLE version=&quot;1.0&quot;
LABEL description=&quot;XXX&quot;
</code></pre></li>
</ul>
<h5 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h5><ul>
<li>镜像内服务所监听端口</li>
<li>格式：EXPOST <port> [<port>…]<ul>
<li>EXPOST 22 80 8443</li>
</ul>
</port></port></li>
<li>仅声明，并不会自动完成端口映射</li>
<li>启动容器时需使用 -P，docker主机会自动分配宿主机的临时端口转发到指定端口；-p可具体指定宿主机的哪个本地端口映射。    </li>
</ul>
<h5 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h5><ul>
<li>指定环境变量，镜像生成过程中会被RUN指令使用，在镜像启动的容器中也会存在。</li>
<li><p>格式：ENV &lt; key&gt; &lt; value&gt;、ENV &lt; key&gt;=&lt; value&gt;…</p>
<pre><code>ENV PG_MAJOR 9.3
RUN XXX
ENV PATH /usr/local/XXX:$PATH
</code></pre></li>
<li>运行时可被覆盖，如docker run –env XXX build_image</li>
</ul>
<h5 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h5><ul>
<li>复制<src>路径下内容到容器的<dest></dest></src></li>
<li>格式：ADD <src> <dest><ul>
<li>src可以是dockerfile所在目录的一个相对路径；也可为URL；或tar文件（tar文件会自动解压到dest下）</li>
<li>dest可为镜像内绝对路径，或相对于工作目录（WORKDIR）的相对路径。</li>
<li>ADD *.c /code</li>
</ul>
</dest></src></li>
</ul>
<h5 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h5><ul>
<li>复制本地主机<src>(为dockerfile所在目录的相对路径、文件或目录)下内容到镜像中的<dest>下。目标路径不存在时自动创建</dest></src></li>
<li>格式：COPY <src> <dest></dest></src></li>
<li>使用本地目录为源目录时,推荐使用COPY</li>
</ul>
<h5 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h5><ul>
<li>指定镜像的默认入口命令，在启动容器时作为根命令执行，所有传入值作为该命令的参数。</li>
<li>格式<ul>
<li>ENTRYPOINT [“executable”,”param1”,”param2”]：exec调用执行</li>
<li>ENTRYPOINT command param1 param2：shell中执行</li>
</ul>
</li>
<li>CMD指令的指定值将作为根命令参数</li>
<li>每个dockerfile中只能有一个ENTRYPOINT，指定多个时仅最后一个生效。</li>
<li>运行时可被–entrypoint覆盖</li>
</ul>
<h5 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h5><ul>
<li>创建数据卷挂载点</li>
<li>格式：VOLUME [“/data”]</li>
<li>可从本地主机或其他容器挂载数据卷，一般用来存放数据库和需要保存的数据</li>
</ul>
<h5 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h5><ul>
<li>指定运行容器时的用户名或UID，后续RUN指令也会使用此用户。</li>
<li>格式：USER daemon</li>
<li>服务无需管理员权限时，可通过此命令指定运行用户，并可在之前创建所需用户<ul>
<li>RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</li>
</ul>
</li>
<li>要临时获取管理员权限可使用gosu或sudo</li>
</ul>
<h5 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h5><ul>
<li>为后续的RUN、CMD、ENTRYPOINT指令配置工作目录。可多个WORKDIR，后续命令如为相对路径，则会基于之前指定的WORKDIR。</li>
<li><p>格式：WORKDIR /path/XXX</p>
<pre><code>WORKDIR /a
WORKDIR b
WORKDIR c
</code></pre><ul>
<li>则最终路径为/a/b/c</li>
</ul>
</li>
</ul>
<h5 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h5><ul>
<li>指定镜像内使用的参数，这些参数在执行docker build命令时才以–build-arg&lt; varname&gt;=&lt; value&gt;格式传入。</li>
<li>格式：ARG&lt; name&gt;[=&lt; default value&gt;]</li>
<li>可用 docker build –build-arg&lt; name&gt;=&lt; value&gt; 来指定参数值。</li>
</ul>
<h5 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h5><ul>
<li>当创建的镜像作为其他镜像的基础镜像时，所执行的创建操作指令。</li>
<li>格式：ONBUILD [INSTRUCTION]</li>
<li><p>如image-A镜像的dockerfile包含</p>
<pre><code>ONBUILD ADD . /app/src
ONBUILD RUN /usr/local/bin/python-build --dir /app/src
</code></pre><ul>
<li>则基于image-A创建新镜像时，新dockerfile中使用FROM image-A，会自动执行如上ONBUILD指令。</li>
</ul>
</li>
<li><p>使用ONBUILD指令的镜像，推荐在标签中注册，如ruby:1.9-onbuild</p>
</li>
</ul>
<h5 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h5><ul>
<li>指定所创建镜像启动的容器，接收退出的信号值</li>
<li>格式：STOPSIGNAL signal</li>
</ul>
<h5 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h5><ul>
<li>配置所启动容器如何进行健康检查</li>
<li>格式<ul>
<li>HEALTHCHECK [OPTIONS] CMD command：根据所执行命令返回值是否为0来判断</li>
<li>HEALTHCHECK NONE：禁止基础镜像中的健康检查</li>
</ul>
</li>
<li>OPTION支持<ul>
<li>–interval=DURATION(默认30s)：多久检查1次</li>
<li>–timeout=DURATION(默认30s)：每次检查等待结果的超时</li>
<li>–retries=N(默认3)：如失败，重试几次才确定失败</li>
</ul>
</li>
</ul>
<h5 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h5><ul>
<li>指定其他命令使用shell时的默认shell类型。</li>
<li>格式：SHELL [“executable”,”parameters”]<ul>
<li>默认：[“/bin/bash”,”-c”]</li>
</ul>
</li>
</ul>
<h3 id="8-3-创建镜像"><a href="#8-3-创建镜像" class="headerlink" title="8.3 创建镜像"></a>8.3 创建镜像</h3><ul>
<li>编写完dockerfile后通过 <code>docker build</code> 来创建镜像。</li>
<li>指定dockerfile路径为/tmp/docker_builder/，且生成镜像标签为build_repo/first_image<ul>
<li>docker build -t build_repo/first_image /tmp/docker_builder/</li>
</ul>
</li>
<li>一般建议放置dockerfile的目录为空目录。docker build将读取指定路径下的dockerfile，并将此路径下所有内容发送给docker服务端。</li>
</ul>
<h3 id="8-4-使用-dockerignore文件"><a href="#8-4-使用-dockerignore文件" class="headerlink" title="8.4 使用.dockerignore文件"></a>8.4 使用.dockerignore文件</h3><ul>
<li>使用.dockerignore来让docker忽略匹配模式路径下的目录和文件。</li>
</ul>
<h3 id="8-5-最佳实践"><a href="#8-5-最佳实践" class="headerlink" title="8.5 最佳实践"></a>8.5 最佳实践</h3><ol>
<li>精减镜像用途：避免大而复杂、多功能的镜像</li>
<li>选用合适的基础镜像：大镜像太臃肿，推荐小巧的debian镜像</li>
<li>提供足够清晰的命令注释和维护者信息：dockerfile文件清晰</li>
<li>正确使用版本号：使用明确版本号而不是latest</li>
<li>减少镜像层数：尽量合并指令（多个RUN合并为一条）可减少层数</li>
<li>及时删除临时文件和缓存文件：执行apt-get后/var/cache/apt下会缓存安装包</li>
<li>提高生成速度：合理用缓存，减少内容目录下文件；或使用.dockerignore</li>
<li>调整合理的指令顺序：开启缓存时，内容不变的指令尽量放前面，可尽量复用</li>
<li>减少外部源的干扰：使用外部资源需指定持久地址并带有版本信息</li>
</ol>
<hr>
<h1 id="第9章-操作系统"><a href="#第9章-操作系统" class="headerlink" title="第9章 操作系统"></a>第9章 操作系统</h1><h3 id="9-1-BusyBox"><a href="#9-1-BusyBox" class="headerlink" title="9.1 BusyBox"></a>9.1 BusyBox</h3><ul>
<li>集成常用linux指令，只有几M大小（2M）。</li>
<li>docker pull busybox:latest</li>
<li>docker run -it busybox</li>
</ul>
<h3 id="9-2-Alpine"><a href="#9-2-Alpine" class="headerlink" title="9.2 Alpine"></a>9.2 Alpine</h3><ul>
<li>面向安全的轻型linux发行版</li>
<li>体积小：5M左右</li>
<li>采用了 musl libc 和 busybox</li>
</ul>
<h5 id="使用官方镜像"><a href="#使用官方镜像" class="headerlink" title="使用官方镜像"></a>使用官方镜像</h5><ul>
<li>docker run alpine echo ‘123’</li>
</ul>
<h5 id="迁移至Alpine基础镜像"><a href="#迁移至Alpine基础镜像" class="headerlink" title="迁移至Alpine基础镜像"></a>迁移至Alpine基础镜像</h5><ul>
<li>大部分docker官方镜像已支持alpine作为基础镜像，很容易进行迁移。<ul>
<li>ubuntu/debian &gt; alpine</li>
<li>python:2.7 &gt; python:2.7-alpine</li>
<li>ruby:2.3 &gt; ruby:2.3-alpine</li>
</ul>
</li>
<li>使用alpine替换ubuntu作基础镜像，需使用apk替换apt工具安装软件。<ul>
<li>apk add –no-cache <package></package></li>
</ul>
</li>
</ul>
<h3 id="9-3-Debian-Ubuntu"><a href="#9-3-Debian-Ubuntu" class="headerlink" title="9.3 Debian/Ubuntu"></a>9.3 Debian/Ubuntu</h3><ul>
<li>docker清除了ubuntu的apt仓库信息<ul>
<li>apt-get update</li>
<li>apt-get install XXX</li>
</ul>
</li>
</ul>
<h3 id="9-4-CentOS-Fedora"><a href="#9-4-CentOS-Fedora" class="headerlink" title="9.4 CentOS/Fedora"></a>9.4 CentOS/Fedora</h3><h3 id="9-5-本章小结"><a href="#9-5-本章小结" class="headerlink" title="9.5 本章小结"></a>9.5 本章小结</h3><ul>
<li>出于安全考虑，几乎所有官方镜像均无SSH服务，无法使用用户名、密码直接登录。</li>
</ul>
<hr>
<h1 id="第10章-为镜像添加SSH服务"><a href="#第10章-为镜像添加SSH服务" class="headerlink" title="第10章 为镜像添加SSH服务"></a>第10章 为镜像添加SSH服务</h1><ul>
<li>使用attach、exec可进入容器内进行操作，但无法远程操作容器。远程需SSH</li>
</ul>
<h3 id="10-1-基于commit命令创建"><a href="#10-1-基于commit命令创建" class="headerlink" title="10.1 基于commit命令创建"></a>10.1 基于commit命令创建</h3><ul>
<li>基于容器创建镜像：docker commit CONTAINER [REPOSITORY[:TAG]]</li>
</ul>
<h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><ul>
<li>docker run -it ubuntu:14.04 /bin/bash</li>
<li>进入容器后执行命令：apt-get update</li>
</ul>
<h5 id="安装和配置SSH服务"><a href="#安装和配置SSH服务" class="headerlink" title="安装和配置SSH服务"></a>安装和配置SSH服务</h5><ul>
<li>容器内执行命令：apt-get install openssh-server -y<ul>
<li>/var/run/sshd 必须存在，不存在则手动创建。</li>
</ul>
</li>
<li>容器内启动SSH服务<ul>
<li>mkdir -p /var/run/sshd</li>
<li>/usr/sbin/sshd -D &amp;</li>
</ul>
</li>
<li>查看容器的22端口（SSH服务默认监听的端口）<ul>
<li>netstat -tunlp</li>
</ul>
</li>
<li>修改SSH服务的安全登录配置，取消 pam 登录限制<ul>
<li>sed -ri ‘s/session required pam_loginuid.so/#session required pam_loginuid.so/g’ /etc/pam.d/sshd</li>
</ul>
</li>
<li>root用户目录下创建.ssh目录，复制需要登录的公钥信息（一般为本地主机用户目录下的.ssh/id_rsa.pub文件，可由ssh-keygen -t rsa命令生成）到authorized_keys文件中<ul>
<li>mkdir root/.ssh</li>
<li>vi /root/.ssh/authorized_keys</li>
</ul>
</li>
<li><p>创建自动启动SSH服务的可执行文件run.sh，并添加可执行权限</p>
<ul>
<li>vi /run.sh</li>
<li>chmod -x run.sh</li>
<li><p>run.sh内容如下</p>
<pre><code>#!/bin/bash
/usr/sbin/sshd -D
</code></pre></li>
</ul>
</li>
<li>退出容器<ul>
<li>exit</li>
</ul>
</li>
</ul>
<h5 id="保存镜像"><a href="#保存镜像" class="headerlink" title="保存镜像"></a>保存镜像</h5><ul>
<li>将所退出的容器用docker commit保存为一个新的sshd:ubuntu镜像<ul>
<li>docker commit fc1XXXX sshd:ubuntu</li>
</ul>
</li>
</ul>
<h5 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h5><ul>
<li>启动容器，添加端口映射10022&gt;22。10022为宿主主机端口，22为容器的SSH服务监听端口<ul>
<li>docker run -p 10022:22 -d sshd:ubuntu /run.sh</li>
</ul>
</li>
<li>其他主机上使用ssh访问10022端口来登录容器<ul>
<li>ssh 192.168.1.200 -p 10022</li>
</ul>
</li>
</ul>
<h3 id="10-2-使用dockerfile创建"><a href="#10-2-使用dockerfile创建" class="headerlink" title="10.2 使用dockerfile创建"></a>10.2 使用dockerfile创建</h3><h5 id="创建工作目录"><a href="#创建工作目录" class="headerlink" title="创建工作目录"></a>创建工作目录</h5><ul>
<li>创建sshd_ubuntu工作目录<ul>
<li>mkdir sshd_ubuntu</li>
</ul>
</li>
<li>创建dockerfile和run.sh<ul>
<li>cd sshd_ubuntu</li>
<li>touch Dockerfile run.sh</li>
</ul>
</li>
</ul>
<h5 id="编写-run-sh-脚本和-authorized-keys-文件"><a href="#编写-run-sh-脚本和-authorized-keys-文件" class="headerlink" title="编写 run.sh 脚本和 authorized_keys 文件"></a>编写 run.sh 脚本和 authorized_keys 文件</h5><ul>
<li><p>run.sh内容</p>
<pre><code>#!/bin/bash
/usr/sbin/sshd -D
</code></pre></li>
<li>宿主机上生成SSH密钥对，创建authorized_keys<ul>
<li>ssh-keygen -t rsa</li>
<li>cat ~/.ssh/id_rsa.pub &gt; authorized_keys</li>
</ul>
</li>
</ul>
<h5 id="编写dockerfile"><a href="#编写dockerfile" class="headerlink" title="编写dockerfile"></a>编写dockerfile</h5><pre><code># 设置继承镜像
FROM ubuntu:14.04

# 提供一些作者的信息
MAINTAINER docker_user (user@docker.com)

# 下面开始运行更新命令
RUN apt-get update

# 安装ssh服务
RUN apt-get install -y openssh-server
RUN mkdir -p /var/run/sshd
RUN mkdir -p /root/.ssh
# 取消pam限制
RUN sed -ri &apos;s/session required pam_loginuid.so/#session required pam_loginuid.so/g&apos; /etc/pam.d/sshd

# 复制配置文件到相应位置，并赋予脚本可执行权限
ADD authorized_keys /root/.ssh/authorized_keys
ADD run.sh /run.sh
RUN chmod 755 /run.sh

# 开放端口
EXPOSE 22

# 设置自启动命令
CMD [&quot;/run.sh&quot;]
</code></pre><h5 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h5><ul>
<li>在sshd_ubuntu目录下，使用docker build创建镜像。命令中的.表示使用当前目录中的dockerfile<ul>
<li>cd sshd_ubuntu</li>
<li>docker build -t sshd:dockerfile .</li>
</ul>
</li>
<li>使用dockerfile创建自定义镜像，docker会删除中间临时创建的层。</li>
</ul>
<h5 id="测试镜像，运行容器"><a href="#测试镜像，运行容器" class="headerlink" title="测试镜像，运行容器"></a>测试镜像，运行容器</h5><ul>
<li>docker run -d -p 10122:22 sshd:dockerfile</li>
<li>ssh 192.168.1.200 -p 10122</li>
</ul>
<hr>
<h1 id="第11章-Web服务与应用"><a href="#第11章-Web服务与应用" class="headerlink" title="第11章 Web服务与应用"></a>第11章 Web服务与应用</h1><ul>
<li>操作简单的镜像使用dockerfile创建；复杂应用（如weblogic）使用commit方式创建。</li>
</ul>
<h3 id="11-1-Apache"><a href="#11-1-Apache" class="headerlink" title="11.1 Apache"></a>11.1 Apache</h3><h5 id="使用官方镜像-1"><a href="#使用官方镜像-1" class="headerlink" title="使用官方镜像"></a>使用官方镜像</h5><ul>
<li><p>编写dockerfile</p>
<pre><code>FROM httpd:2.4
COPY ./public-html /usr/local/apache2/htdocs/
</code></pre></li>
<li>创建public-html目录，创建index.html</li>
<li>构建镜像<ul>
<li>docker build -t apache2-image .</li>
</ul>
</li>
<li>运行镜像<ul>
<li>docker run -it –rm –name apache-container -p 80:80 apacha2-image</li>
</ul>
</li>
<li>不创建镜像，通过映射目录方式运行apache<ul>
<li>docker run -it –rm –name my-apache-app -p 80:80 -v “$PWD”:/usr/local/apache2/htdocs/ httpd:2.4</li>
</ul>
</li>
</ul>
<h5 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h5><ul>
<li>略</li>
</ul>
<h3 id="11-2-Nginx"><a href="#11-2-Nginx" class="headerlink" title="11.2 Nginx"></a>11.2 Nginx</h3><ul>
<li>支持协议：http、https、smtp、pop3、imap</li>
<li>官方镜像：docker run -d -p 80:80 –name webserver nginx</li>
<li>自定义web页面<ul>
<li>docker run –name nginx-container -p 80:80 -v index.html:/usr/share/nginx/html:ro -d nginx</li>
</ul>
</li>
<li><p>dockerfile构建镜像</p>
<pre><code>FROM nginx
COPY ./index.html /usr/share/nginx/html
</code></pre><ul>
<li>docker build -t my-nginx .</li>
<li>docker run –name nginx-container -d my-nginx</li>
</ul>
</li>
</ul>
<h3 id="11-3-Tomcat"><a href="#11-3-Tomcat" class="headerlink" title="11.3 Tomcat"></a>11.3 Tomcat</h3><h5 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h5><ul>
<li>创建dockerfile、run.sh<ul>
<li>mkdir tomcat7_jdk6</li>
<li>cd tomcat7_jdk6</li>
<li>touch Dockerfile run.sh</li>
<li>下载tomcat并解压到tomcat7_jdk6</li>
<li>Dockerfile、run.sh、apache-tomcat-7.0.56 jdk</li>
</ul>
</li>
</ul>
<h5 id="dockerfile文件、脚本文件"><a href="#dockerfile文件、脚本文件" class="headerlink" title="dockerfile文件、脚本文件"></a>dockerfile文件、脚本文件</h5><ul>
<li><p>Dockerfile</p>
<pre><code>FROM sshd:dockerfile
# 设置继承自用户创建的sshd镜像
MAINTAINER docker_user (user@docker.com)
# 下面是一些创建者的基本信息

# 设置环境变量，所有操作都是非交互式的
ENV DEBIAN_FRONTEND noninteractive

# 注意这里要更改系统的时区设置
RUN echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone &amp;&amp; dpkg-reconfigure -f noninteractive tzdata

# 安装跟 tomcat 用户认证相关的软件
RUN apt-get install -yq --no-install-recommends wget pwgen ca-certificates &amp;&amp; apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/*

# 设置 tomcat 的环境变量，若读者有其他环境变量需要设置，也可在此添加
ENV CATALINA_HOME /tomcat
ENV JAVA_HOME /jdk

# 复制 tomcat 和 jdk 文件到镜像中
ADD apache-tomcat-7.0.56 /tomcat
ADD jdk /jdk

ADD create_tomcat_admin_user.sh /create_tomcat_admin_user.sh
ADD run.sh /run.sh
RUN chmod +x /*.sh
RUN chmod +x /tomcat/bin/*.sh

EXPOSE 8080
CMD [&quot;/run.sh&quot;]
</code></pre></li>
<li><p>创建 tomcat 用户和密码脚本文件 create_tomcat_admin_user.sh</p>
<pre><code>#!/bin/bash

if [ -f /.tomcat_admin_created ]; then
    echo &quot;Tomcat &apos;admin&apos; user already created&quot;
    exit 0
fi

#generate password
PASS=${TOMCAT_PASS:-$(pwgen -s 12 1)}
_word=$( [ ${TOMCAT_PASS}] &amp;&amp; echo &quot;preset&quot; || echo &quot;random&quot; )

echo &quot;=&gt; Creating and admin user with a ${_word} password in Tomcat&quot;
sed -i -r &apos;s/&lt;\/tomcat-users&gt;//&apos; ${CATALINA_HOME}/conf/tomcat-users.xml
echo &apos;&lt;role rolename=&quot;manager-gui&quot;/&gt;&apos; &gt;&gt; ${CATALINA_HOME}/conf/tomcat-users.xml
echo &apos;&lt;role rolename=&quot;manager-script&quot;/&gt;&apos; &gt;&gt; ${CATALINA_HOME}/conf/tomcat-users.xml
echo &apos;&lt;role rolename=&quot;manager-jmx&quot;/&gt;&apos; &gt;&gt; ${CATALINA_HOME}/conf/tomcat-users.xml
echo &apos;&lt;role rolename=&quot;admin-gui&quot;/&gt;&apos; &gt;&gt; ${CATALINA_HOME}/conf/tomcat-users.xml
echo &apos;&lt;role rolename=&quot;admin&quot;-script&quot;/&gt;&apos; &gt;&gt; ${CATALINA_HOME}/conf/tomcat-users.xml
echo &quot;&lt;user username=\&quot;admin\&quot; password=\&quot;${PASS}\&quot; roles=\&quot;manager-gui,manager-script,manager-jmx,admin-gui,admin-script\&quot;/&gt;&quot; &gt;&gt; ${CATALINA_HOME}/conf/tomcat-users.xml
echo &apos;&lt;/tomcat-users&gt;&apos; &gt;&gt; ${CATALINA_HOME}/conf/tomcat-users.xml
echo &quot;=&gt; Done!&quot;
touch /.tomcat_admin_created

echo &quot;======================&quot;
echo &quot;You can now configure to this Tomcat server using:&quot;
echo &quot;&quot;
echo &quot;   admin:${PASS}&quot;
echo &quot;&quot;
echo &quot;======================&quot;
</code></pre></li>
<li><p>run.sh</p>
<pre><code>#!/bin/bash

if [ ! -f /.tomcat_admin_created ]; then
    /create_tomcat_admin_user.sh
fi
/usr/sbin/sshd -D &amp; exec ${CATALINA_HOME}/bin/catalina.sh run
</code></pre></li>
</ul>
<h5 id="创建、测试镜像"><a href="#创建、测试镜像" class="headerlink" title="创建、测试镜像"></a>创建、测试镜像</h5><ul>
<li>docker build -t tomcat7:jdk6</li>
<li>docker run -d -P tomcat7:jdk6</li>
<li>获取 tomcat 密码：docker logs CONTAINER_ID</li>
<li>docker ps</li>
<li>可用-v来挂载Tomcat日志文件、程序所在目录、tomcat相关配置。</li>
</ul>
<h3 id="11-4-Jetty"><a href="#11-4-Jetty" class="headerlink" title="11.4 Jetty"></a>11.4 Jetty</h3><ul>
<li>docker run -d jetty<ul>
<li>docker run -d -p 80:8080 -p 443:8443 jetty</li>
</ul>
</li>
<li>container-ip:8080</li>
</ul>
<h3 id="11-5-LAMP"><a href="#11-5-LAMP" class="headerlink" title="11.5 LAMP"></a>11.5 LAMP</h3><h5 id="linode-lamp镜像"><a href="#linode-lamp镜像" class="headerlink" title="linode/lamp镜像"></a>linode/lamp镜像</h5><ul>
<li>docker run -p 80:80 -t -i linode/lamp /bin/bash</li>
<li>进入容器启动apache、mysql<ul>
<li>service apache2 start</li>
<li>service mysql start</li>
</ul>
</li>
</ul>
<h5 id="tutum-lamp镜像"><a href="#tutum-lamp镜像" class="headerlink" title="tutum/lamp镜像"></a>tutum/lamp镜像</h5><ul>
<li>docker run -d -p 80:80 -p 3306:3306 tutum/lamp</li>
</ul>
<h3 id="11-6-CMS"><a href="#11-6-CMS" class="headerlink" title="11.6 CMS"></a>11.6 CMS</h3><h5 id="11-6-1-WordPress"><a href="#11-6-1-WordPress" class="headerlink" title="11.6.1 WordPress"></a>11.6.1 WordPress</h5><ul>
<li>基于 PHP 和 Mysql</li>
<li>使用官方镜像<ul>
<li>下载：docker pull wordpress</li>
<li>创建wordpress容器，连接mysql容器<ul>
<li>docker run –name some-wordpress –link some-mysql:mysql -p 8080:80 -d wordpress</li>
</ul>
</li>
</ul>
</li>
<li><p>使用Compose一键搭建Wordpress应用</p>
<ul>
<li><p>创建docker-compose.yml</p>
<pre><code>wordpress:
    image: wordpress
    links:
        - db:mysql
    ports:
        - 8080:80

db:
    -image: mariadb
    environment:
        MYSQL_ROOT_PASSWORD: example
</code></pre></li>
<li><p>执行：docker-compose up</p>
</li>
<li>如无docker-compose命令，可通过pip install docker-compose在线安装</li>
<li>通过80端口打开wordpress配置页。</li>
</ul>
</li>
</ul>
<h5 id="11-6-2-Ghost"><a href="#11-6-2-Ghost" class="headerlink" title="11.6.2 Ghost"></a>11.6.2 Ghost</h5><ul>
<li>开源博客平台，Javascript编写。</li>
<li>docker run –name ghost-container -d ghost<ul>
<li>默认监听2368端口</li>
<li>docker run –name ghost-container -p 8080:2368 -d ghost</li>
</ul>
</li>
<li>挂载已有的内容到Ghost容器内<ul>
<li>docker run –name some-ghost -v /path/to/ghost/blog:/var/lib/ghost ghost</li>
</ul>
</li>
</ul>
<h3 id="11-7-持续开发与管理"><a href="#11-7-持续开发与管理" class="headerlink" title="11.7 持续开发与管理"></a>11.7 持续开发与管理</h3><ul>
<li>持续集成CI，持续交付CD</li>
</ul>
<h5 id="11-7-1-Jenkins"><a href="#11-7-1-Jenkins" class="headerlink" title="11.7.1 Jenkins"></a>11.7.1 Jenkins</h5><ul>
<li>jenkins官方提供了Docker镜像</li>
<li>宿主机：mkdir jenkins_data</li>
<li>数据持久化<ul>
<li>数据卷机制<ul>
<li>docker run -p 8080:8080 -p 50000:50000 -v /var/jenkins_data:/var/jenkins_home jenkins</li>
</ul>
</li>
<li>数据卷容器<ul>
<li>docker run –name myjenkins -p 8080:8080 -p 50000:50000 -v /var/jenkins_home jenkins</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="11-7-2-Gitlab"><a href="#11-7-2-Gitlab" class="headerlink" title="11.7.2 Gitlab"></a>11.7.2 Gitlab</h5><ul>
<li>gitlab官方提供DockerHub镜像</li>
<li><p>命令</p>
<pre><code>docker run --detach \
    --hostname ip:port \
    --publish 443:443 --publish 80:80 --publish 23:23 \
    --name gitlab \
    --restart always \
    --volume /srv/gitlab/config:/etc/gitlab \
    --volume /srv/gitlab/logs:/var/log/gitlab \
    --volume /srv/gitlab/data:/var/opt/gitlab \
    gitlab/gitlab-ce:latest
</code></pre><ul>
<li>hostname指外网ip或域名，git项目地址即为<a href="http://ip:port/projectname" target="_blank" rel="external">http://ip:port/projectname</a></li>
<li>本地目录/srv/gitlab/*提前创建好</li>
<li>几分钟后gitlab启动成功</li>
</ul>
</li>
</ul>
<h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><ul>
<li>对于程序代码、程序资源目录、日志、数据库文件等需实时更新的数据，一定要通过-v映射到宿主主机的目录，避免数据丢失。</li>
</ul>
<hr>
<h1 id="第12章-数据库应用"><a href="#第12章-数据库应用" class="headerlink" title="第12章 数据库应用"></a>第12章 数据库应用</h1><h3 id="12-1-MySQL"><a href="#12-1-MySQL" class="headerlink" title="12.1 MySQL"></a>12.1 MySQL</h3><ul>
<li>官方镜像<ul>
<li>docker run –name hi-mysql -e MYSQL_ROOT_PASSWORD=123 -d mysql:latest</li>
<li>以上容器名为hi-mysql，密码为123</li>
</ul>
</li>
<li><p>将应用容器连接到mysql容器</p>
<ul>
<li>docker run –name some-app –link some-mysql:mysql -d application-that-uses-mysql</li>
<li>修改mysql配置<ul>
<li>docker run -it –link some-mysql:mysql –rm mysql sh -c ‘exec mysql -h”$MYSQL_PORT_3306_TCP_ADDR” -P”$MYSQL_PORT_3306_TCP_PORT” -uroot -p”$MYSQL_ENV_MYSQL_ROOT_PASSWORD”‘</li>
</ul>
</li>
</ul>
</li>
<li><p>mysql容器作为客户端连接非docker或远程mysql实例</p>
<ul>
<li>docker run -it –rm mysql mysql -hsome.mysql.host -usome-mysql-user -p</li>
</ul>
</li>
</ul>
<h5 id="系统与日志访问"><a href="#系统与日志访问" class="headerlink" title="系统与日志访问"></a>系统与日志访问</h5><ul>
<li>使用docker exec指令调用内部系统bash shell，以访问容器内部系统<ul>
<li>docker exec -it some-mysql bash</li>
</ul>
</li>
<li>查看mysql日志<ul>
<li>docker logs some-mysql</li>
</ul>
</li>
</ul>
<h5 id="使用自定义配置文件"><a href="#使用自定义配置文件" class="headerlink" title="使用自定义配置文件"></a>使用自定义配置文件</h5><ul>
<li>创建cnf配置文件(如/mypath/config-file.cnf)，并挂载至容器的/etc/mysql/conf.d目录<ul>
<li>docker run –name some-mysql -v /mypath:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</li>
</ul>
</li>
<li>新容器启动后会结合使用/etc/mysql/my.cnf和/mypath/config-file.cnf两个配置文件。</li>
</ul>
<h5 id="脱离cnf文件进行配置"><a href="#脱离cnf文件进行配置" class="headerlink" title="脱离cnf文件进行配置"></a>脱离cnf文件进行配置</h5><ul>
<li>很多配置项可通过标签传给mysqld进程，这样用户可脱离cnf对容器进行弹性的定制。</li>
<li>改变表编码为uft8mb4<ul>
<li>docker run –name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag –character-set-server=utf8mb4 –collation-server=utf8mb4_unicode_ci</li>
</ul>
</li>
<li>查看命令<ul>
<li>docker run -it –rm mysql:tag –verbose –help</li>
</ul>
</li>
</ul>
<h3 id="12-2-MongoDB"><a href="#12-2-MongoDB" class="headerlink" title="12.2 MongoDB"></a>12.2 MongoDB</h3><h5 id="12-2-1-使用官方镜像"><a href="#12-2-1-使用官方镜像" class="headerlink" title="12.2.1 使用官方镜像"></a>12.2.1 使用官方镜像</h5><ul>
<li>docker run –name mongo-container -d mongo</li>
<li>进入mongo容器<ul>
<li>docker exec -it CONTAINER_ID sh</li>
<li>启动mongo：mongo</li>
<li>show dbs</li>
<li>db.status()</li>
</ul>
</li>
<li>查看环境变量：容器内执行 env 命令</li>
<li><p>默认端口 27017</p>
</li>
<li><p>连接已创建的 mongodb 容器</p>
<ul>
<li>docker run -it –link mongo-container:db alpine sh</li>
<li>ping db</li>
</ul>
</li>
<li>直接使用 mongo cli 指令<ul>
<li>在宿主机上直接使用 mongodb 镜像，可在 docker run 后加入 entrypoint 指令，即可直接进入 mongo cli 了。</li>
<li>docker run -it –link mongo-container:db –entrypoint mongo mongo –host db</li>
<li>可设置存储引擎：docker run –name mongo-container -d mongo –storageEngine wiredTiger</li>
</ul>
</li>
</ul>
<h5 id="12-2-2-使用自定义Dockerfile"><a href="#12-2-2-使用自定义Dockerfile" class="headerlink" title="12.2.2 使用自定义Dockerfile"></a>12.2.2 使用自定义Dockerfile</h5><ul>
<li><p>创建dockerfile</p>
<pre><code># 设置从用户之前创建的 sshd 镜像继承
FROM sshd
MAINTAINER docker_user (user@docker.com)

RUN apt-get update &amp;&amp; apt-get install -y mongodb pwgen &amp;&amp; apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/*

# 创建 mongodb 存放数据文件的文件夹
RUN mkdir -p /data/db
VOLUME /data/db

ENV AUTH yes

# 添加脚本
ADD run.sh /run.sh
ADD set_mongodb_password.sh /set_mongodb_password.sh
RUN chmod 755 ./*.sh

EXPOSE 27017
EXPOSE 28017

CMD [&quot;/run.sh&quot;]
</code></pre></li>
<li><p>set_mongodb_password.sh：配置数据库的用户名和密码</p>
<pre><code>#!/bin/bash
# 这个脚本主要是用来设置数据库的用户名和密码

# 判断是否已经设置过密码
if [ -f /.mongodb_password_set ]; then
    echo &quot;MongoDB password already set!&quot;
    exit0
fi

/usr/bin/mongod --smallfiles --nojournal &amp;
PASS=${MONGODB_PASS:-$(pwgen -s 12 1)}
_word=$( [ ${MONGODB_PASS}] &amp;&amp; echo &quot;preset&quot; || echo &quot;random&quot; )

RET=1
while [[ RET -ne 0]]; do
    echo &quot;=&gt; Waiting for confirmation of MongoDB service startup&quot;
    sleep 5
    mongo admin --eval &quot;help&quot; &gt;/dev/null 2&gt;&amp;1
    RET=$?
done

# 通过 docker logs + id 可看到下面的输出
echo &quot;=&gt; Creating an admin user with a ${_word} password in MongoDB&quot;
mongo admin --eval &quot;db.addUser({user: &apos;admin&apos;, pwd: &apos;$PASS&apos;, roles: [ &apos;userAdminAnyDatabase&apos;, &apos;dbAdminAnyDatabase&apos;]});&quot;
mongo admin --eval &quot;db.shutdownServer();&quot;

echo &quot;=&gt; Done!&quot;
touch /.mongodb_password_set

echo &quot;===========&quot;
echo &quot;You can now connect to this MongoDB server using:&quot;
echo &quot;&quot;
echo &quot;  mongo admin -u admin -p $PASS --host &lt;host&gt; --port &lt;port&gt;&quot;
echo &quot;&quot;
echo &quot;Please remember to change the above password as soon as possible!&quot;
echo &quot;===========&quot;
</code></pre></li>
<li><p>run.sh：mongodb启动脚本</p>
<pre><code>#!/bin/bash
if [ ! -f /.mongodb_password_set ]; then
    /set_mongodb_password.sh
fi

if [ &quot;$AUTH&quot; == &quot;yes&quot;]; then
# 这里读者可以自己设定 Mongodb 的启动参数
    export mongodb=&apos;/usr/bin/mongod --nojournal --auth --httpinterface --rest&apos;
else
    export mongodb=&apos;/usr/bin/mongod --nojournal --httpinterface --rest&apos;
fi

if [ ! -f /data/db/mongod.lock ];then
    eval $mongodb
else
    export mongodb=$mongodb&apos; --dbpath /data/db&apos;
    rm /data/db/mongod.lock
    mongod --dbpath /data/db --repair &amp;&amp; eval $mongodb
fi
</code></pre></li>
<li>构建镜像<ul>
<li>docker build -t mongodb-image .</li>
</ul>
</li>
<li>启动容器，并分别映射 27017、28017 端口到本地<ul>
<li>docker run -d -p 27017:27017 -p 28017:28017 mongodb</li>
</ul>
</li>
<li>查看默认的admin密码<ul>
<li>docker logs CONTAINER_ID</li>
<li>容器启动时指定密码：docker run -d -p 27017:27017 -p 28017:28017 -e MONGODB_PASS=”mypass” mongodb</li>
<li>不设定密码：docker run -d -p 27017:27017 -p 28017:28017 -e AUTH=no mongodb</li>
</ul>
</li>
</ul>
<h3 id="12-3-Redis"><a href="#12-3-Redis" class="headerlink" title="12.3 Redis"></a>12.3 Redis</h3><ul>
<li>docker run –name redis-container -d redis</li>
<li>容器中启动bash：docker exec -it CONTAINER_ID bash</li>
</ul>
<h5 id="连接redis容器"><a href="#连接redis容器" class="headerlink" title="连接redis容器"></a>连接redis容器</h5><ul>
<li>docker run -it –link redis-container:db alpine sh</li>
<li>进入容器后<ul>
<li>ping db</li>
<li>检测redis服务可用性：nc db 6379</li>
</ul>
</li>
<li>官方镜像自事了redis客户端<ul>
<li>docker run -it –link redis-container:db –entrypoint redis-cli redis -h db</li>
</ul>
</li>
</ul>
<h5 id="使用自定义配置"><a href="#使用自定义配置" class="headerlink" title="使用自定义配置"></a>使用自定义配置</h5><ul>
<li>docker run -v /myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf –name myredis redis redis-server /usr/local/etc/redis/redis.conf</li>
</ul>
<h3 id="12-4-Memcached"><a href="#12-4-Memcached" class="headerlink" title="12.4 Memcached"></a>12.4 Memcached</h3><ul>
<li>docker run –name memcached-container -d memcached</li>
<li>设定 memcached server 内存大小<ul>
<li>docker run –name memcached-container -d memcached memcached -m64</li>
</ul>
</li>
<li>宿主机测试<ul>
<li>telnet 192.168.99.100 11211</li>
</ul>
</li>
</ul>
<h3 id="12-5-CouchDB"><a href="#12-5-CouchDB" class="headerlink" title="12.5 CouchDB"></a>12.5 CouchDB</h3><ul>
<li>面向文档的 nosql 数据库，json格式存数据。兼容 ACID</li>
<li>CouchDB侧重AP(可用性和分区容忍度)；MongoDB侧重CP(一致性和分区容忍度)，Neo4j则提供特有的面向图形的结构。</li>
<li>docker run -d –name couchdb-container couchdb<ul>
<li>默认端口：5984</li>
</ul>
</li>
<li>容器链接：docker run –name couchdb-app –link couchdb-container:couch couchdb</li>
</ul>
<h3 id="12-6-Cassandra"><a href="#12-6-Cassandra" class="headerlink" title="12.6 Cassandra"></a>12.6 Cassandra</h3><ul>
<li>实现容错及无单点故障</li>
<li>引入p2p技术，具备大规模可分区行存储能力。支持 Spart、Storm、Hadoop集成，类似工具有 HBase。</li>
<li>docker run –name my-cassandra -d cassandra:latest</li>
<li>将另一容器的应用与Cassandra容器连接，应用容器需暴露Cassandra需使用的端口（Cassandra默认服务端口为rpc_host:9160；CQL默认本地服务端口为native_transport_host:9042）<ul>
<li>docker run –name my-app –link my-cassandra:cassandra -d app-this-uses-cassandra</li>
</ul>
</li>
</ul>
<h5 id="搭建-cassandra-集群"><a href="#搭建-cassandra-集群" class="headerlink" title="搭建 cassandra 集群"></a>搭建 cassandra 集群</h5><ul>
<li>单机模式（所有实例集中到一台机器）、多机模式（实例分布在多台机器）</li>
<li>如需启动更多实例，需在指令中配置首个实例信息<ul>
<li>docker run –name my-cassandra2 -d -e CASSANDRA_SEEDS=”$(docker inspect –format=’{ { .NetworkSettings.IPAddress } }’ my-cassandra)” cassasndra:latest</li>
<li>my-cassandra即为首个 Cassandra Server 的实例名。docker inspect 用以获取首个实例ip地址。</li>
</ul>
</li>
<li>连接2个cassandra实例<ul>
<li>docker run –name my-cassandra2 -d –link my-cassandra:cassandra cassasndra:latest</li>
</ul>
</li>
<li>多机模式，需通过环境变量配置 Cassandra Server 容器的IP广播地址(-e标签)。如容器1的ip为10.22.22.22，容器2 的ip为10.23.23.23，Gossip端口为 7000<ul>
<li>启动容器1的Cassandra实例<ul>
<li>docker run –name my-cassandra -d -e CASSANDRA_BROADCAST_ADDRESS=10.22.22.22 -p 7000:7000 cassandra:latest</li>
</ul>
</li>
<li>启动容器2的Cassandra实例，同样需暴露 Gossip 端口，并通过环境变量声明容器1的 IP<ul>
<li>docker run –name my-cassandra -d -e CASSANDRA_BROADCAST_ADDRESS=10.23.23.23 -p 7000:7000 -e CASSANDRA_SEEDS=10.22.22.22 cassandra:latest</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="12-7-本章小结"><a href="#12-7-本章小结" class="headerlink" title="12.7 本章小结"></a>12.7 本章小结</h3><ul>
<li>数据库文件映射到宿主主机：一方面减少容器文件系统带来的性能损耗，另一方面实现数据持久化。</li>
</ul>
<hr>
<h1 id="第13章-分布式处理与大数据平台"><a href="#第13章-分布式处理与大数据平台" class="headerlink" title="第13章 分布式处理与大数据平台"></a>第13章 分布式处理与大数据平台</h1><h3 id="13-1-RabbitMQ"><a href="#13-1-RabbitMQ" class="headerlink" title="13.1 RabbitMQ"></a>13.1 RabbitMQ</h3><ul>
<li>支持AMQP的开源消息队列实现，Erlang编写。</li>
<li>客户端：java、python、php、.net、ruby、javascript。</li>
<li>消息发送者与接收者间无须知道彼此的存在。</li>
<li>重要组件<ul>
<li>服务端：Broker包括Exchange、Queue)</li>
<li>客户端：Producer、Consumer</li>
<li>Producer 产生消息，发送给 Exchange，经由 Queue，最终由 Consumer 接收。</li>
</ul>
</li>
<li>RabbitMQ 将数据存储在 Node 中，默认为 hostname。运行容器时指定每个 rabbitmq daemon 运行的主机名，以便管理和维护数据。<ul>
<li>docker run -d –hostname my-rabbit –name some-rabbit rabbitmq:3</li>
</ul>
</li>
<li>使用 rabbitmqctl 工具进行远程管理（或跨容器管理），需设置持久化的 cookie。<ul>
<li>docker run -d –hostname my-rabbit –name some-rabbit -e RABBITMQ_ERLANG_COOKIE=’secret cookie here’ rabbitmq:3</li>
</ul>
</li>
<li>使用 cookie 连接至1个独立的实例<ul>
<li>docker run -it –rm –link some-rabbit:my-rabbit -e RABBITMQ_ERLANG_COOKIE=’secret cookie here’ rabbitmq:3 bash</li>
<li>rabbitmyctl -n rabbit@my-rabbit list_users</li>
<li>使用 RABBITMQ_NODENAME 简化指令<ul>
<li>docker run -it –rm –link some-rabbit:my-rabbit -e RABBITMQ_ERLANG_COOKIE=’secret cookie here’ -e RABBITMQ_NODENAME=rabbit@my-rabbit rabbitmq:3 bash</li>
</ul>
</li>
</ul>
</li>
<li>默认rabbitmq会启动一些管控插件，如 rabbitmq:3-management，通过默认用户名密码及标准管控端口 15672 访问插件。<ul>
<li>docker run -d –hostname my-rabbit –name some-rabbit rabbitmq:3-management</li>
<li><a href="http://container-ip:15672" target="_blank" rel="external">http://container-ip:15672</a></li>
<li>如需从宿主机外访问，可使用 8080 端口<ul>
<li>docker run -d –hostname my-rabbit –name some-rabbit -p 8080:15672 rabbitmq:3-management</li>
</ul>
</li>
</ul>
</li>
<li>修改默认用户名密码<ul>
<li>docker run -d –hostname my-rabbit –name some-rabbit -e RABBITMQ_DEFAULT_USER=user -e RABBITMQ_DEFAULT_PASS=password rabbitmq:3-management</li>
</ul>
</li>
<li>修改默认 vhost<ul>
<li>docker run -d –hostname my-rabbit –name some-rabbit -e RABBITMQ_DEFAULT_VHOST=my_vhost rabbitmq:3-management</li>
</ul>
</li>
<li>连接到 daemon<ul>
<li>docker run –name some-app –link some-rabbit:rabbit -d application-that-uses-rabbitmq</li>
</ul>
</li>
</ul>
<h3 id="13-2-Celery"><a href="#13-2-Celery" class="headerlink" title="13.2 Celery"></a>13.2 Celery</h3><ul>
<li>分布式任务处理系统，专注实时处理的任务队列管理，同时支持任务调度。</li>
<li>基于python实现，可集成 Django、Pyramid、Pylons、Flask、Tornado 等web框架。</li>
<li>Celery 可单机运行，也可多机或跨数据中心运行。</li>
</ul>
<h5 id="使用官方镜像-2"><a href="#使用官方镜像-2" class="headerlink" title="使用官方镜像"></a>使用官方镜像</h5><ul>
<li>启动1个 celery worker，即 RabbitMQ Broker<ul>
<li>docker run –link some-rabbit:rabbit –name some-celery -d celery:latest</li>
<li>检查集群状态<ul>
<li>docker run –link some-rabbit:rabbit –rm celery celery status</li>
</ul>
</li>
</ul>
</li>
<li>启动1个 celery worker，即 Redis Broker<ul>
<li>docker run –link some-redis:redis -e CELERY_BROKER_URL=redis://redis –name some-celery -d celery</li>
<li>检查集群状态<ul>
<li>docker run –link some-redis:redis -e CELERY_BROKER_URL=redis://redis –rm celery celery status</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="使用-Celery-库"><a href="#使用-Celery-库" class="headerlink" title="使用 Celery 库"></a>使用 Celery 库</h5><ul>
<li><p>如用户的web框架已有 Celery 库，则更方便。Python 调用 Celery 示例：</p>
<pre><code>from celery import Celery
app = Celery(&apos;hello&apos;, broker=&apos;amqp://guest@localhost//&apos;)

@app.task
def hello();
    return &apos;hello world&apos;
</code></pre></li>
</ul>
<h3 id="13-3-Hadoop"><a href="#13-3-Hadoop" class="headerlink" title="13.3 Hadoop"></a>13.3 Hadoop</h3><ul>
<li>HDFS：文件系统；YARN：资源管理系统（相当于Linux的进程调度和内存分配模块）；MapReduce：运行在YARN上的应用，负责分布式处理管理。</li>
</ul>
<h5 id="使用官方镜像-3"><a href="#使用官方镜像-3" class="headerlink" title="使用官方镜像"></a>使用官方镜像</h5><ul>
<li>docker run -it sequenceiq/hadoop-docker:2.7.0 /etc/bootstrap.sh -bash</li>
<li>查看namenode日志<ul>
<li>cat /usr/local/hadoop/logs/hadoop-root-namenode-d4e1e9d8f24f.out</li>
</ul>
</li>
</ul>
<h5 id="安装验证（验证-hadoop-是否安装成功）"><a href="#安装验证（验证-hadoop-是否安装成功）" class="headerlink" title="安装验证（验证 hadoop 是否安装成功）"></a>安装验证（验证 hadoop 是否安装成功）</h5><ul>
<li>打开容器bash<ul>
<li>cd /usr/local/hadoop</li>
<li>bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.0.jar grep input output ‘dfs[a-z.]+’</li>
<li>检查输出结果：bin/hdfs dfs -cat output/*</li>
</ul>
</li>
</ul>
<h3 id="13-4-Spark"><a href="#13-4-Spark" class="headerlink" title="13.4 Spark"></a>13.4 Spark</h3><ul>
<li>速度、易用性、复杂分析；基于 Scala。</li>
<li>与 Hadoop 和 Storm 及 MapReduce 技术相比，Spark 支持更灵活的函数定义，处理速度提升1到2个数量级。更多的实用工具：SQL查询、流处理、机器学习、图处理。</li>
<li>三大组件：数据存储(HDFS)、API(Java,Scala,Python)、管理框架(Mesos,YARN)。</li>
</ul>
<h5 id="13-4-1-使用官方镜像"><a href="#13-4-1-使用官方镜像" class="headerlink" title="13.4.1 使用官方镜像"></a>13.4.1 使用官方镜像</h5><ul>
<li>docker pull sequenceiq/spark:1.6.0<ul>
<li>docker build –rm -t sequenceiq/spark:1.6.0</li>
</ul>
</li>
<li>docker run -it -p 8088:8088 -p 8042:8042 -h sanbox sequenceiq/spark:1.6.0 bash<ul>
<li>cat /usr/local/hadoop/logs/hadoop-root-namenode-sanbox.out</li>
</ul>
</li>
</ul>
<h5 id="13-4-2-验证"><a href="#13-4-2-验证" class="headerlink" title="13.4.2 验证"></a>13.4.2 验证</h5><ul>
<li><p>YARN 客户端模式</p>
<ul>
<li><p>客户端模式，SparkContext(驱动程序)运行在客户端进程中，应用的master仅处理来自 YARN 的资源管理请求</p>
<pre><code># 运行spark shell
spark-shell --master yarn-client --driver-memory 1g --executor-memory 1g --executor-cores 1

# 执行以下命令，若返回1000则符合预期
scala&gt; sc.parallelize(1 to 1000).count()
</code></pre></li>
</ul>
</li>
<li><p>YARN 集群模式</p>
<ul>
<li>集群模式，Spark driver驱动运行于应用 master 的进程中，即由 YARN 从集群层面进行管理。</li>
</ul>
</li>
<li><p>容器外访问 Spark</p>
<ul>
<li>设置 YARN_CONF_DIR 环境变量，yarn-remote-client 文件夹内置远程访问的配置信息：export YARN_CONF_DOR=”<code>pwd</code>/yarn-remote-client”</li>
<li>只能使用 root 用户访问 Docker 的 HDFS 环境。当用户从容器集群外使用非 root 用户访问 Spark 环境时，需配置 HADOOP_USER_NAME 环境变量：export HADOOP_USER_NAME=root</li>
</ul>
</li>
</ul>
<h3 id="13-5-Storm"><a href="#13-5-Storm" class="headerlink" title="13.5 Storm"></a>13.5 Storm</h3><ul>
<li>实时流计算框架，Twitter开源，基于 Clojure 语言开发</li>
<li>Storm与Hadoop类似，Hadoop 运行 MapReduce，Storm 运行 topolopy。MapReduce 任务完成即结束，topolopy 则永远等待消息并处理。</li>
</ul>
<h5 id="使用-Compose-搭建-Storm-集群"><a href="#使用-Compose-搭建-Storm-集群" class="headerlink" title="使用 Compose 搭建 Storm 集群"></a>使用 Compose 搭建 Storm 集群</h5><ul>
<li>利用 Docker Compose 模板，可在本地单机 Docker 环境快速搭建 Storm 集群，进行开发测试。</li>
<li>包含的容器<ul>
<li>Zookeeper：Apache Zookeeper 三节点部署。</li>
<li>Nimbus：Storm Nimbus</li>
<li>Ui：Storm UI</li>
<li>Supervisor：Storm Supervisor（一个或多个）</li>
<li>Topology：Topolopy 部署工具。</li>
</ul>
</li>
<li>本地开发测试<ul>
<li>git clone <a href="https://github.com/denverdino/docker-storm.git" target="_blank" rel="external">https://github.com/denverdino/docker-storm.git</a></li>
<li>cd docker-swarm/local</li>
<li>docker-compose build</li>
<li>一键部署一个 Storm 应用：docker-compose up -d</li>
<li>容器启动后，访问容器的 8080 端口打开操作界面。</li>
<li>伸缩 supervisor 数量：docker-compose scale supervisor=3</li>
<li>web 界面中无运行中的topolopy，因为 Docker Compose 只能保证容器启动顺序，无法确保所依赖容器中的应用已完全启动并可被正常访问。再次启动 topolopy 服务来提交更新的拓扑<ul>
<li>docker-compose start topolopy</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="13-6-ElasticSearch"><a href="#13-6-ElasticSearch" class="headerlink" title="13.6 ElasticSearch"></a>13.6 ElasticSearch</h3><ul>
<li>实时分布式数据存储与查询分析，易扩展到上百台服务器，支持 PB 级结构化或非结构化数据。配合 Logstash、Kibana 组件，可快速构建对日志消息的分析平台。</li>
<li>docker run -d elasticsearch<ul>
<li>docker run -d elasticsearch elasticsearch -Des.node.name=”TestNode”</li>
</ul>
</li>
<li>镜像内包含默认配置文件，如使用自定义配置，可使用数据卷，挂载到/usr/share/elasticsearch/config<ul>
<li>docker run -d -v “$PWD/config”:/usr/share/elasticsearch/config elasticsearch</li>
</ul>
</li>
<li>数据持久化<ul>
<li>docker run -d -v “$PWD/esdata”:/usr/share/elasticsearch/data elasticsearch</li>
</ul>
</li>
<li>镜像暴露 9200 9300 端口，9200对外提供API，9300 用于内部通信（心跳、集群内信息同步）</li>
</ul>
<hr>
<h1 id="第14章-编程开发"><a href="#第14章-编程开发" class="headerlink" title="第14章 编程开发"></a>第14章 编程开发</h1><h3 id="14-1-C-C"><a href="#14-1-C-C" class="headerlink" title="14.1 C/C++"></a>14.1 C/C++</h3><ul>
<li>三款 C/C++ 开发工具：GCC、LLVM、Clang</li>
</ul>
<h5 id="14-1-1-GCC"><a href="#14-1-1-GCC" class="headerlink" title="14.1.1 GCC"></a>14.1.1 GCC</h5><ul>
<li>GNU 开发的编译器</li>
<li>GCC 可处理 C/C++、Fortran、Pascal、Objective-C、Java、Ada</li>
<li>将编译指令写入 Dockerfile，再使用此 Dockerfile 构建自定义镜像，最后直接运行此镜像，即可启动程序。</li>
<li><p>Dockerfile</p>
<pre><code>FROM gcc:4.9
COPY . /usr/src/myapp
WORKDIR /usr/src/myapp
RUN gcc -o myapp main.c
CMD [&quot;./myapp&quot;]
</code></pre></li>
<li><p>main.c</p>
<pre><code>#include&lt;stdio.h&gt;

int main(){
    printf(&quot;Hello World!&quot;);
    return 0;
}
</code></pre></li>
<li>docker build -t gcc-image .</li>
<li>docker run -it –rm –name gcc-container gcc-image</li>
<li>如只需编译不需运行<ul>
<li>docker run –rm -v “$(pwd)”:/usr/src/myapp -w /usr/src/myapp gcc gcc -o myapp main.c</li>
<li>此命令将当前目录 “$(pwd)” 挂载到容器的 /usr/src/myapp 目录，并执行 gcc -o myapp myapp.c，GCC 将编译 myapp.c 并将生成的可执行文件输出至 /usr/src/myapp 文件夹。</li>
</ul>
</li>
</ul>
<h5 id="14-1-2-LLVM"><a href="#14-1-2-LLVM" class="headerlink" title="14.1.2 LLVM"></a>14.1.2 LLVM</h5><ul>
<li>docker pull imiell/llvm</li>
</ul>
<h5 id="14-1-3-Clang"><a href="#14-1-3-Clang" class="headerlink" title="14.1.3 Clang"></a>14.1.3 Clang</h5><ul>
<li>Apple 用 C++，基于 LLVM 实现</li>
<li>docker pull bowery/clang</li>
</ul>
<h3 id="14-2-Java"><a href="#14-2-Java" class="headerlink" title="14.2 Java"></a>14.2 Java</h3><h5 id="新建目录，创建-Dockerfile"><a href="#新建目录，创建-Dockerfile" class="headerlink" title="新建目录，创建 Dockerfile"></a>新建目录，创建 Dockerfile</h5><pre><code>FROM java:7
COPY . /usr/src/javaapp
WORKDIR /usr/src/javaapp
RUN javac HelloWorld.java
CMD [&quot;java&quot;, &quot;HelloWorld&quot;]
</code></pre><h5 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h5><ul>
<li>docker build -t java-image .</li>
</ul>
<h5 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h5><ul>
<li>docker run -it –rm –name java-container java-image</li>
<li>如只需在容器中编译Java程序，不需运行<ul>
<li>docker run –rm -v “$(pwd)”:/usr/src/javaapp -w /usr/src/javaapp java:7 javac HelloWorld.java</li>
</ul>
</li>
</ul>
<h3 id="14-3-Python"><a href="#14-3-Python" class="headerlink" title="14.3 Python"></a>14.3 Python</h3><ul>
<li>解释型动态语言，面向对象</li>
</ul>
<h5 id="14-3-1-使用官方的Python镜像"><a href="#14-3-1-使用官方的Python镜像" class="headerlink" title="14.3.1 使用官方的Python镜像"></a>14.3.1 使用官方的Python镜像</h5><ul>
<li><p>创建 Dockerfile</p>
<pre><code>FROM python:3-onbuild
CMD [ &quot;python3.5&quot;, &quot;./py3-sample.py&quot; ]
</code></pre></li>
<li>py3-sample.py 为一段 python 代码</li>
<li>touch requirements.txt</li>
<li>创建镜像：docker build -t py3-image .</li>
<li>docker run -it –rm –name py3-container py3-image<ul>
<li>只运行单个 python 脚本，无需用 Dockerfile 构建镜像，可直接用命令运行官方镜像<ul>
<li>docker run -it –rm –name my-running-script -v “$(pwd)”:/usr/src/myapp -w /usr/src/myapp python:3 python your-daemon-or-script.py</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="14-3-2-使用PyPy"><a href="#14-3-2-使用PyPy" class="headerlink" title="14.3.2 使用PyPy"></a>14.3.2 使用PyPy</h5><ul>
<li>Python 实现的解释器和即时编译工具，通过 JIT 技术可使 Python 运行速度提高近十倍</li>
</ul>
<h3 id="14-4-JavaScript"><a href="#14-4-JavaScript" class="headerlink" title="14.4 JavaScript"></a>14.4 JavaScript</h3><h5 id="创建-Dockerfile"><a href="#创建-Dockerfile" class="headerlink" title="创建 Dockerfile"></a>创建 Dockerfile</h5><pre><code>FROM node:4-onbuild
EXPOSE 8888
</code></pre><h5 id="新建-server-js"><a href="#新建-server-js" class="headerlink" title="新建 server.js"></a>新建 server.js</h5><pre><code>&apos;use strict&apos;;

var connect = require(&apos;connect&apos;);
var serveStatic = require(&apos;serve-static&apos;);

var app = connect();
app.use(&apos;/&apos;, serveStatic(&apos;.&apos;,{&apos;index&apos;:[&apos;index.html&apos;]}));
app.listen(8080);

console.log(&apos;MyApp is ready at http://localhost:8080&apos;);
</code></pre><h5 id="npm-init-命令新建-node-项目必须的-package-json"><a href="#npm-init-命令新建-node-项目必须的-package-json" class="headerlink" title="npm init 命令新建 node 项目必须的 package.json"></a>npm init 命令新建 node 项目必须的 package.json</h5><h5 id="docker-build-t-node-image"><a href="#docker-build-t-node-image" class="headerlink" title="docker build -t node-image ."></a>docker build -t node-image .</h5><h5 id="docker-run-it-P-node-image"><a href="#docker-run-it-P-node-image" class="headerlink" title="docker run -it -P node-image"></a>docker run -it -P node-image</h5><ul>
<li>若只需运行单个 node 脚本的容器，无需 Dockerfile 构建镜像<ul>
<li>docker run -it –rm –name my-running-script -v “$(pwd)”:/usr/src/myapp -w /usr/src/myapp node:0.10 node your-daemon-or-script.js</li>
</ul>
</li>
</ul>
<h3 id="14-5-Go"><a href="#14-5-Go" class="headerlink" title="14.5 Go"></a>14.5 Go</h3><ul>
<li>拥有 C/C++ 的运行和编译效率。</li>
<li>提供轻量级协程，支持大规模并发。</li>
</ul>
<h5 id="14-5-1-搭建并运行Go容器"><a href="#14-5-1-搭建并运行Go容器" class="headerlink" title="14.5.1 搭建并运行Go容器"></a>14.5.1 搭建并运行Go容器</h5><ul>
<li>官方镜像：docker run -it golang /bin/bash</li>
<li>自定义镜像，创建 Dockerfile</li>
<li>Go 项目容器化</li>
</ul>
<h5 id="14-5-2-Beego"><a href="#14-5-2-Beego" class="headerlink" title="14.5.2 Beego"></a>14.5.2 Beego</h5><ul>
<li>Go 应用程序开源框架</li>
<li><p>使用方法</p>
<ul>
<li>go get github.com/astaxie/beego</li>
<li><p>创建 hello.go</p>
<pre><code>package main

import &quot;github.com/astaxie/beego&quot;

func main() {
    beego.Run()
}
</code></pre></li>
<li>编译：go build -o hello hello.go</li>
<li>运行：./hello</li>
</ul>
</li>
</ul>
<h5 id="14-5-3-Gogs-基于Go的Git服务"><a href="#14-5-3-Gogs-基于Go的Git服务" class="headerlink" title="14.5.3 Gogs:基于Go的Git服务"></a>14.5.3 Gogs:基于Go的Git服务</h5><ul>
<li>docker run –rm –name gogs gogs/gogs</li>
<li>停止：docker stop gogs</li>
<li>删除：docker rm gogs</li>
<li>数据持久化：先创建数据文件夹，将其作为数据卷挂载至gogs容器中<ul>
<li>mkdir -p /srv/lxc/gogs/data</li>
<li>docker run -d –name gogs -p 8300:3000 -p 8322:22 -v /srv/lxc/gogs/data:/data gogs/gogs</li>
</ul>
</li>
</ul>
<h3 id="14-6-PHP"><a href="#14-6-PHP" class="headerlink" title="14.6 PHP"></a>14.6 PHP</h3><h3 id="14-7-Ruby"><a href="#14-7-Ruby" class="headerlink" title="14.7 Ruby"></a>14.7 Ruby</h3><h5 id="14-7-1-使用Ruby官方镜像"><a href="#14-7-1-使用Ruby官方镜像" class="headerlink" title="14.7.1 使用Ruby官方镜像"></a>14.7.1 使用Ruby官方镜像</h5><h5 id="14-7-2-JRuby"><a href="#14-7-2-JRuby" class="headerlink" title="14.7.2 JRuby"></a>14.7.2 JRuby</h5><h5 id="14-7-3-Ruby-on-Rails"><a href="#14-7-3-Ruby-on-Rails" class="headerlink" title="14.7.3 Ruby on Rails"></a>14.7.3 Ruby on Rails</h5><h3 id="14-8-Perl"><a href="#14-8-Perl" class="headerlink" title="14.8 Perl"></a>14.8 Perl</h3><h3 id="14-9-R"><a href="#14-9-R" class="headerlink" title="14.9 R"></a>14.9 R</h3><h3 id="14-10-Erlang"><a href="#14-10-Erlang" class="headerlink" title="14.10 Erlang"></a>14.10 Erlang</h3><h3 id="14-11-本章小结"><a href="#14-11-本章小结" class="headerlink" title="14.11 本章小结"></a>14.11 本章小结</h3><hr>
<h1 id="第15章-容器与云服务"><a href="#第15章-容器与云服务" class="headerlink" title="第15章 容器与云服务"></a>第15章 容器与云服务</h1><h3 id="15-1-公有云容器服务"><a href="#15-1-公有云容器服务" class="headerlink" title="15.1 公有云容器服务"></a>15.1 公有云容器服务</h3><h5 id="15-1-1-AWS"><a href="#15-1-1-AWS" class="headerlink" title="15.1.1 AWS"></a>15.1.1 AWS</h5><h5 id="15-1-2-Google-Cloud-Platform"><a href="#15-1-2-Google-Cloud-Platform" class="headerlink" title="15.1.2 Google Cloud Platform"></a>15.1.2 Google Cloud Platform</h5><h5 id="15-1-3-Azure"><a href="#15-1-3-Azure" class="headerlink" title="15.1.3 Azure"></a>15.1.3 Azure</h5><h5 id="15-1-4-腾讯云"><a href="#15-1-4-腾讯云" class="headerlink" title="15.1.4 腾讯云"></a>15.1.4 腾讯云</h5><h5 id="15-1-5-阿里云"><a href="#15-1-5-阿里云" class="headerlink" title="15.1.5 阿里云"></a>15.1.5 阿里云</h5><h5 id="15-1-6-华为云"><a href="#15-1-6-华为云" class="headerlink" title="15.1.6 华为云"></a>15.1.6 华为云</h5><h5 id="15-1-7-UCloud"><a href="#15-1-7-UCloud" class="headerlink" title="15.1.7 UCloud"></a>15.1.7 UCloud</h5><h3 id="15-2-容器云服务"><a href="#15-2-容器云服务" class="headerlink" title="15.2 容器云服务"></a>15.2 容器云服务</h3><h5 id="15-2-1-基本要素与关键特性"><a href="#15-2-1-基本要素与关键特性" class="headerlink" title="15.2.1 基本要素与关键特性"></a>15.2.1 基本要素与关键特性</h5><h5 id="15-2-2-网易蜂巢"><a href="#15-2-2-网易蜂巢" class="headerlink" title="15.2.2 网易蜂巢"></a>15.2.2 网易蜂巢</h5><h5 id="15-2-3-时速云"><a href="#15-2-3-时速云" class="headerlink" title="15.2.3 时速云"></a>15.2.3 时速云</h5><h5 id="15-2-4-Daocloud"><a href="#15-2-4-Daocloud" class="headerlink" title="15.2.4 Daocloud"></a>15.2.4 Daocloud</h5><h5 id="15-2-5-灵雀云"><a href="#15-2-5-灵雀云" class="headerlink" title="15.2.5 灵雀云"></a>15.2.5 灵雀云</h5><h5 id="15-2-6-数人云"><a href="#15-2-6-数人云" class="headerlink" title="15.2.6 数人云"></a>15.2.6 数人云</h5><h3 id="15-3-阿里云容器服务"><a href="#15-3-阿里云容器服务" class="headerlink" title="15.3 阿里云容器服务"></a>15.3 阿里云容器服务</h3><h3 id="15-4-时速云容器平台"><a href="#15-4-时速云容器平台" class="headerlink" title="15.4 时速云容器平台"></a>15.4 时速云容器平台</h3><h3 id="15-5-本章小结"><a href="#15-5-本章小结" class="headerlink" title="15.5 本章小结"></a>15.5 本章小结</h3><hr>
<h1 id="第16章-容器实战思考"><a href="#第16章-容器实战思考" class="headerlink" title="第16章 容器实战思考"></a>第16章 容器实战思考</h1><h3 id="16-1-docker为什么会成功"><a href="#16-1-docker为什么会成功" class="headerlink" title="16.1 docker为什么会成功"></a>16.1 docker为什么会成功</h3><h3 id="16-2-研发人员该如何看容器"><a href="#16-2-研发人员该如何看容器" class="headerlink" title="16.2 研发人员该如何看容器"></a>16.2 研发人员该如何看容器</h3><h3 id="16-3-容器化开发模式"><a href="#16-3-容器化开发模式" class="headerlink" title="16.3 容器化开发模式"></a>16.3 容器化开发模式</h3><h3 id="16-4-容器与生产环境"><a href="#16-4-容器与生产环境" class="headerlink" title="16.4 容器与生产环境"></a>16.4 容器与生产环境</h3><h3 id="16-5-本章小结"><a href="#16-5-本章小结" class="headerlink" title="16.5 本章小结"></a>16.5 本章小结</h3><hr>
<h1 id="第17章-docker核心实现技术"><a href="#第17章-docker核心实现技术" class="headerlink" title="第17章 docker核心实现技术"></a>第17章 docker核心实现技术</h1><ul>
<li>Linux 操作系统命名空间、控制组、联合文件系统、Linux 网络虚拟化支持</li>
</ul>
<h3 id="17-1-基本架构"><a href="#17-1-基本架构" class="headerlink" title="17.1 基本架构"></a>17.1 基本架构</h3><ul>
<li>C/S 架构，客户端和服务端既可运行在一个机器上，也可运行在不同机器上通过 socket 或 restful api 来进行通信。</li>
</ul>
<h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><ul>
<li>Docker Daemon 一般运行在宿主主机后台，作为服务端接受客户请求（创建、运行、分发容器）。</li>
<li>Docker Daemon 模块化设计，通过专门的 Engine 模块来分发管理客户端任务。</li>
<li>Docker 服务端默认监听本地 unix:///var/run/docker.sock 套接字，只允许root或docker用户组成员访问。<ul>
<li>修改监听方式，如监听tcp的1234端口：docker daemon -H 0.0.0.0:1234</li>
</ul>
</li>
<li>Docker 还支持通过 https 认证方式来验证访问。</li>
</ul>
<h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><ul>
<li>客户端默认通过本地 unix:///var/run/docker.sock 套接字向服务端发送命令。若服务端不是监听在默认地址，需客户端执行命令时显示指定服务端地址。<ul>
<li>docker -H tcp://127.0.0.1:1234 version</li>
</ul>
</li>
</ul>
<h5 id="新的架构设计"><a href="#新的架构设计" class="headerlink" title="新的架构设计"></a>新的架构设计</h5><ul>
<li>原架构必须保证 Docker daemon 正常运行，既要管理容器的运行时，也要提供对外api响应。一旦 Docker daemon 不正常，则运行在 Docker 上的容器也无法使用。</li>
<li>新架构将容器运行任务放到一个单独的组件 containerd 中来管理。原对客户端 api 的支持仍在 Docker daemon 。</li>
</ul>
<h3 id="17-2-命名空间"><a href="#17-2-命名空间" class="headerlink" title="17.2 命名空间"></a>17.2 命名空间</h3><ul>
<li>命名空间为linux内核特性，每个容器有自己单独的命名空间。保证容器间互不影响。</li>
<li>操作系统中，内核、文件系统、网络、PID、UID、IPC、内存、硬盘、CPU 均为应用进程直接共享。让进程在彼此隔离的命名空间中运行，彼此不可见。</li>
</ul>
<h5 id="进程命名空间"><a href="#进程命名空间" class="headerlink" title="进程命名空间"></a>进程命名空间</h5><ul>
<li>linux 通过命名空间管理进程号，同一进程在不同命名空间中，看到的进程号不相同。</li>
<li>进程命名空间是父子关系结构，子空间中的进程对父空间可见。新 fork 的进程在父命名空间和子命名空间分别有一个进程号。</li>
</ul>
<h5 id="网络命名空间"><a href="#网络命名空间" class="headerlink" title="网络命名空间"></a>网络命名空间</h5><ul>
<li>通过网络命名空间实现网络隔离。</li>
<li>网络命名空间为进程提供了完全独立的网络协议栈视图，这样每个容器的网络可隔离开<ul>
<li>网络设备接口</li>
<li>IPv4 和 IPv6 协议栈</li>
<li>IP 路由表</li>
<li>防火墙规则</li>
<li>sockets</li>
</ul>
</li>
<li>Docker 采用虚拟网络设备的方式，将不同命名空间的网络设备连接在一起。默认，容器中虚拟网卡将同本地主机上的 docker0 网桥连接在一起</li>
<li>桥接到宿主机 docker0 网桥上的虚拟网口：brctl show</li>
</ul>
<h5 id="IPC命名空间"><a href="#IPC命名空间" class="headerlink" title="IPC命名空间"></a>IPC命名空间</h5><ul>
<li>容器中进程交互采用 linux 常见的进程间交互方法：信号量、消息队列、共享内存。</li>
<li>PIC 命名空间和 IPC 命名空间可组合使用，同一个 IPC 命名空间内的进程彼此可见；不同空间的进程无法交互。</li>
</ul>
<h5 id="挂载命名空间"><a href="#挂载命名空间" class="headerlink" title="挂载命名空间"></a>挂载命名空间</h5><ul>
<li>类似 chroot，将一个进程放到一个特定的目录执行。</li>
<li>挂载命名空间允许不同命名空间的进程看到的文件结构不同，这样每个命名空间中的进程看到的文件目录彼此隔离。</li>
</ul>
<h5 id="UTS命名空间"><a href="#UTS命名空间" class="headerlink" title="UTS命名空间"></a>UTS命名空间</h5><ul>
<li>unix time-sharing system 命名空间允许每个容器拥有独立主机名和域名。</li>
<li>默认 docker 容器的主机名为容器id。</li>
</ul>
<h5 id="用户命名空间"><a href="#用户命名空间" class="headerlink" title="用户命名空间"></a>用户命名空间</h5><ul>
<li>每个容器可有不同的用户和组 id，可在容器内使用特定的内部用户执行程序，而非本地系统上存在的用户。</li>
<li>每个容器内都可有 root 账号，但与宿主机主机不在一个命名空间。</li>
<li>使用隔离的用户命名空间可提高安全性，避免容器内进程获取额外权限。</li>
</ul>
<h3 id="17-3-控制组"><a href="#17-3-控制组" class="headerlink" title="17.3 控制组"></a>17.3 控制组</h3><ul>
<li>控制组为linux内核特性，用于对共享资源进行隔离、限制、审计。</li>
<li>提控容器对内存、CPU、磁盘IO等资源进行限制和计费管理。</li>
<li>控制组提供<ul>
<li>资源限制：将组设置为不超过设定的内存限制。如内存子系统可为进程组设置内存上限，一旦进程组达到上限后再申请内存将 Out of Memory 警告。</li>
<li>优先级：通过优先级让一些组优先得到更多的cpu等资源。</li>
<li>资源审计：统计使用多少资源，如可用cpuacct子系统记录某个进程组使用的cpu时间。</li>
<li>隔离：为组隔离命名空间，一个组不会看到另一个组的进程、网络连接、文件系统。</li>
<li>控制：挂起、恢复、重启</li>
</ul>
</li>
<li>查看Docker组应用的各种限制项<ul>
<li>cd /sys/fs/cgroup/memory/docker</li>
<li>ls</li>
<li>可修改文件值来控制Docker应用资源</li>
</ul>
</li>
<li>进入对应的容器文件夹，可看到对应容器的状态<ul>
<li>cd 42352bb6c</li>
<li>ls</li>
<li>开发容器工具时，往往需要一些容器运行状态数据，可从这里获取</li>
</ul>
</li>
</ul>
<h3 id="17-4-联合文件系统"><a href="#17-4-联合文件系统" class="headerlink" title="17.4 联合文件系统"></a>17.4 联合文件系统</h3><ul>
<li>联合文件系统：轻量级高性能分层文件系统，它支持将文件系统中的修改信息作为一次提交，层层叠加，同时可将不同目录挂载到同一个虚拟文件系统下，应用看到的是挂载的最终结果。</li>
<li>联合文件系统是实现 Docker 镜像的技术基础。Docker 镜像可通过分层来进行继承。</li>
</ul>
<h5 id="Docker-存储"><a href="#Docker-存储" class="headerlink" title="Docker 存储"></a>Docker 存储</h5><ul>
<li>查看镜像由哪些层组成<ul>
<li>docker history image_name</li>
</ul>
</li>
<li>Docker 镜像层不可修改、只读。使用 Docker 镜像启动容器时，将在镜像文件系统的最顶端再挂载一个新的可读写的层给容器。容器中的内容更新将发生在可读写层。<ul>
<li>当所操作对象位于较深的层时，需要先复制到最上层的可读写层。</li>
<li>当数据对象较大时，往往意味着IO性能较差。因此，一般推荐将容器修改的数据通过 volume 方式挂载，而不是直接修改镜像内数据。</li>
<li>对频繁启停Docker容器的情况下，文件系统的 IO 性能也十分关键。</li>
</ul>
</li>
<li>Docker 所有的存储都在 Docker 目录下，Ubuntu 默认路径为/var/lib/docker<ul>
<li>此目录下存储Docker镜像和容器相关的文件和目录，包括：aufs、containers、graph、image、init、linkgraph.db、network、repositories-aufs、swarm、tmp、trust、volumes等。<ul>
<li>aufs保存Docker镜像相关数据和信息。包括 layers、diff 和 mnt 三个子目录。</li>
<li>layers 包含层属性文件，用来保存各个镜像层的元数据</li>
<li>diff 包含层内容子目录，用来保存所有镜像层的内容数据</li>
<li>mnt 下子目录是各容器最终挂载点，所有相关的 AUFS 层在这里挂载到一起，形成最终效果。一个运行中容器的根文件系统就挂载在这下面的子目录上。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="多种文件系统比较"><a href="#多种文件系统比较" class="headerlink" title="多种文件系统比较"></a>多种文件系统比较</h5><ul>
<li>Docker 支持的联合文件系统有：AUFS、OverlayFS、btrfs、vfs、zfs、Device Mapper</li>
<li>AUFS、Device Mapper 应用更广泛。</li>
</ul>
<h3 id="17-5-Linux网络虚拟化"><a href="#17-5-Linux网络虚拟化" class="headerlink" title="17.5 Linux网络虚拟化"></a>17.5 Linux网络虚拟化</h3><ul>
<li>Docker 本地网络实现利用了 Linux 上的网络命名空间和虚拟网络设备（特别是 veth pair）。</li>
</ul>
<h5 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h5><ul>
<li>要实现网络通信，机器至少需要一个网络接口（物理或虚拟），收发数据包。不同子网间通信，还需要额外的路由机制。</li>
<li>Docker 中网络接口默认为虚拟接口，最大优势是转发效率高。Linux通过在内核中进行数据复制来实现虚拟接口之间的数据转发。即发送接口的发送缓存中的数据包直接复制到接收接口的接收缓存中。</li>
<li>Docker 容器网络在本地主机和容器内分别创建一个虚拟接口，彼此连通，称为 veth pair。</li>
</ul>
<h5 id="网络创建过程"><a href="#网络创建过程" class="headerlink" title="网络创建过程"></a>网络创建过程</h5><ul>
<li>创建一对虚拟接口，分别放到本地主机和新容器的命名空间中</li>
<li>本地主机端的虚拟接口，连接到默认的 docker0 网桥或指定网桥上，且有一个以 veth 开头的唯一名字，如 veth1234。</li>
<li>容器端的虚拟接口放在新创建的容器中，修改名字为 eth0。此接口仅在容器的命名空间可见。</li>
<li>从网桥可用地址段中获取一个空闲地址分配给容器的 eth0，并配置默认路由网关为 docker0 网卡的内部接口 docker0 的 ip 地址。</li>
<li>docker run 启动容器时，可通过 –net 参数指定容器的网络配置<ul>
<li>–net=bridge：默认，在 Docker 网桥 docker0 上为容器创建新的网络栈。</li>
<li>–net=none：让 Docker 将新容器放到隔离的网络栈中，但不进行网络配置。</li>
<li>–net=container:NAME_or_ID：新容器与某已存在的容器共享 IP 地址和端口等网络资源，2者进程可直接通过lo环回接口通信。</li>
<li>–net=host：容器使用本地主机网络，此时容器拥有完全的本地主机接口访问权限。容器进程可跟主机其他root进程一样打开低范围的端口，可访问本地网络服务（如D-bus）。甚至可配置主机的网络栈，此选项要特别小心</li>
<li>–net=user_defined_network：用户自行用network命令创建一个网络，此方式将容器连接到指定的已创建网络上去。</li>
</ul>
</li>
</ul>
<h5 id="手动配置网络"><a href="#手动配置网络" class="headerlink" title="手动配置网络"></a>手动配置网络</h5><ul>
<li>使用–net=none后，Docker不对容器网络进行配置，需手动完成配置。<ul>
<li>启动容器，设定–net=none<ul>
<li>docker run -it –rm –net=none base /bin/bash</li>
</ul>
</li>
<li>本地主机中查找容器进程id，并为它创建网络命名空间<ul>
<li>docker inspect -f ‘{ {.State.Pid} }’ CONTAINER_ID</li>
<li>pid=XXX</li>
<li>sudo mkdir -p /var/run/netns</li>
<li>sudo ln -s /proc/$pid/ns/net /var/run/netns/$pid</li>
</ul>
</li>
<li>检查桥接网卡的IP和子网掩码<ul>
<li>ip addr show docker0</li>
</ul>
</li>
<li>创建一对“veth pair”接口A和B，绑定A接口到网桥docker0，并启用<ul>
<li>sudo ip link add A type veth peer name B</li>
<li>sudo brctl addif docker0 A</li>
<li>sudo ip link set A up</li>
</ul>
</li>
<li>将B接口放到容器的网络命名空间，命名为etho，启动它并配置一个可用ip（桥接网段）和默认网关<ul>
<li>sudo ip link set B netns $pid</li>
<li>sudo ip netns exec $pid ip link set dev B name eth0</li>
<li>sudo ip netns exec $pid ip link set eth0 up</li>
<li>sudo ip netns exec $pid ip addr add 172.17.42.99/16 dev eth0</li>
<li>sudo ip netns exec $pid ip route add default via 172.17.42.1</li>
</ul>
</li>
</ul>
</li>
<li>容器终止后，Docker清空容器，容器内网络接口会随网络命名空间一起被清除，A接口也会自动从docker0缷载并清除。</li>
</ul>
<h3 id="17-6-本章小结"><a href="#17-6-本章小结" class="headerlink" title="17.6 本章小结"></a>17.6 本章小结</h3><hr>
<h1 id="第18章-配置私有仓库"><a href="#第18章-配置私有仓库" class="headerlink" title="第18章 配置私有仓库"></a>第18章 配置私有仓库</h1><h3 id="18-1-安装Docker-Registry"><a href="#18-1-安装Docker-Registry" class="headerlink" title="18.1 安装Docker Registry"></a>18.1 安装Docker Registry</h3><h3 id="18-2-配置TLS证书"><a href="#18-2-配置TLS证书" class="headerlink" title="18.2 配置TLS证书"></a>18.2 配置TLS证书</h3><h3 id="18-3-管理访问权限"><a href="#18-3-管理访问权限" class="headerlink" title="18.3 管理访问权限"></a>18.3 管理访问权限</h3><h3 id="18-4-配置Registry"><a href="#18-4-配置Registry" class="headerlink" title="18.4 配置Registry"></a>18.4 配置Registry</h3><h5 id="18-4-1-示例配置"><a href="#18-4-1-示例配置" class="headerlink" title="18.4.1 示例配置"></a>18.4.1 示例配置</h5><h5 id="18-4-2-选项"><a href="#18-4-2-选项" class="headerlink" title="18.4.2 选项"></a>18.4.2 选项</h5><h3 id="18-5-批量管理镜像"><a href="#18-5-批量管理镜像" class="headerlink" title="18.5 批量管理镜像"></a>18.5 批量管理镜像</h3><h3 id="18-6-使用通知系统"><a href="#18-6-使用通知系统" class="headerlink" title="18.6 使用通知系统"></a>18.6 使用通知系统</h3><h5 id="18-6-1-相关配置"><a href="#18-6-1-相关配置" class="headerlink" title="18.6.1 相关配置"></a>18.6.1 相关配置</h5><h5 id="18-6-2-Notification的使用场景"><a href="#18-6-2-Notification的使用场景" class="headerlink" title="18.6.2 Notification的使用场景"></a>18.6.2 Notification的使用场景</h5><h3 id="18-7-本章小结"><a href="#18-7-本章小结" class="headerlink" title="18.7 本章小结"></a>18.7 本章小结</h3><hr>
<h1 id="第19章-安全防护与配置"><a href="#第19章-安全防护与配置" class="headerlink" title="第19章 安全防护与配置"></a>第19章 安全防护与配置</h1><ul>
<li>Docker 安全性依赖于 Linux 系统自身<ul>
<li>Linux 内核的命名空间机制提供的容器隔离安全</li>
<li>Linux 控制组机制对容器资源的控制能力安全</li>
<li>Linux 内核的能力机制所带来的操作权限安全</li>
<li>Docker程序本身的抗攻击性</li>
<li>其他安全增强机制（AppArmor、SELinux）对容器安全性的影响</li>
<li>第三方工具（Docker Bench）对 Docker 环境的安全性进行评估</li>
</ul>
</li>
</ul>
<h3 id="19-1-命名空间隔离的安全"><a href="#19-1-命名空间隔离的安全" class="headerlink" title="19.1 命名空间隔离的安全"></a>19.1 命名空间隔离的安全</h3><ul>
<li>docker run 启动容器，Docker 在后台为容器创建一个独立的命名空间。</li>
<li>命名空间提供了直接的隔离，容器中进程不会被本地主机进程影响。</li>
<li>所有容器实际上通过本地主机的网桥接口(docker0)通信。</li>
<li>与虚拟机相比，命名空间实现的隔离并不绝对。容器中应用可直接访问系统内核和部分系统文件。用户必须保证容器中应用是安全可信的，否则本地系统会受威胁。即必须保证镜像来源和自身可靠。</li>
</ul>
<h3 id="19-2-控制组资源控制的安全"><a href="#19-2-控制组资源控制的安全" class="headerlink" title="19.2 控制组资源控制的安全"></a>19.2 控制组资源控制的安全</h3><ul>
<li>控制组实现资源的审计和限制。</li>
<li>docker run 启动容器，Docker 通过 Linux 相关的调用，在后台为容器创建一个独立的控制组策略集合，该集合将限制容器内应用对资源的消耗。</li>
<li>控制组作用<ul>
<li>各容器可公平分享主机的CPU、内存、磁盘IO等</li>
<li>限制容器对资源占用，当某容器对资源消耗过大，不会影响本地主机系统和其他容器</li>
</ul>
</li>
<li>控制组虽不负责隔离容器间相互访问、处理数据和进程，但防止恶意攻击（特别是DDOS）方面十分有效。</li>
</ul>
<h3 id="19-3-内核能力机制"><a href="#19-3-内核能力机制" class="headerlink" title="19.3 内核能力机制"></a>19.3 内核能力机制</h3><ul>
<li>能力机制为Linux内核特性，可提供细粒度权限访问控制。即可作用于进程，也可作用于文件。<ul>
<li>如某web进程仅需绑定一个小于1024端口的权限，不需root权限。那么只需被授权 net_bing_service 能力即可。</li>
</ul>
</li>
<li>默认，Docker启动的容器被限制只允许使用内核的一部分能力，包括chown、dac_override、fowner、kill、setgid、setuid、setpcap、net_bind_service、net_raw、sys_chroot、mknod、setfcap、audit_write等</li>
<li>通常，服务器上会运行一些特权进程，如ssh、cron、syslogd、硬件管理工具、网络配置工具等。容器与这些进程不同，因为几乎所有特权进程都由容器外的支持系统来进行管理。</li>
<li>攻击者在容器中获取root，也不能获得本地主机较高权限，破坏有限。</li>
<li>不恰当分配内核能力，会导致容器内应用获取破坏本地系统的权限。</li>
<li>默认，Docker采用白名单机制，禁用了必需的一些能力之外的其他权限。<ul>
<li>支持CAP_CHOWN、CAP_DAC_OVERRIDE、CAP_FSETID、CAP_FOWNER、CAP_MKNOD、CAP_NET_RAW、CAP_SETGID、CAP_SETUID、CAP_SETFCAP、CAP_SETPCAP、CAP_NET_BIND_SERVICE、CAP_SYS_CHROOT、CAP_KILL、CAP_AUDIT_WRITE等</li>
<li>用户也可根据需要为 Docker 容器启用额外权限。</li>
</ul>
</li>
</ul>
<h3 id="19-4-Docker服务端的防护"><a href="#19-4-Docker服务端的防护" class="headerlink" title="19.4 Docker服务端的防护"></a>19.4 Docker服务端的防护</h3><ul>
<li>Docker核心为Docker服务端，目前Docker服务的运行需root权限支持。</li>
</ul>
<h3 id="19-5-更多安全特性的使用"><a href="#19-5-更多安全特性的使用" class="headerlink" title="19.5 更多安全特性的使用"></a>19.5 更多安全特性的使用</h3><h3 id="19-6-使用第三方检测工具"><a href="#19-6-使用第三方检测工具" class="headerlink" title="19.6 使用第三方检测工具"></a>19.6 使用第三方检测工具</h3><h5 id="19-6-1-Docker-Bench"><a href="#19-6-1-Docker-Bench" class="headerlink" title="19.6.1 Docker Bench"></a>19.6.1 Docker Bench</h5><h5 id="19-6-2-clair"><a href="#19-6-2-clair" class="headerlink" title="19.6.2 clair"></a>19.6.2 clair</h5><h3 id="19-7-本章小结"><a href="#19-7-本章小结" class="headerlink" title="19.7 本章小结"></a>19.7 本章小结</h3><hr>
<h1 id="第20章-高级网络功能"><a href="#第20章-高级网络功能" class="headerlink" title="第20章 高级网络功能"></a>第20章 高级网络功能</h1><h3 id="20-1-网络启动与配置参数"><a href="#20-1-网络启动与配置参数" class="headerlink" title="20.1 网络启动与配置参数"></a>20.1 网络启动与配置参数</h3><h3 id="20-2-配置容器DNS和主机名"><a href="#20-2-配置容器DNS和主机名" class="headerlink" title="20.2 配置容器DNS和主机名"></a>20.2 配置容器DNS和主机名</h3><h3 id="20-3-容器访问控制"><a href="#20-3-容器访问控制" class="headerlink" title="20.3 容器访问控制"></a>20.3 容器访问控制</h3><h3 id="20-4-映射容器端口到宿主主机的实现"><a href="#20-4-映射容器端口到宿主主机的实现" class="headerlink" title="20.4 映射容器端口到宿主主机的实现"></a>20.4 映射容器端口到宿主主机的实现</h3><h3 id="20-5-配置docker0网桥"><a href="#20-5-配置docker0网桥" class="headerlink" title="20.5 配置docker0网桥"></a>20.5 配置docker0网桥</h3><h3 id="20-6-自定义网桥"><a href="#20-6-自定义网桥" class="headerlink" title="20.6 自定义网桥"></a>20.6 自定义网桥</h3><h3 id="20-7-使用OpenvSwitch网桥"><a href="#20-7-使用OpenvSwitch网桥" class="headerlink" title="20.7 使用OpenvSwitch网桥"></a>20.7 使用OpenvSwitch网桥</h3><h3 id="20-8-创建一个点到点连接"><a href="#20-8-创建一个点到点连接" class="headerlink" title="20.8 创建一个点到点连接"></a>20.8 创建一个点到点连接</h3><h3 id="20-9-本章小结"><a href="#20-9-本章小结" class="headerlink" title="20.9 本章小结"></a>20.9 本章小结</h3><hr>
<h1 id="第21章-libnetwork插件化网络功能"><a href="#第21章-libnetwork插件化网络功能" class="headerlink" title="第21章 libnetwork插件化网络功能"></a>第21章 libnetwork插件化网络功能</h1><h3 id="21-1-容器网络模型"><a href="#21-1-容器网络模型" class="headerlink" title="21.1 容器网络模型"></a>21.1 容器网络模型</h3><h3 id="21-2-docker网络相关命令"><a href="#21-2-docker网络相关命令" class="headerlink" title="21.2 docker网络相关命令"></a>21.2 docker网络相关命令</h3><h3 id="21-3-构建跨主机容器网络"><a href="#21-3-构建跨主机容器网络" class="headerlink" title="21.3 构建跨主机容器网络"></a>21.3 构建跨主机容器网络</h3><h3 id="21-4-本章小结"><a href="#21-4-本章小结" class="headerlink" title="21.4 本章小结"></a>21.4 本章小结</h3><hr>
<h1 id="第22章-Etcd–高可用的键值数据库"><a href="#第22章-Etcd–高可用的键值数据库" class="headerlink" title="第22章 Etcd–高可用的键值数据库"></a>第22章 Etcd–高可用的键值数据库</h1><h3 id="22-1-简介"><a href="#22-1-简介" class="headerlink" title="22.1 简介"></a>22.1 简介</h3><h3 id="22-2-安装和使用Etcd"><a href="#22-2-安装和使用Etcd" class="headerlink" title="22.2 安装和使用Etcd"></a>22.2 安装和使用Etcd</h3><h3 id="22-3-使用etcdctl客户端"><a href="#22-3-使用etcdctl客户端" class="headerlink" title="22.3 使用etcdctl客户端"></a>22.3 使用etcdctl客户端</h3><h5 id="22-3-1-数据类操作"><a href="#22-3-1-数据类操作" class="headerlink" title="22.3.1 数据类操作"></a>22.3.1 数据类操作</h5><h5 id="22-3-2-非数据类操作"><a href="#22-3-2-非数据类操作" class="headerlink" title="22.3.2 非数据类操作"></a>22.3.2 非数据类操作</h5><h3 id="22-4-Etcd集群管理"><a href="#22-4-Etcd集群管理" class="headerlink" title="22.4 Etcd集群管理"></a>22.4 Etcd集群管理</h3><h5 id="22-4-1-构建集群"><a href="#22-4-1-构建集群" class="headerlink" title="22.4.1 构建集群"></a>22.4.1 构建集群</h5><h5 id="22-4-2-集群参数配置"><a href="#22-4-2-集群参数配置" class="headerlink" title="22.4.2 集群参数配置"></a>22.4.2 集群参数配置</h5><h3 id="22-5-本章小结"><a href="#22-5-本章小结" class="headerlink" title="22.5 本章小结"></a>22.5 本章小结</h3><hr>
<h1 id="第23章-Docker三剑客之Docker-Machine"><a href="#第23章-Docker三剑客之Docker-Machine" class="headerlink" title="第23章 Docker三剑客之Docker Machine"></a>第23章 Docker三剑客之Docker Machine</h1><h3 id="23-1-简介"><a href="#23-1-简介" class="headerlink" title="23.1 简介"></a>23.1 简介</h3><h3 id="23-2-安装Machine"><a href="#23-2-安装Machine" class="headerlink" title="23.2 安装Machine"></a>23.2 安装Machine</h3><h3 id="23-3-使用Machine"><a href="#23-3-使用Machine" class="headerlink" title="23.3 使用Machine"></a>23.3 使用Machine</h3><h3 id="23-4-Machine命令"><a href="#23-4-Machine命令" class="headerlink" title="23.4 Machine命令"></a>23.4 Machine命令</h3><h3 id="23-5-本章小结"><a href="#23-5-本章小结" class="headerlink" title="23.5 本章小结"></a>23.5 本章小结</h3><hr>
<h1 id="第24章-Docker三剑客之Docker-Compose"><a href="#第24章-Docker三剑客之Docker-Compose" class="headerlink" title="第24章 Docker三剑客之Docker Compose"></a>第24章 Docker三剑客之Docker Compose</h1><h3 id="24-1简介"><a href="#24-1简介" class="headerlink" title="24.1简介"></a>24.1简介</h3><h3 id="24-2-安装与卸载"><a href="#24-2-安装与卸载" class="headerlink" title="24.2 安装与卸载"></a>24.2 安装与卸载</h3><h3 id="24-3-Compose命令说明"><a href="#24-3-Compose命令说明" class="headerlink" title="24.3 Compose命令说明"></a>24.3 Compose命令说明</h3><h3 id="24-4-Compose环境变量"><a href="#24-4-Compose环境变量" class="headerlink" title="24.4 Compose环境变量"></a>24.4 Compose环境变量</h3><h3 id="24-5-Compose模板文件"><a href="#24-5-Compose模板文件" class="headerlink" title="24.5 Compose模板文件"></a>24.5 Compose模板文件</h3><h3 id="24-6-Compose应用案例一-Web负载均衡"><a href="#24-6-Compose应用案例一-Web负载均衡" class="headerlink" title="24.6 Compose应用案例一:Web负载均衡"></a>24.6 Compose应用案例一:Web负载均衡</h3><h3 id="24-7-Compose应用案例二-大数据Spark集群"><a href="#24-7-Compose应用案例二-大数据Spark集群" class="headerlink" title="24.7 Compose应用案例二:大数据Spark集群"></a>24.7 Compose应用案例二:大数据Spark集群</h3><h3 id="24-8-本章小结"><a href="#24-8-本章小结" class="headerlink" title="24.8 本章小结"></a>24.8 本章小结</h3><hr>
<h1 id="第25章-Docker三剑客之Docker-Swarm"><a href="#第25章-Docker三剑客之Docker-Swarm" class="headerlink" title="第25章 Docker三剑客之Docker Swarm"></a>第25章 Docker三剑客之Docker Swarm</h1><h3 id="25-1-简介"><a href="#25-1-简介" class="headerlink" title="25.1 简介"></a>25.1 简介</h3><h3 id="25-2-安装Swarm"><a href="#25-2-安装Swarm" class="headerlink" title="25.2 安装Swarm"></a>25.2 安装Swarm</h3><h3 id="25-3-使用Swarm"><a href="#25-3-使用Swarm" class="headerlink" title="25.3 使用Swarm"></a>25.3 使用Swarm</h3><h3 id="25-4-使用其他服务发现后端"><a href="#25-4-使用其他服务发现后端" class="headerlink" title="25.4 使用其他服务发现后端"></a>25.4 使用其他服务发现后端</h3><h3 id="25-5-Swarm中的调度器"><a href="#25-5-Swarm中的调度器" class="headerlink" title="25.5 Swarm中的调度器"></a>25.5 Swarm中的调度器</h3><h3 id="25-6-Swarm中的过滤器"><a href="#25-6-Swarm中的过滤器" class="headerlink" title="25.6 Swarm中的过滤器"></a>25.6 Swarm中的过滤器</h3><h3 id="25-7-本章小结"><a href="#25-7-本章小结" class="headerlink" title="25.7 本章小结"></a>25.7 本章小结</h3><hr>
<h1 id="第26章-Mesos–优秀的集群资源调度平台"><a href="#第26章-Mesos–优秀的集群资源调度平台" class="headerlink" title="第26章 Mesos–优秀的集群资源调度平台"></a>第26章 Mesos–优秀的集群资源调度平台</h1><h3 id="26-1-简介"><a href="#26-1-简介" class="headerlink" title="26.1 简介"></a>26.1 简介</h3><h3 id="26-2-Mesos安装与使用"><a href="#26-2-Mesos安装与使用" class="headerlink" title="26.2 Mesos安装与使用"></a>26.2 Mesos安装与使用</h3><h3 id="26-3-原理与架构"><a href="#26-3-原理与架构" class="headerlink" title="26.3 原理与架构"></a>26.3 原理与架构</h3><h5 id="26-3-1-架构"><a href="#26-3-1-架构" class="headerlink" title="26.3.1 架构"></a>26.3.1 架构</h5><h5 id="26-3-2-基本单元"><a href="#26-3-2-基本单元" class="headerlink" title="26.3.2 基本单元"></a>26.3.2 基本单元</h5><h5 id="26-3-3-调度"><a href="#26-3-3-调度" class="headerlink" title="26.3.3 调度"></a>26.3.3 调度</h5><h5 id="26-3-4-高可用性"><a href="#26-3-4-高可用性" class="headerlink" title="26.3.4 高可用性"></a>26.3.4 高可用性</h5><h3 id="26-4-Mesos配置项解析"><a href="#26-4-Mesos配置项解析" class="headerlink" title="26.4 Mesos配置项解析"></a>26.4 Mesos配置项解析</h3><h5 id="26-4-1-通用项"><a href="#26-4-1-通用项" class="headerlink" title="26.4.1 通用项"></a>26.4.1 通用项</h5><h5 id="26-4-2-master专属项"><a href="#26-4-2-master专属项" class="headerlink" title="26.4.2 master专属项"></a>26.4.2 master专属项</h5><h5 id="26-4-3-slave专属项"><a href="#26-4-3-slave专属项" class="headerlink" title="26.4.3 slave专属项"></a>26.4.3 slave专属项</h5><h3 id="26-5-日志与监控"><a href="#26-5-日志与监控" class="headerlink" title="26.5 日志与监控"></a>26.5 日志与监控</h3><h3 id="26-6-常见应用框架"><a href="#26-6-常见应用框架" class="headerlink" title="26.6 常见应用框架"></a>26.6 常见应用框架</h3><h3 id="26-7-本章小结"><a href="#26-7-本章小结" class="headerlink" title="26.7 本章小结"></a>26.7 本章小结</h3><hr>
<h1 id="第27章-Kubernetes–生产级容器集群平台"><a href="#第27章-Kubernetes–生产级容器集群平台" class="headerlink" title="第27章 Kubernetes–生产级容器集群平台"></a>第27章 Kubernetes–生产级容器集群平台</h1><h3 id="27-1-简介"><a href="#27-1-简介" class="headerlink" title="27.1 简介"></a>27.1 简介</h3><h3 id="27-2-核心概念"><a href="#27-2-核心概念" class="headerlink" title="27.2 核心概念"></a>27.2 核心概念</h3><h5 id="27-2-1-集群组件"><a href="#27-2-1-集群组件" class="headerlink" title="27.2.1 集群组件"></a>27.2.1 集群组件</h5><h5 id="27-2-2-资源抽象"><a href="#27-2-2-资源抽象" class="headerlink" title="27.2.2 资源抽象"></a>27.2.2 资源抽象</h5><h5 id="27-2-3-辅助概念"><a href="#27-2-3-辅助概念" class="headerlink" title="27.2.3 辅助概念"></a>27.2.3 辅助概念</h5><h3 id="27-3-快速体验"><a href="#27-3-快速体验" class="headerlink" title="27.3 快速体验"></a>27.3 快速体验</h3><h3 id="27-4-安装部署"><a href="#27-4-安装部署" class="headerlink" title="27.4 安装部署"></a>27.4 安装部署</h3><h3 id="27-5-重要组件"><a href="#27-5-重要组件" class="headerlink" title="27.5 重要组件"></a>27.5 重要组件</h3><h5 id="27-5-1-Etcd"><a href="#27-5-1-Etcd" class="headerlink" title="27.5.1 Etcd"></a>27.5.1 Etcd</h5><h5 id="27-5-2-kube-apiserver"><a href="#27-5-2-kube-apiserver" class="headerlink" title="27.5.2 kube-apiserver"></a>27.5.2 kube-apiserver</h5><h5 id="27-5-3-kube-scheduler"><a href="#27-5-3-kube-scheduler" class="headerlink" title="27.5.3 kube-scheduler"></a>27.5.3 kube-scheduler</h5><h5 id="27-5-4-kube-controller-manager"><a href="#27-5-4-kube-controller-manager" class="headerlink" title="27.5.4 kube-controller-manager"></a>27.5.4 kube-controller-manager</h5><h5 id="27-5-5-kubelet"><a href="#27-5-5-kubelet" class="headerlink" title="27.5.5 kubelet"></a>27.5.5 kubelet</h5><h5 id="27-5-6-kube-proxy"><a href="#27-5-6-kube-proxy" class="headerlink" title="27.5.6 kube-proxy"></a>27.5.6 kube-proxy</h5><h3 id="27-6-使用kubectl"><a href="#27-6-使用kubectl" class="headerlink" title="27.6 使用kubectl"></a>27.6 使用kubectl</h3><h5 id="27-6-1-获取kubectl"><a href="#27-6-1-获取kubectl" class="headerlink" title="27.6.1 获取kubectl"></a>27.6.1 获取kubectl</h5><h5 id="27-6-2-命令格式"><a href="#27-6-2-命令格式" class="headerlink" title="27.6.2 命令格式"></a>27.6.2 命令格式</h5><h5 id="27-6-3-全局参数"><a href="#27-6-3-全局参数" class="headerlink" title="27.6.3 全局参数"></a>27.6.3 全局参数</h5><h5 id="27-6-4-子命令"><a href="#27-6-4-子命令" class="headerlink" title="27.6.4 子命令"></a>27.6.4 子命令</h5><h3 id="27-7-网络设计"><a href="#27-7-网络设计" class="headerlink" title="27.7 网络设计"></a>27.7 网络设计</h3><h3 id="27-8-本章小结"><a href="#27-8-本章小结" class="headerlink" title="27.8 本章小结"></a>27.8 本章小结</h3><hr>
<h1 id="第28章-其他相关项目"><a href="#第28章-其他相关项目" class="headerlink" title="第28章 其他相关项目"></a>第28章 其他相关项目</h1><h3 id="28-1-平台即服务方案"><a href="#28-1-平台即服务方案" class="headerlink" title="28.1 平台即服务方案"></a>28.1 平台即服务方案</h3><h5 id="28-1-1-Deis"><a href="#28-1-1-Deis" class="headerlink" title="28.1.1 Deis"></a>28.1.1 Deis</h5><h5 id="28-1-2-Flynn"><a href="#28-1-2-Flynn" class="headerlink" title="28.1.2 Flynn"></a>28.1.2 Flynn</h5><h3 id="28-2-持续集成平台-Drone"><a href="#28-2-持续集成平台-Drone" class="headerlink" title="28.2 持续集成平台 Drone"></a>28.2 持续集成平台 Drone</h3><h3 id="28-3-容器管理"><a href="#28-3-容器管理" class="headerlink" title="28.3 容器管理"></a>28.3 容器管理</h3><h5 id="28-3-1-Citadel"><a href="#28-3-1-Citadel" class="headerlink" title="28.3.1 Citadel"></a>28.3.1 Citadel</h5><h5 id="28-3-2-Shipyard"><a href="#28-3-2-Shipyard" class="headerlink" title="28.3.2 Shipyard"></a>28.3.2 Shipyard</h5><h5 id="28-3-3-DockerUI"><a href="#28-3-3-DockerUI" class="headerlink" title="28.3.3 DockerUI"></a>28.3.3 DockerUI</h5><h5 id="28-3-4-Panamax"><a href="#28-3-4-Panamax" class="headerlink" title="28.3.4 Panamax"></a>28.3.4 Panamax</h5><h5 id="28-3-5-Seagull"><a href="#28-3-5-Seagull" class="headerlink" title="28.3.5 Seagull"></a>28.3.5 Seagull</h5><h5 id="28-3-6-Dockerboard"><a href="#28-3-6-Dockerboard" class="headerlink" title="28.3.6 Dockerboard"></a>28.3.6 Dockerboard</h5><h3 id="28-4-编程开发"><a href="#28-4-编程开发" class="headerlink" title="28.4 编程开发"></a>28.4 编程开发</h3><h3 id="28-5-网络支持"><a href="#28-5-网络支持" class="headerlink" title="28.5 网络支持"></a>28.5 网络支持</h3><h5 id="28-5-1-pipework"><a href="#28-5-1-pipework" class="headerlink" title="28.5.1 pipework"></a>28.5.1 pipework</h5><h5 id="28-5-2-Flannel"><a href="#28-5-2-Flannel" class="headerlink" title="28.5.2 Flannel"></a>28.5.2 Flannel</h5><h5 id="28-5-3-Weave-Net"><a href="#28-5-3-Weave-Net" class="headerlink" title="28.5.3 Weave Net"></a>28.5.3 Weave Net</h5><h5 id="28-5-4-Calico"><a href="#28-5-4-Calico" class="headerlink" title="28.5.4 Calico"></a>28.5.4 Calico</h5><h3 id="28-6-日志处理"><a href="#28-6-日志处理" class="headerlink" title="28.6 日志处理"></a>28.6 日志处理</h3><h5 id="28-6-1-Docker-Fluentd"><a href="#28-6-1-Docker-Fluentd" class="headerlink" title="28.6.1 Docker-Fluentd"></a>28.6.1 Docker-Fluentd</h5><h5 id="28-6-2-Logspout"><a href="#28-6-2-Logspout" class="headerlink" title="28.6.2 Logspout"></a>28.6.2 Logspout</h5><h5 id="28-6-3-Sematext-agent-docker"><a href="#28-6-3-Sematext-agent-docker" class="headerlink" title="28.6.3 Sematext-agent-docker"></a>28.6.3 Sematext-agent-docker</h5><h3 id="28-7-服务代理工具"><a href="#28-7-服务代理工具" class="headerlink" title="28.7 服务代理工具"></a>28.7 服务代理工具</h3><h5 id="28-7-1-Traefik"><a href="#28-7-1-Traefik" class="headerlink" title="28.7.1 Traefik"></a>28.7.1 Traefik</h5><h5 id="28-7-2-Muguet"><a href="#28-7-2-Muguet" class="headerlink" title="28.7.2 Muguet"></a>28.7.2 Muguet</h5><h5 id="28-7-3-nginx-proxy"><a href="#28-7-3-nginx-proxy" class="headerlink" title="28.7.3 nginx-proxy"></a>28.7.3 nginx-proxy</h5><h3 id="28-8-标准与规范"><a href="#28-8-标准与规范" class="headerlink" title="28.8 标准与规范"></a>28.8 标准与规范</h3><h3 id="28-9-其他项目"><a href="#28-9-其他项目" class="headerlink" title="28.9 其他项目"></a>28.9 其他项目</h3><h5 id="28-9-1-CoreOS"><a href="#28-9-1-CoreOS" class="headerlink" title="28.9.1 CoreOS"></a>28.9.1 CoreOS</h5><h5 id="28-9-2-OpenStack支持"><a href="#28-9-2-OpenStack支持" class="headerlink" title="28.9.2 OpenStack支持"></a>28.9.2 OpenStack支持</h5><h5 id="28-9-3-dockerize"><a href="#28-9-3-dockerize" class="headerlink" title="28.9.3 dockerize"></a>28.9.3 dockerize</h5><h5 id="28-9-4-Unikernel"><a href="#28-9-4-Unikernel" class="headerlink" title="28.9.4 Unikernel"></a>28.9.4 Unikernel</h5><h5 id="28-9-5-容器化的虚拟机"><a href="#28-9-5-容器化的虚拟机" class="headerlink" title="28.9.5 容器化的虚拟机"></a>28.9.5 容器化的虚拟机</h5><h3 id="28-10-本章小结"><a href="#28-10-本章小结" class="headerlink" title="28.10 本章小结"></a>28.10 本章小结</h3><hr>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h3 id="附录A-常见问题总结"><a href="#附录A-常见问题总结" class="headerlink" title="附录A 常见问题总结"></a>附录A 常见问题总结</h3><h3 id="附录B-Docker命令查询"><a href="#附录B-Docker命令查询" class="headerlink" title="附录B Docker命令查询"></a>附录B Docker命令查询</h3><h3 id="附录C-参考资源链接"><a href="#附录C-参考资源链接" class="headerlink" title="附录C 参考资源链接"></a>附录C 参考资源链接</h3>

                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


    <hr />
    <h3>Kommentare:</h3>
    <div id="fb-root"></div>
    <script>
        (function(d, s, id) {
            var js, fjs = d.getElementsByTagName(s)[0];
            if (d.getElementById(id)) return;
            js = d.createElement(s); js.id = id;
            js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=397462077298331";
            fjs.parentNode.insertBefore(js, fjs);
        }(document, 'script', 'facebook-jssdk'));
    </script>

    <div class="fb-comments" data-href="http://www.mamian.net/2017/07/23/《Docker技术入门与实战》读书笔记/index.html" data-num-posts="5" data-width="100%" data-colorscheme="light"></div>


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/mamian" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">© 2016  <a href="http://www.mamian.net/" target="_blank">mamian</a>  All Rights Reserved</p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>